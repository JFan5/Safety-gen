
\section{Preliminaries}\label{sec:preliminaries}
This section briefly reviews classical planning and PDDL with safety constraints,
and then introduces the formal robotic task-planning model studied in this work.

\subsection{Classical Planning and PDDL}
In classical planning, a problem is defined as
$\Pi=\langle \mathcal{F}, \mathcal{A}, I, \mathcal{G} \rangle$,
where $\mathcal{F}$ denotes the set of fluents, $\mathcal{A}$ the action set,
$I\subseteq\mathcal{F}$ the initial state, and $\mathcal{G}$ the goal condition.
Each action $a\in\mathcal{A}$ is associated with preconditions $\mathrm{Pre}(a)$
and effects $\mathrm{Eff}(a)$.
A plan is a finite action sequence whose execution from $I$ leads to a state
satisfying $\mathcal{G}$.

Planning problems are commonly specified using
PDDL~\cite{aeronautiques1998pddl}, which provides a structured format
to describe actions, predicates, objects, initial states, and goals.
PDDL has become the de facto standard for representing classical planning benchmarks.

PDDL3 extends PDDL with constructs for specifying temporal constraints and preferences
over plans~\cite{gerevini2005plan}.
In particular, safety constraints can be encoded using the \texttt{:constraints}
field as temporal formulas that restrict all valid plans.
For example, the following constraint enforces that no block is ever placed on top
of a fragile block:
\begin{lstlisting}[style=lispstyle]
(:constraints
  (always
    (forall (?x - fragile-block ?y - block)
      (not (on ?y ?x)))))
\end{lstlisting}
In this work, we focus on hard safety constraints that must be satisfied by all
valid plans.

\subsection{Robotic Task Planning}
We formalize a robotic task-planning problem as a tuple
$\mathcal{P} = (\mathcal{S}, \mathcal{A}, s_0, \mathcal{G}, \mathcal{C})$,
where $\mathcal{S}$ denotes the (possibly hybrid) state space of the robotic system,
$\mathcal{A}$ is the set of available actions or control decisions,
$s_0 \in \mathcal{S}$ is the initial state,
$\mathcal{G}$ is the goal condition,
and $\mathcal{C}$ is a set of formal safety constraints that define the safe operating
region of the system.
Each constraint $C \in \mathcal{C}$ may specify either a state invariant that must hold
at every state along execution or a trajectory-level requirement capturing temporal
patterns such as ``eventually,'' ``until,'' or ``before.''

\paragraph{Safety-Aware Planning.}
A plan is defined as a finite sequence of actions
$\pi = [a_1, a_2, \dots, a_n]$
that induces a state trajectory
$s_0 \xrightarrow{a_1} s_1 \xrightarrow{a_2} \cdots \xrightarrow{a_n} s_n$.
The plan is \emph{goal-reaching} if the final state satisfies the goal condition,
i.e., $s_n \models \mathcal{G}$, and it is \emph{safe} if it respects all safety
constraints, denoted by $\pi \models \mathcal{C}$.
Safety-aware planning requires finding a plan that satisfies both conditions:
\begin{equation}
  \text{find } \pi \text{ s.t. } s_n \models \mathcal{G} \;\land\; \pi \models \mathcal{C}.
\end{equation}
While classical search-based planners enforce safety constraints explicitly during planning, LLM-based planners generate plans as sequences and do not inherently simulate state transitions against formal constraints. As a result, safety must be learned from data or feedback, or enforced through external
verification and correction mechanisms.

\paragraph{Safety-Generalizable Planning.}
Beyond solving individual planning problems, we require planners to generalize safety reasoning.
In safety-critical settings, this requirement extends to safety constraints themselves:
a planner should satisfy safety constraints in new problems or domains, a property
we refer to as \emph{safety generalizability}.
We distinguish two complementary forms of safety generalization.

\noindent\textbf{Cross-Problem Safety Generalizability.}
Fix a domain $D=(\mathcal{S}, \mathcal{A}, \mathcal{C})$ with shared state and action
semantics and a common set of safety constraints.
A model $\mathcal{M}$ exhibits cross-problem safety generalization if, for unseen problems
$\mathcal{P}_i \in D$ with different initial states and goals, it produces plans that are
both goal-reaching and safe:
\begin{equation}
  \forall \mathcal{P}_i \in D:\;
  \pi_i = \mathcal{M}(\mathcal{P}_i)
  \Rightarrow
  (s_n^i \models \mathcal{G}_i \;\land\; \pi_i \models \mathcal{C}).
\end{equation}
\noindent\textbf{Cross-Domain Safety Generalizability.}
Let $\{D_1, \dots, D_K\}$ denote a collection of planning domains, each with its own
state and action semantics and associated safety-constraint set.
A model $\mathcal{M}$ exhibits cross-domain safety generalizability if, for any domain
$D_j$ in this collection and any planning problem $\mathcal{P}_i \in D_j$, it produces
a plan that is both goal-reaching and safe:
\begin{equation}
  \forall D_j,\;
  \forall \mathcal{P}_i \in D_j:\;
  \pi_i = \mathcal{M}(\mathcal{P}_i)
  \Rightarrow
  (s_n^i \models \mathcal{G}_i \;\land\; \pi_i \models \mathcal{C}_j).
\end{equation}

Together, these requirements characterize the objective of safety-generalizable robotic
task planning studied in this work: the planner should produce plans that are safe by construction and sustain this property on unseen problems within and across domains.

\begin{table*}[t]
  \centering
  \caption{Brief introduction of the domains and their safety constraints.}
  \label{tab:domain-introduction}
  \begin{tabularx}{0.95\linewidth}{l|X|X}
    \hline
    \textbf{Domain} & \textbf{Description} & \textbf{Safety Constraints} \\
    \hline
    \textbf{Blocksworld} &
    The agent must rearrange stacked blocks into a desired configuration using pick-and-place actions. &
    Blocks must be stacked in a safe and stable order, e.g., a supporting block must be positioned before the blocks it supports. \\
    \hline
    \textbf{Ferry} &
    The agent controls a ferry that transports cars between locations. &
    The ferry must never be overloaded, and cars must safely reach their destinations before the ferry departs or returns. \\
    \hline
    \textbf{Grippers} &
    A robot with two grippers must pick up and deliver all objects to a target room. &
    Robots (or manipulators) must avoid operating simultaneously in the same narrow room, and certain grippers may be restricted for safety-critical objects. \\
    \hline
    \textbf{Spanner} &
    A worker must collect spanners and tighten all nuts across connected locations. &
    Bolts must be tightened in a safe sequence (e.g., foundation nuts before upper ones), and access to shared tools (e.g., entering the tool shed) is limited to prevent unsafe congestion. \\
    \hline
  \end{tabularx}
\end{table*}
