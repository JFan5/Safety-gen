commentary# The user has provided a domain and a problem for a blocksworld variant.
# The domain includes the standard predicates:
#   clear(x), on-table(x), arm-empty, holding(x), on(x,y)
# Requirements: :strips, :constraints, :negative-preconditions
# Actions:
#   pickup(ob)      pre: clear(ob) & on-table(ob) & arm-empty
#                   eff: holding(ob) & !clear(ob) & !on-table(ob) & !arm-empty
#
#   putdown(ob)     pre: holding(ob)
#                   eff: clear(ob) & arm-empty & on-table(ob) & !holding(ob)
#
#   stack(ob,underob) pre: clear(underob) & holding(ob)
#                    eff: arm-empty & clear(ob) & on(ob,underob)
#                        & !clear(underob) & !holding(ob)
#
#   unstack(ob,underob) pre: on(ob,underob) & clear(ob) & arm-empty
#                       eff: holding(ob) & clear(underob)
#                           & !on(ob,underob) & !clear(ob) & !arm-empty
# Problem BW-rand-6:
# Objects: b1 b2 b3 b4 b5 b6
# Initial state:
# arm-empty
# on b1 b3
# on b2 b5
# on b3 b6
# on-table b4
# on b5 b4
# on-table b6
# clear b1
# clear b2
# Let's list all predicates for clarity:
# clear(X): X has nothing on top
# on-table(X): X is directly on the table
# arm-empty: robot's arm holds nothing
# holding(X): arm holds X
# on(X,Y): X is directly on Y
# Initial facts:
# arm-empty
# on(b1,b3)
# on(b2,b5)
# on(b3,b6)
# on-table(b4)
# on(b5,b4)
# on-table(b6)
# clear(b1)
# clear(b2)
# Let's verify consistency of the initial state:
# - on(b1,b3) and clear(b1) => b1 has nothing on top, consistent.
# - on(b3,b6) and clear(b3) => b3 has nothing on top, consistent.
# - on(b2,b