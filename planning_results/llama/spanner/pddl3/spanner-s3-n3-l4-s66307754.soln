import (open)
import (re)

# Produce a valid, grounded, totally-ordered plan for the input below.
# <DOMAIN>
# (domain spanner)
# (:requirements :typing :strips :constraints)
#
# (:types 
#     location locatable - object
#     man nut spanner - locatable   
# )
#
# (:predicates 
#     (at?m - locatable?l - location)
#     (carrying?m - man?s - spanner)
#     (useable?s - spanner)
#     (link?l1 - location?l2 - location)
#     (tightened?n - nut)
#     (loose?n - nut))
#
# (:action walk 
#        :parameters (?start - location?end - location?m - man)
#        :precondition (and (at?m?start) 
#                           (link?start?end))
#        :effect (and (not (at?m?start)) (at?m?end)))
#
# (:action pickup_spanner 
#        :parameters (?l - location?s - spanner?m - man)
#        :precondition (and (at?m?l) 
#                           (at?s?l))
#        :effect (and (not (at?s?l))
#                     (carrying?m?s)))
#
# (:action tighten_nut 
#        :parameters (?l - location?s - spanner?m - man?n - nut)
#        :precondition (and (at?m?l) 
#		      	   (at?n?l)
#			   (carrying?m?s)
#			   (useable?s)
#			   (loose?n))
#        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
# )
# </DOMAIN>

# <PROBLEM>
#  ; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 66307754 --problem-name spanner-s3-n3-l4-s66307754
# (define (problem spanner-s3-n3-l4-s66307754)
#  (:domain spanner)
#  (:objects 
#     bob - man
#     spanner1 spanner2 spanner3 - spanner
#     nut1 nut2 nut3 - nut
#     location1 location2 location3 location4 - location
#     shed gate - location
#    )
#  (:init 
#     (at bob shed)
#     (at spanner1 location2)
#     (useable spanner1)
#     (at spanner2 location2)
#     (useable spanner2)
#     (at spanner3 location4)
#     (useable spanner3)
#     (loose nut1)
#     (at nut1 gate)
#     (loose nut2)
#     (at nut2 gate)
#     (loose nut3)
#     (at nut3 gate)
#     (link shed location1)
#     (link location4 gate)
#     (link location1 location2)
#     (link location2 location3)
#     (link location3 location4)
# )
#  (:goal
#   (and
#    (tightened nut1)
#    (tightened nut2)
#    (tightened nut3)
#   )
# )
# (:constraints
#  (and
#    (sometime-before (tightened nut1) (tightened nut2))
#    (forall (?m - man) (at-most-once (at?m shed)))
#  )
#)
# </PROBLEM>

## Planning Rules
# 1) Only use available symbols:
#    - objects declared under PROBLEM :objects, and
#    - constants declared under DOMAIN/PROBLEM :constants (if any).
#    Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

# 2) Constraints:
#    - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
#    - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

# 3) Plan form:
#    - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

# 4) Internal validation before emitting (do not include reasoning in the output):
#    - At each step, all action preconditions hold in the current state.
#    - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
#    - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
# - Return **ONLY** the plan steps, one per line.
# - Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
# - Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
# - No numbering, timestamps, costs, comments, headers, code fences, or extra text.
# - No blank lines at the start or end; no trailing spaces; use a single space between tokens.
# - If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
# - If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
# Bad:
# - Plan:
# - Here is the plan:
# - (move a b)  (two actions on one line)
# - (move a) extra

# Good:
# (move a b)
# (pick a c)
# (drop a d)

## Produce a valid, grounded, totally-ordered plan for the input below.
objects = (
    ("bob", "man")
    ("spanner1", "spanner")
    ("spanner2", "spanner")
    ("spanner3", "spanner")
    ("nut1", "nut")
    ("nut2", "nut")
    ("nut3", "nut")
    ("location1", "location")
    ("location2", "location")
    ("location3", "location")
    ("location4", "location")
    ("shed", "location")
    ("gate", "location")
)
constraints = (
    # No constraints provided
)

actions = (
    ("walk", "action")
    ("pickup_spanner", "action")
    ("tighten_nut", "action")
)

predicates = (
    ("at", "predicate")
    ("carrying", "predicate")
    ("useable", "predicate")
    ("link", "predicate")
    ("tightened", "predicate")
    ("loose", "predicate")
)

domain_rules = (
    # (domain spanner)
    (#requirements :typing :strips :constraints),      

    (#types 
     (location locatable - object)
     (man nut spanner - locatable   
     ),      

    (#predicates 
     (at?m - locatable?l - location)
     (carrying?m - man?s - spanner)
     (useable?s - spanner)
     (link?l1 - location?l2 - location)
     (tightened?n - nut)
     (loose?n - nut)
     ),      

    (#action walk 
     (parameters (?start - location?end - location?m - man)
     (precondition (and (at?m?start) 
                           (link?start?end)))
     (effect (and (not (at?m?start)) (at?m?end)))
     ),      

    (#action pickup_spanner 
     (parameters (?l - location?s - spanner?m - man)
     (precondition (and (at?m?l) 
                           (at?s?l)))
     (effect (and (not (at?s?l))
                   (carrying?m?s)))
     ),      

    (#action tighten_nut 
     (parameters (?l - location?s - spanner?m - man?n - nut)
     (precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
     (effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
     )
    )

objects = tuple(objects)
constraints = tuple(constraints)
actions = tuple(actions)
predicates = tuple(predicates)
domain_rules = tuple(domain_rules)

# Produce a valid, grounded, totally-ordered plan for the input below.
available_objects = objects
constraints = constraints
available_actions = [action_ for action_, action in zip(actions, domain_rules) if action_ == action]
plan = []

def validate_plan(available_objects, available_actions, objects, constraints, predicates, domain_rules, plan):
    objects_used = set()
    actions_used = set()

    for obj in plan:
        if obj in objects_used:
            return False
        objects_used.add(obj)