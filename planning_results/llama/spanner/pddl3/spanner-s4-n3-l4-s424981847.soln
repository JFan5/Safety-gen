import spanner_generator

problem_name = "spanner-s4-n3-l4-s424981847"
spanner_generator.generate_spanner_problem(problem_name)
domain = spanner_generator.get_domain(problem_name)
problem = spanner_generator.get_problem(problem_name)

objects = problem.objects
constants = spanner_generator.get_constants(domain, problem)

available_objects = []
for obj in objects:
    if obj.startswith('spanner') or obj.startswith('nut') or obj.startswith('location'):
        available_objects.append(obj)

available_actions = []
for action in spanner_generator.get_available_actions(domain, problem, objects, constants):
    args = spanner_generator.get_action_args(action, domain, problem, objects, constants)
    if len(args) == len(available_objects):
        available_actions.append((action, args))

available_actions = spanner_generator.filter_constraints(available_actions, problem)

sequential_available_actions = []
for action, args in available_actions:
    if spanner_generator.is_action_sequential(action, domain, problem):
        sequential_available_actions.append((action, args))

sequential_available_actions = spanner_generator.filter_initial_state(sequential_available_actions, domain, problem)

goal = problem.goal
constraints = spanner_generator.get_constraints(problem)

sequential_goal_actions = spanner_generator.get_goal_actions(sequential_available_actions, goal, constraints)

sequential_goal_actions = spanner_generator.filter_internal_validation(sequential_goal_actions, domain, problem)

if len(sequential_goal_actions) == 0:
    print("NO-PLAN")
else:
    plan = spanner_generator.generate_plan(sequential_goal_actions, domain, problem)
    for step in plan:
        print(step)