import spanner_generator

problem_name = "spanner-s4-n3-l5-s1505956009"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)
print()

problem = "<PROBLEM>"
print(problem)
print()

spanner_generator.generate_spanner_problem(problem_name)

rules = """
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

"""
constraints = """
and
 (sometime-before (tightened nut2) (tightened nut3))
and
 (forall (?m - man) (at-most-once (at?m shed)))
"""

domain_objects = """
(:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
"""

problem_objects = """
(:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
"""

action_walk = """
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))
"""

action_pick_spanner = """
(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))
"""

action_tighten_nut = """
(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
"""

domain_predicates = """
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))
"""

problem_predicates = """
(:predicates
  (and
   (sometime-before (tightened nut2) (tightened nut3))
   (forall (?m - man) (at-most-once (at?m shed)))
  )
"""

domain_constants = """
()

"""

problem_constants = """
()

"""

print("DOMAIN")
print(domain_objects)
print()
print("PROBLEM")
print(problem_objects)
print()
print("RULES")
print(rules)
print()
print("CONSTRANTS")
print(constraints)
print()

available_symbols = set(domain_objects.split() + problem_objects.split()) - {
    '(:objects', '(:action', '(:predicates', '(:constraints', '(:parameters', '(:effect', '(:precondition'
} 

available_symbols = sorted(list(available_symbols)) 

objects = {}
actions = {}
predicates = {}
constraints = {}

for symbol in available_symbols:
    if symbol.startswith('(:'):
        if symbol.endswith(')'):
            name = symbol[2:-1]
            if name in objects:
                print(f"Error: Object {name} already exists.")
                exit()
            objects[name] = len(objects)
        elif symbol == '(:objects':
            continue
        elif symbol == '(:action':
            continue
        elif symbol == '(:predicates':
            continue
        elif symbol == '(:constraints':
            continue
        elif symbol == '(:parameters':
            continue
        elif symbol == '(:effect':
            continue
        elif symbol == '(:precondition':
            continue
        else:
            raise Exception(f"Unknown symbol: {symbol}")
    else:
        if symbol.isnumeric():
            continue
        if '_' in symbol:
            name, separator = symbol.split('_', 1)
            if name in objects:
                print(f"Error: Object {name} already exists.")
                exit()
            objects[name] = len(objects)
        else:
            if symbol in objects:
                print(f"Error: Object {symbol} already exists.")
                exit()
            objects[symbol] = len(objects)

for obj in objects.values():
    name = f"{obj:03d}"
    symbols = [f":{name}"] + [f"{name}{i:03d}" for i in range(1, 8)] + [f":{name}n", f":{name}m"]
    for symbol in symbols:
        if symbol in available_symbols:
            if symbol == f":{name}n":
                predicates[name + "n"] = len(predicates)
            elif symbol == f":{name}m":
                predicates[name + "m"] = len(predicates)
            elif symbol == f":{name}":
                actions[name] = len(actions)
            else:
                constraints[name] = len(constraints)

print("OBJECTS")
for obj in objects.values():
    print(f"{obj:03d}: {objects[obj]}")

print()
print("ACTIONS")
for action in actions.values():
    print(f"{action:03d}: {actions[action]}")

print()
print("PREDICATES")
for pred in predicates.values():
    print(f"{pred:03d}: {predicates[pred]}")

print()
print("CONSTRAINTS")
for constraint in constraints.values():
    print(f"{constraint:03d}: {constraints[constraint]}")

available_symbols = sorted(list(available_symbols))

domain = ""
problem = ""

domain_objects = ""
problem_objects = ""

domain_predicates = ""
problem_predicates = ""

domain_constants = ""
problem_constants = ""

print("DOMAIN")
domain_objects = f"""
(:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
"""
for obj in objects.values():
    name = f"{obj:03d}"
    domain_objects += f"""
    ({name})
"""
domain_predicates = f"""
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut)
"""
for pred in predicates.values():
    name = f"{pred:03d}n"
    domain_predicates += f"""
    ({name})
"""
for pred in predicates.values():
    name = f"{pred:03d}m"
    domain_predicates += f"""
    ({name})
"""
domain_constants = ""
for constraint in constraints.values():
    name = f"{constraint:03d}"
    domain_constants += f"""
    ({name})
"""

domain = f"""
(:domain spanner)
({domain_objects