import spanner_generator
problem_name = "spanner-s4-n3-l4-s645105511"
spanner_generator.generate_problem(problem_name)
# Produce a valid, grounded, totally-ordered plan
import pddlplan2
domain = "domain/spanner.pddl"
problem = "problem/spanner-s4-n3-l4-s645105511.pddl"
pddlplan2.generate_plan(domain, problem, ["spanner-s4-n3-l4-s645105511"], False, False)

# Internal validation before emitting
def validate_plan(plan, domain, problem):
    # At each step, all action preconditions hold in the current state.
    # Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
    # If constraints exist in PROBLEM, ensure the plan satisfies all of them.
    pass

# Output Requirements
def emit_plan(plan, domain, problem):
    # Return **ONLY** the plan steps, one per line.
    # Each line must be exactly: `<action-name> <obj1> <obj2>...`
    # Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
    # No numbering, timestamps, costs, comments, headers, code fences, or extra text.
    # No blank lines at the start or end; no trailing spaces; use a single space between tokens.
    output = ""
    for step in plan:
        action = step[0]
        objects = step[1:]
        obj_str = " ".join([f"{obj}:obj" for obj in objects])
        output += f"({action} {obj_str})\n"
    return output.strip()

# Generate and validate the plan
plan = pddlplan2.generate_plan(domain, problem, ["spanner-s4-n3-l4-s645105511"], False, False)
validation_result = validate_plan(plan, domain, problem)
output = emit_plan(plan, domain, problem)

# Print the output
print(output)