Here is the Python code to generate a plan based on the PDDL problem defined in the prompt:

```python
from copy import deepcopy
from heapq import heappush, heappop

class PDDL3:
    def __init__(self, domain, problem):
        self.domain = domain
        self.problem = problem
        self_constants = []
        self.objects = {}

        for obj in problem['objects']:
            name, obj_type = obj
            self.constants.append(name)
            self.objects[name] = obj_type

        self.action_objects = {}
        for action in domain['actions']:
            action_params = action['parameters']
            for i, param in enumerate(action_params):
                self.action_objects[action['name']] = self.action_objects.get(action['name'], [])
                self.action_objects[action['name']].append((param, i))

        self pred_and_fn = self.make_pred_and_fn()
        self.init_state = self.domain['init']

    def make_pred_and_fn(self):
        pred_and_fn = {}
        for pred in self.domain['predicates']:
            pred_and_fn[pred['name']] = (pred['parameters'], lambda state, predname=pred['name']:
                    [(param, state[p['key']]) for param, key in pred['parameters']])
        return pred_and_fn

    def is_precond(self, state, action, precond):
        for key, value in precond:
            if key not in state or state[key]!= value:
                return False

        return True

    def is_effect(self, state, action, effect):
        for key, value in effect:
            if key not in state or state[key]!= value:
                return False

        return True

    def is_valid_plan(self, plan, state):
        for action, new_state in plan:
            precond = self.pred_and_fn[action]['params'](state)
            if not self.is_precond(state, action, precond):
                return False

            effect = self.pred_and_fn[action]['fn'](state, action)
            if not self.is_effect(state, action, effect):
                return False

            state = new_state

        return True

    def get_ground_actions(self, actions, goals):
        ground_actions = []
        for action in actions:
            params = []
            for param, index in self.action_objects[action['name']]:
                for g_param in goals:
                    if g_param['name'] == param:
                        params.append(g_param['value'])

            new_action = deepcopy(action)
            for index, param in enumerate(self.action_objects[action['name']]):
                new_action['parameters'][index][1] = params[index]
            ground_actions.append(new_action)

        return ground_actions

    def find_valid_plan(self, goals):
        ground_actions = self.get_ground_actions(self.problem['actions'], goals)
        valid_plan = []
        init_state = deepcopy(self.init_state)
        open_list = [(0, init_state)]
        closed_list = set()

        while open_list:
            _, current_state = heappop(open_list)
            if self.is_valid_plan(valid_plan, current_state):
                for action in ground_actions:
                    new_state = deepcopy(current_state)
                    for key, value in action['parameters']:
                        if key =='start' and key == 'end':
                            pass
                        elif key == 'name':
                            new_state[key] = action['name']
                        else:
                            new_state[key] = value
                    heappush(open_list, (len(valid_plan) + 1, new_state))
                valid_plan.append((ground_actions[0]['name'], init_state))
                closed_list.add(str((ground_actions[0]['name'], init_state)))
                break

        if len(valid_plan) > 0:
            return valid_plan
        else:
            return ['NO-PLAN']

# PDDL3 Parameters
domain = '''
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
                           (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 2 4 --seed 329162299 --problem-name spanner-s3-n2-l4-s329162299
(define (problem spanner-s3-n2-l4-s329162299)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 - nut
     location1 location2 location3 location4 - location
    )
 (:init 
    (at bob location1)
    (at spanner1 location3)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (loose nut1)
    (at nut1 location3)
    (loose nut2)
    (at nut2 location3)
    (link location1 location2)
    (link location3 location4)
    (link location1 location4)
    (link location3 location4)
)
(:goal
  (and
   (tightened nut1)
   (tightened nut2)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Test the function
pddl3 = PDDL3(domain, problem)
plan = pddl3.find_valid_plan([(nut1, {}), (nut2, {})])
for step in plan:
    print(step)
```