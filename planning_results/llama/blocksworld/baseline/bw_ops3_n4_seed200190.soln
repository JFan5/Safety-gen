You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

(define (domain blocksworld)
  (:requirements :strips :constraints :negative-preconditions)
  (:predicates (clear?x)
               (on-table?x)
               (arm-empty)
               (holding?x)
               (on?x?y))

  (:action pickup
    :parameters (?ob)
    :precondition (and (clear?ob) (on-table?ob) (arm-empty))
    :effect (and (holding?ob) (not (clear?ob)) (not (on-table?ob)) 
                 (not (arm-empty))))

  (:action putdown
    :parameters  (?ob)
    :precondition (holding?ob)
    :effect (and (clear?ob) (arm-empty) (on-table?ob) 
                 (not (holding?ob))))

  (:action stack
    :parameters  (?ob?underob)
    :precondition (and (clear?underob) (holding?ob))
    :effect (and (arm-empty) (clear?ob) (on?ob?underob)
                 (not (clear?underob)) (not (holding?ob))))

  (:action unstack
    :parameters  (?ob?underob)
    :precondition (and (on?ob?underob) (clear?ob) (arm-empty))
    :effect (and (holding?ob) (clear?underob)
                 (not (on?ob?underob)) (not (clear?ob)) (not (arm-empty)))))

(define (problem BW-rand-4)
(:domain blocksworld)
(:objects b1 b2 b3 b4 )
(:init
(arm-empty)
(on-table b1)
(on b2 b4)
(on b3 b1)
(on-table b4)
(clear b2)
(clear b3)
)
(:goal
(and
(on-table b1)
(on b2 b4)
(on-table b3)
(on b4 b1))
)

(:constraints
  (sometime-before (on b2 b4) (on-table b1))
)

(move b1 b2)
(pick b4 b1)
(stack b4 b1)
(drop b1 b4)
(pick b3 b1)
(unstack b3 b1)
(drop b2 b3)