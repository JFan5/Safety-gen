You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain blocksworld)
  (:requirements :strips :constraints :negative-preconditions)
  (:predicates (clear?x)
               (on-table?x)
               (arm-empty)
               (holding?x)
               (on?x?y))

  (:action pickup
    :parameters (?ob)
    :precondition (and (clear?ob) (on-table?ob) (arm-empty))
    :effect (and (holding?ob) (not (clear?ob)) (not (on-table?ob)) 
                 (not (arm-empty))))

  (:action putdown
    :parameters  (?ob)
    :precondition (holding?ob)
    :effect (and (clear?ob) (arm-empty) (on-table?ob) 
                 (not (holding?ob))))

  (:action stack
    :parameters  (?ob?underob)
    :precondition (and (clear?underob) (holding?ob))
    :effect (and (arm-empty) (clear?ob) (on?ob?underob)
                 (not (clear?underob)) (not (holding?ob))))

  (:action unstack
    :parameters  (?ob?underob)
    :precondition (and (on?ob?underob) (clear?ob) (arm-empty))
    :effect (and (holding?ob) (clear?underob)
                 (not (on?ob?underob)) (not (clear?ob)) (not (arm-empty)))))

</DOMAIN>

<PROBLEM>
(define (problem BW-rand-5)
(:domain blocksworld)
(:objects b1 b2 b3 b4 b5 )
(:init
(arm-empty)
(on-table b1)
(on-table b2)
(on b3 b4)
(on-table b4)
(on-table b5)
(clear b1)
(clear b2)
(clear b3)
(clear b5)
)
(:goal
(and
(on b1 b3)
(on b2 b1)
(on b4 b5)
(on b5 b2))
)

(:constraints
  (sometime-before (on b2 b1) (on b1 b3))
)
)
</PROBLEM>

(move a b)
(pick a c)
(drop a d)