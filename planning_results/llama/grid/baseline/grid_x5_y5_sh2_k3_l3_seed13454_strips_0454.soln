To generate the final output, we need to parse the domain, problem, and constraints, and then plan the sequence of actions.

First, let's parse the domain:

```lisp
(define (domain grid)
    (:requirements :strips :constraints)
    (:predicates (conn?x?y)
                 (key-shape?k?s)
                 (lock-shape?x?s)
                 (at?r?x )
                 (at-robot?x)
                 (place?p)
                 (key?k)
                 (shape?s)
                 (locked?x)
                 (holding?k)
                 (open?x)
                 (arm-empty ))
    (:action unlock
      :parameters (?curpos?lockpos?key?shape)
      :precondition (and (place?curpos) (place?lockpos) (key?key) (shape?shape)
                        (conn?curpos?lockpos) (key-shape?key?shape)
                        (lock-shape?lockpos?shape) (at-robot?curpos) 
                        (locked?lockpos) (holding?key))
      :effect (and  (open?lockpos) (not (locked?lockpos))))
    (:action move
      :parameters (?curpos?nextpos)
      :precondition (and (place?curpos) (place?nextpos)
                        (at-robot?curpos) (conn?curpos?nextpos) (open?nextpos))
      :effect (and (at-robot?nextpos) (not (at-robot?curpos))))
    (:action pickup
      :parameters (?curpos?key)
      :precondition (and (place?curpos) (key?key) 
                        (at-robot?curpos) (at?key?curpos) (arm-empty ))
      :effect (and (holding?key)
                  (not (at?key?curpos))
                  (not (arm-empty ))))
    (:action pickup-and-loose
      :parameters (?curpos?newkey?oldkey)
      :precondition (and (place?curpos) (key?newkey) (key?oldkey)
                        (at-robot?curpos) (holding?oldkey) (at?newkey?curpos))
      :effect (and (holding?newkey)
                  (at?oldkey?curpos)
                  (not (holding?oldkey))
                  (not (at?newkey?curpos))))
    (:action putdown
      :parameters (?curpos?key)
      :precondition (and (place?curpos) (key?key) 
                        (at-robot?curpos) (holding?key))
      :effect (and (arm-empty )
                  (at?key?curpos)
                  (not (holding?key))))
    (:constraints
      (always (not (at-robot pos3-3))))
    ))
```

Now, let's parse the problem:

```lisp
(define (problem grid-5-5-2-3-3)
  (:domain grid)
  (:objects
    pos0-0 pos0-1 pos0-2 pos0-3 pos0-4 pos1-0 pos1-1 pos1-2 pos1-3 pos1-4 pos2-0 pos2-1 pos2-2 pos2-3 pos2-4 pos3-0 pos3-1 pos3-2 pos3-3 pos3-4 pos4-0 pos4-1 pos4-2 pos4-3 pos4-4
    shape0 shape1
    key0 key1 key2
    )
  (:init
    (arm-empty)
    (place pos0-0)
    (place pos0-1)
    (place pos0-2)
    (place pos0-3)
    (place pos0-4)
    (place pos1-0)
    (place pos1-1)
    (place pos1-2)
    (place pos1-3)
    (place pos1-4)
    (place pos2-0)
    (place pos2-1)
    (place pos2-2)
    (place pos2-3)
    (place pos2-4)
    (place pos3-0)
    (place pos3-1)
    (place pos3-2)
    (place pos3-3)
    (place pos3-4)
    (place pos4-0)
    (place pos4-1)
    (place pos4-2)
    (place pos4-3)
    (place pos4-4)
    (key-shape  key0 shape0)
    (key-shape  key1 shape1)
    (key-shape  key2 shape1)
    (at key0 pos3-1)
    (at key1 pos4-2)
    (at key2 pos3-2)
    )
  (:goal
    (and (at key1 pos4-2)
         (at key2 pos3-2))
    )
  )
```

Now, let's plan the sequence of actions:

1. Move the key0 to the position pos3-0.
2. Move the key0 to the position pos3-1.
3. Move the key0 to the position pos3-2.
4. Move the key0 to the position pos3-3.
5. Move the key0 to the position pos3-4.
6. Move the key0 to the position pos3-2.
7. Move the key0 to the position pos3-1.
8. Move the key0 to the position pos3-0.
9. Move the key1 to the position pos4-1.
10. Move the key1 to the position pos4-2.
11. Move the key1 to the position pos4-3.
12. Move the key1 to the position pos4-4.
13. Move the key1 to the position pos4-2.
14. Move the key1 to the position pos4-1.
15. Move the key1 to the position pos4-0.
16. Move the key1 to the position pos4-2.
17. Move the key2 to the position pos3-4.
18. Move the key2 to the position pos3-3.
19. Move the key2 to the position pos3-2.
20. Move the key2 to the position pos3-1.
21. Move the key2 to the position pos3-0.
22. Move the key2 to the position pos3-2.
23. Move the key2 to the position pos3-1.
24. Move the key2 to the position pos3-0.
25. Put down the key2.
26. Move the key2 to the position pos3-1.
27. Move the key2 to the position pos3-2.
28. Move the key2 to the position pos3-3.
29. Move the key2 to the position pos3-4.
30. Move the key2 to the position pos4-0.
31. Move the key2 to the position pos4-1.
32. Move the key2 to the position pos4-2.
33. Move the key2 to the position pos4-3.
34. Move the key2 to the position pos4-4.
35. Pick up the key0.
36. Pick up the key2.
37. Put down the key2.
38. Put down the key0.

The final output is:
(move pos0-0 pos3-0)
(move pos0-0 pos3-1)
(move pos0-0 pos3-2)
(move pos0-0 pos3-3)
(move pos0-0 pos3-4)
(move pos0-0 pos3-2)
(move pos0-0 pos3-1)
(move pos0-0 pos3-0)
(move pos1-0 pos4-1)
(move pos1-0 pos4-2)
(move pos1-0 pos4-3)
(move pos1-0 pos4-4)
(move pos1-0 pos4-2)
(move pos1-0 pos4-1)
(move pos1-0 pos4-0)
(move pos2-0 pos4-2)
(move pos2-0 pos4-3)
(move pos2-0 pos4-4)
(move pos2-0 pos4-2)
(move pos2-0 pos4-1)
(move pos2-0 pos4-0)
(move pos3-0 pos4-2)
(move pos3-0 pos4-3)
(move pos3-0 pos4-4)
(move pos3-0 pos4-2)
(move pos3-0 pos4-1)
(move pos3-0 pos4-0)
(putdown pos3-2)
(move pos3-2 pos3-1)
(move pos3-2 pos3-3)
(move pos3-2 pos3-4)
(move pos3-2 pos4-0)
(move pos3-2 pos4-1)
(move pos3-2 pos4-2)
(move pos3-2 pos4-3)
(move pos3-2 pos4-4)
(pickup pos3-2)
(putdown pos3-2)
(pickup pos3-1)
(putdown pos3-1)