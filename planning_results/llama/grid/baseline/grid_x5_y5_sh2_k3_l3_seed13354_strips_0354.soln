To produce a valid, grounded, totally-ordered plan for the given problem, we need to parse the domain, problem, and constraints, and then apply the planning rules to generate a plan.

First, let's parse the domain and problem:

```
(define (domain grid)
  (:requirements :strips :constraints)
  (:predicates conn shape locked holding open at robot)
  (:action unlock
    :parameters (?curpos?lockpos?key?shape)
    :precondition (and (place?curpos) (place?lockpos) (key?key) (shape?shape)
                      (conn?curpos?lockpos) (key-shape?key?shape)
                      (lock-shape?lockpos?shape) (at-robot?curpos) 
                      (locked?lockpos) (holding?key))
    :effect (and (open?lockpos) (not (locked?lockpos))))
  (:action move
    :parameters (?curpos?nextpos)
    :precondition (and (place?curpos) (place?nextpos) 
                      (at-robot?curpos) (conn?curpos?nextpos) (open?nextpos))
    :effect (and (at-robot?nextpos) (not (at-robot?curpos))))
  (:action pickup
    :parameters (?curpos?key)
    :precondition (and (place?curpos) (key?key) 
                      (at-robot?curpos) (at?key?curpos) (arm-empty ))
    :effect (and (holding?key) (not (at?key?curpos)) (not (arm-empty))))
  (:action pickup-and-loose
    :parameters (?curpos?newkey?oldkey)
    :precondition (and (place?curpos) (key?newkey) (key?oldkey) 
                      (at-robot?curpos) (holding?oldkey) (at?newkey?curpos))
    :effect (and (holding?newkey) (at?oldkey?curpos) 
        (not (holding?oldkey)) (not (at?newkey?curpos))))
  (:action putdown
    :parameters (?curpos?key)
    :precondition (and (place?curpos) (key?key) 
                      (at-robot?curpos) (holding?key))
    :effect (and (arm-empty ) (at?key?curpos) (not (holding?key))))
  (:objects
    pos0-0 pos0-1 pos0-2 pos0-3 pos0-4 pos1-0 pos1-1 pos1-2 pos1-3 pos1-4 pos2-0 pos2-1 pos2-2 pos2-3 pos2-4 pos3-0 pos3-1 pos3-2 pos3-3 pos3-4 pos4-0 pos4-1 pos4-2 pos4-3 pos4-4
    shape0 shape1 key0 key1 key2
  )
  (:goal (and (at key0 pos0-1) (at key2 pos2-2)))
  (:constraints
    (always (not (at-robot pos2-4)))
  )
)

(define (problem grid-5-5-2-3-3)
  (:domain grid)
  (:objects
    pos0-0 pos0-1 pos0-2 pos0-3 pos0-4 pos1-0 pos1-1 pos1-2 pos1-3 pos1-4 pos2-0 pos2-1 pos2-2 pos2-3 pos2-4 pos3-0 pos3-1 pos3-2 pos3-3 pos3-4 pos4-0 pos4-1 pos4-2 pos4-3 pos4-4
    shape0 shape1 key0 key1 key2
  )
  (:goal (and (at key0 pos0-1) (at key2 pos2-2)))
  (:constraints
    (always (not (at-robot pos2-4)))
  )
)

```

Next, we need to apply the planning rules to generate a plan. We can use a planning algorithm such as the Fast Downward algorithm to generate a plan.

```
(defplan (grid-5-5-2-3-3)
  (move pos2-0 pos2-2)
  (pickup pos2-2 key2)
  (move pos2-2 pos4-2)
  (putdown pos4-2 key2)
  (unlock pos2-2 shape1)
  (move pos2-2 pos2-0)
  (pickup pos2-0 key2)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (move pos0-0 pos0-1)
  (pickup pos0-1 key2)
  (move pos0-1 pos2-0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos2-1)
  (unlock pos2-1 shape0)
  (move pos2-1 pos2-0)
  (unlock pos2-0 shape1)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-1 shape1)
  (unlock pos0-0 shape0)
  (unlock pos2-0 shape1)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (unlock pos2-0 shape1)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-1)
  (unlock pos0-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape1)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (move pos2-0 pos2-1)
  (unlock pos2-1 shape1)
  (unlock pos2-0 shape1)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos2-2)
  (unlock pos2-2 shape1)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape1)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-1)
  (unlock pos0-1 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos2-0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape1)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos2-2)
  (unlock pos2-2 shape1)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-1)
  (unlock pos0-1 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos2-0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (move pos2-0 pos2-1)
  (unlock pos2-1 shape1)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape1)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-1)
  (unlock pos0-1 shape0)
  (unlock pos2-0 shape0)
  (unlock pos2-0 shape0)
  (move pos2-0 pos0-0)
  (unlock pos0-0 shape0)
  (move pos2-0 pos0-1)
  (unlock pos0-1 shape