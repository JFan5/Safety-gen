Skipping import of cpp extensions due to incompatible torch version 2.8.0+cu128 for torchao version 0.14.1             Please see https://github.com/pytorch/ao/issues/2919 for more info
Unsloth 2025.8.6 patched 28 layers with 0 QKV layers, 0 O layers and 0 MLP layers.
The attention mask is not set and cannot be inferred from input because pad token is same as eos token. As a consequence, you may observe unexpected behavior. Please pass your input's `attention_mask` to obtain reliable results.
ðŸ¦¥ Unsloth: Will patch your computer to enable 2x faster free finetuning.
ðŸ¦¥ Unsloth Zoo will now patch everything to make training faster!
Testing model: /groups/fkong/jfan5/sft_models/llama/spanner/pddl3
Problems dir: spanner/all_problems3/testing
Domain file: spanner/domain3.pddl
Max problems: 0
Output: spanner_all_testing_pddl3.json
Auto-detected model family: llama
Planning results will be saved to: planning_results/llama/spanner/pddl3
Loaded 200 problems for testing
Loading model...
==((====))==  Unsloth 2025.8.6: Fast Llama patching. Transformers: 4.55.2.
   \\   /|    NVIDIA A10. Num GPUs = 1. Max memory: 22.069 GB. Platform: Linux.
O^O/ \_/ \    Torch: 2.8.0+cu128. CUDA: 8.6. CUDA Toolkit: 12.8. Triton: 3.4.0
\        /    Bfloat16 = TRUE. FA [Xformers = 0.0.32.post2. FA2 = False]
 "-____-"     Free license: http://github.com/unslothai/unsloth
Unsloth: Fast downloading is enabled - ignore downloading bars which are red colored!
unsloth/llama-3.2-3b-instruct-unsloth-bnb-4bit does not have a padding token! Will use pad_token = <|finetune_right_pad_id|>.

--- Test 1/200 ---
Problem: spanner-s2-n2-l3-s1144255128
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s1144255128.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/1)

--- Test 2/200 ---
Problem: spanner-s2-n2-l3-s1152899300
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (file := open("spanner-s2-n2-l3-s1152899300.pddl", "r"))
import re

domain = re.search(r"(:domain (.*))", file.read()).group(1)
problem = re.search(r"(:problem (.*))", file.read()).group(1)

objects = re.search(r"(:objects (.*))", problem)
constants = re.findall(r"(\w+):", file.read())

actions = []
predicates = []
constraints = []

for line in file.readlines():
    line = line.strip()
    if match := re.search(r"\w+\s+(*?(\().?)(.*?)(\).?)", line):
        action = match.group(3)
        args = match.groups()[1:]
        args = [arg.strip() for arg in args]
        if action.startswith("(:action"):
            actions.append((action, args))
        else:
            pred = (action, *args)
            if pred[0].startswith(":predicates"):
                predicates.append(pred)
            else:
                constraints.append(pred)

if constraints:
    valid_constraints = []
    for pred in constraints:
        valid = True
        for action in actions:
            if action[0] == pred[0]:
                for arg, value in zip(pred[1:], action[1]):
                    if arg == "(*?":
                        continue
                    if arg!= value:
                        valid = False
                        break
        if valid:
            valid_constraints.append(pred)
    constraints = valid_constraints
if constraints:
    print("NO-PLAN")
else:
    valid_actions = []
    for action in actions:
        valid = True
        for pred in constraints:
            if pred[0] == action[0]:
                for arg1, value1 in zip(pred[1:], action[1]):
                    if arg1 == "(*?":
                        continue
                    if arg1!= value1:
                        valid = False
                        break
                for arg2, value2 in zip(pred[-1:], action[-1:]):
                    if arg2 == "(*?":
                        continue
                    if arg2!= value2:
                        valid = False
                        break
        if valid:
            valid_actions.append(action)
    if valid_actions:
        objects = objects.groups()
        objects = [obj.strip() for obj in objects]
        obj1, obj2 = objects[0], objects[1]
        if obj1 == "bob":
            obj1 = "man"
        if obj2 == "spanner1":
            obj2 = "spanner"
        if obj2 == "spanner2":
            obj2 = "spanner"
        if obj1 == "nut1":
            obj1 = "nut"
        if obj2 == "nut2":
            obj2 = "nut"
        plan = []
        for action in valid_actions:
            obj1_name, obj2_name = obj1, obj2
            if action[0] == "(:action":
                if action[0].endswith("walk"):
                    if action[1][0] == obj1_name:
                        obj1_name = action[1][1]
                    if action[1][1] == obj2_name:
                        obj2_name = action[1][2]
                elif action[0] == "(:action pickup_spanner":
                    if action[1][0] == obj1_name:
                        obj1_name = action[1][1]
                    if action[1][1] == obj2_name:
                        obj2_name = action[1][2]
                elif action[0] == "(:action tighten_nut":
                    if action[1][0] == obj1_name:
                        obj1_name = action[1][1]
                    if action[1][1] == obj2_name:
                        obj2_name = action[1][2]
            plan.append(f"{action[0]} {obj1_name} {obj2_name}")
        print("\n".join(plan))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s1152899300.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/2)

--- Test 3/200 ---
Problem: spanner-s2-n2-l3-s1275709574
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: â†“    
<link location1 location2>
(at bob location1)
(pickup_spanner location2 spanner1 bob)
(at spanner1 location2)
(tighten_nut location2 spanner1 nut1)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s1275709574.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/3)

--- Test 4/200 ---
Problem: spanner-s2-n2-l3-s1479492158
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s1479492158.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/4)

--- Test 5/200 ---
Problem: spanner-s2-n2-l3-s15460719
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [(pickup_spanner 
      (link location1 location2)
      (at bob location1)
      (at spanner1 location2)
      (at nut2 gate))
 
 (tighten_nut 
   (link location1 location2)
   (at bob location1)
   (at nut2 gate)
   (at spanner1 location2)
   (at bob location1)
   (loose nut1)
   (useable spanner1)
   (loose nut2))]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s15460719.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/5)

--- Test 6/200 ---
Problem: spanner-s2-n2-l3-s1660287226
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s1660287226.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/6)

--- Test 7/200 ---
Problem: spanner-s2-n2-l3-s1860398898
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s1860398898.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/7)

--- Test 8/200 ---
Problem: spanner-s2-n2-l3-s1926165840
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s1926165840.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/8)

--- Test 9/200 ---
Problem: spanner-s2-n2-l3-s2048054551
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s2048054551.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/9)

--- Test 10/200 ---
Problem: spanner-s2-n2-l3-s238689231
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ["(pickup_spanner location1 spanner1 bob)"
 "(walk location1 gate bob)"
 "(pickup_spanner gate spanner2 bob)"
 "(walk gate shed bob)"
 "(pickup_nut gate nut1)"
 "(tighten_nut gate spanner1 nut1)"
 "(tighten_nut gate spanner2 nut2)"]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s238689231.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/10)

--- Test 11/200 ---
Problem: spanner-s2-n2-l3-s307033235
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s307033235.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/11)

--- Test 12/200 ---
Problem: spanner-s2-n2-l3-s329459574
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s329459574.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/12)

--- Test 13/200 ---
Problem: spanner-s2-n2-l3-s462991901
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s462991901.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/13)

--- Test 14/200 ---
Problem: spanner-s2-n2-l3-s688053435
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s688053435.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/14)

--- Test 15/200 ---
Problem: spanner-s2-n2-l3-s692016533
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s692016533.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/15)

--- Test 16/200 ---
Problem: spanner-s2-n2-l3-s70471534
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s2-n2-l3-s70471534.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/16)

--- Test 17/200 ---
Problem: spanner-s3-n2-l4-s1060343414
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 location3 location4 shed bob spanner1 spanner2 spanner3 nut1 nut2 gate)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at spanner1 location1) (at spanner2 location3) (at spanner3 location3) (at nut1 gate) (at nut2 gate)))

#:action pickup_spanner 
#:parameters (location1 shed spanner1 spanner2 spanner3 nut1 nut2 gate bob location2 location3)
#:precondition (and (at spanner1 location1) (at bob shed) (link location4 gate) (link location1 location2) (link location2 location3) (at nut1 gate) (at nut2 gate))
#:effect (and (not (at spanner1 location1)) (at spanner1 location2) (at spanner2 location3) (at spanner3 location3) (not (at nut1 gate)) (not (at nut2 gate)))

#:action tighten_nut 
#:parameters (location1 location2 location3 gate shed spanner1 spanner2 spanner3 nut1 nut2 bob)
#:precondition (and (at spanner1 location2) (at bob shed) (link shed location1) (link location4 gate) (link location1 location2) (link location2 location3) (at spanner2 location3) (at spanner3 location3) (at nut1 gate) (at nut2 gate))
#:effect (and (not (at spanner1 location2)) (not (at spanner2 location3)) (not (at spanner3 location3)) (at spanner1 location1) (at spanner2 location3) (at spanner3 location3) (not (at nut1 gate)) (not (at nut2 gate)) (at nut1 gate) (at nut2 gate))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1060343414.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/17)

--- Test 18/200 ---
Problem: spanner-s3-n2-l4-s1145025463
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 location4 shed gate bob nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) 
                       (link shed location1)
                       (link location4 gate)
                       (link location1 location3)
                       (link location3 location4)
                       (at nut1 gate)
                       (at nut2 gate)
                       (at spanner1 location2)
                       (at spanner2 location2)
                       (at spanner3 location2)
                       (carrying bob location1)
                       (useable spanner1)
                       (loose nut1)
                       (loose nut2)
                       (carrying spanner2 location2)
                       (useable spanner2)
                       (carrying spanner3 location2)
                       (tightened nut1)
                       (tightened nut2))
#:effect (and (not (at bob shed))
              (not (at nut1 gate))
              (not (at nut2 gate))
              (not (at spanner1 location2))
              (not (at spanner2 location2))
              (not (at spanner3 location2))
              (at bob location3)
              (at spanner1 location3)
              (at spanner2 location4)
              (at spanner3 location4)
              (tightened nut1)
              (tightened nut2))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1145025463.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/18)

--- Test 19/200 ---
Problem: spanner-s3-n2-l4-s1156698980
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 location4 shed gate bob nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at nut1 gate) (at spanner1 location2) (at spanner2 location1) (at spanner3 location4) (at nut2 gate)))

#:action pickup_spanner 
#:parameters (location1 shed gate bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob location1) (at spanner1 location2) (at spanner2 location1) (at spanner3 location4) (at nut1 gate) (at nut2 gate))
#:effect (and (not (at spanner1 location2)) (at spanner1 gate) (not (at spanner2 location1)) (at spanner2 gate) (not (at spanner3 location4)) (at spanner3 gate) (not (loose nut1)) (at nut1 shed) (not (loose nut2)) (at nut2 shed)) 

#:action tighten_nut 
#:parameters (gate shed location1 spanner1 spanner2 spanner3 nut1 nut2 bob)
#:precondition (and (at bob gate) (at spanner1 gate) (at spanner2 gate) (at spanner3 gate) (at nut1 shed) (at nut2 shed) (at spanner1 gate) (at spanner2 gate) (at spanner3 gate) (at nut1 gate) (at nut2 gate))
#:effect (and (not (at spanner1 gate)) (not (at spanner2 gate)) (not (at spanner3 gate)) (not (at nut1 gate)) (at spanner1 shed) (at spanner2 shed) (at spanner3 shed) (at nut1 gate) (not (loose nut1)) (at nut1 gate) (at nut2 gate) (not (loose nut2)) (at nut2 gate))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1156698980.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/19)

--- Test 20/200 ---
Problem: spanner-s3-n2-l4-s1246477837
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 location2 bob nut2 gate spanner1 spanner2 spanner3 nut1 man)
#:precondition (and (at bob gate) (link gate location1) (link location1 location2) (link location2 location3) (at spanner1 location2) (at spanner2 location4) (at spanner3 location3) (at nut1 gate) (at nut2 gate) (useable spanner1) (useable spanner2) (useable spanner3) (loose nut1) (loose nut2))
#:effect (and (not (at spanner1 location2)) (not (at spanner2 location4)) (not (at spanner3 location3)) (not (loose nut1)) (not (loose nut2)) (at bob location1) (at spanner1 location3) (at spanner2 gate) (at spanner3 location3) (tightened nut1) (tightened nut2)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1246477837.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/20)

--- Test 21/200 ---
Problem: spanner-s3-n2-l4-s1379135101
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) (at?s?l))
#:effect (and (not (at?s?l)) (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) (at?n?l) (carrying?m?s) (useable?s) (loose?n))
#:effect (and (not (loose?n)) (not (useable?s)) (tightened?n))))

(at bob shed)
(at spanner1 location4)
(useable spanner1)
(at spanner2 location4)
(useable spanner2)
(at spanner3 location4)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)

(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1379135101.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/21)

--- Test 22/200 ---
Problem: spanner-s3-n2-l4-s1403678212
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 bob gate) 
#:precondition (and (at bob gate) (link gate location1) (link location3 gate)) 
#:effect (and (not (at bob gate)) (at bob location3)))

#:action pickup_spanner 
#:parameters (location1 spanner1 bob gate) 
#:precondition (and (at bob gate) (at spanner1 location1) (link gate location1)) 
#:effect (and (not (at spanner1 location1)) (carrying bob spanner1)))

#:action tighten_nut 
#:parameters (location1 spanner1 gate nut1 gate) 
#:precondition (and (at bob gate) (at spanner1 location1) (at nut1 gate) (link gate location1) 
                     (useable spanner1) (loose nut1)) 
#:effect (and (not (loose nut1)) (not (useable spanner1)) (tightened nut1))))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1403678212.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/22)

--- Test 23/200 ---
Problem: spanner-s3-n2-l4-s152552479
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [(pickup_spanner 
  location1 
  spanner1 
  bob)
 (pickup_spanner 
  location3 
  spanner2 
  bob)
 (tighten_nut 
  location1 
  spanner1 
  bob 
  nut1)
 (tighten_nut 
  location3 
  spanner2 
  bob 
  nut2)]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s152552479.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/23)

--- Test 24/200 ---
Problem: spanner-s3-n2-l4-s16178211
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [(pickup_spanner 
        (link location1 location2)
        (at bob location1)
        (at spanner1 location2)
        (at nut2 gate))
 
 (tighten_nut 
        (link location1 location2)
        (at bob location1)
        (at nut2 gate)
        (at spanner1 location2)
        (at nut1 gate)
        (useable spanner1)
        (loose nut1)
        (tightened nut1))
 
 (walk 
        (link shed location1)
        (at bob shed)
        (at spanner1 location2)
        (at nut1 gate)
        (at nut2 gate)
        (at bob location1))
 
 (pickup_spanner 
        (link location1 location2)
        (at bob location1)
        (at spanner1 location2)
        (at nut2 gate)
        (at nut1 gate)
        (at spanner1 location2)
        (useable spanner1)
        (tightened nut1)
        (at spanner1 location4))
 
 (tighten_nut 
        (link location1 location2)
        (at bob location1)
        (at spanner1 location4)
        (at nut2 gate)
        (at nut1 gate)
        (at spanner1 location4)
        (at nut1 gate)
        (useable spanner1)
        (tightened nut1))
 
 (walk 
        (link gate location1)
        (at nut1 gate)
        (at nut2 gate)
        (at bob location1))
 
 (pickup_spanner 
        (link gate location1)
        (at bob location1)
        (at spanner1 location4)
        (at nut2 gate)
        (at nut1 gate)
        (at spanner1 location4)
        (useable spanner1)
        (tightened nut1)
        (at spanner1 location2))
 
 (tighten_nut 
        (link gate location1)
        (at bob location1)
        (at spanner1 location4)
        (at nut2 gate)
        (at nut1 gate)
        (at spanner1 location4)
        (at nut2 gate)
        (useable spanner1)
        (tightened nut2))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s16178211.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/24)

--- Test 25/200 ---
Problem: spanner-s3-n2-l4-s1647581660
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (shed location1 bob nut1 spanner1 spanner2 spanner3 nut2 gate location2 location3 location4)
#:precondition (and (at bob shed) (link shed location1) (loose nut1) (at spanner1 location3) (useable spanner1) (at spanner2 location1) (useable spanner2) (at spanner3 location3) (loose nut2) (at nut2 gate) (link location4 gate) (link location1 location2) (link location2 location3) (link location3 location4))
#:effect (and (not (at bob shed)) (at bob location1) (tightened nut1) (not (at spanner1 location3)) (at spanner1 location1) (not (at spanner2 location1)) (at spanner2 location3) (not (at spanner3 location3)) (at spanner3 location4) (tightened nut2) (not (at nut2 gate)) (at nut2 location4) (link gate location4) (link location1 location2) (link location2 location3) (link location3 location4))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1647581660.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/25)

--- Test 26/200 ---
Problem: spanner-s3-n2-l4-s1675441380
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 location4 bob shed gate nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate) 
                     (link location1 location3) (link location3 location4) 
                     (at nut1 gate) (at nut2 gate) 
                     (carrying spanner1 location2) (carrying spanner2 location4) 
                     (at spanner1 location3) (at spanner2 location4) 
                     (loose nut1) (loose nut2) 
                     (at least-one (at nut1 gate)) (at least-one (at nut2 gate)))
#:effect (and (not (at bob shed)) (not (at nut1 gate)) (not (at nut2 gate))
              (at spanner1 location3) (at spanner2 location4) 
              (tightened nut1) (tightened nut2))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1675441380.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/26)

--- Test 27/200 ---
Problem: spanner-s3-n2-l4-s17629687
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 location3 location4 shed bob gate nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at spanner1 location3) (at spanner2 gate) (at spanner3 location4) (at nut1 gate) (at nut2 gate)))

#:action pickup_spanner 
#:parameters (location1 shed location3 gate location4 bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob location1) (at spanner1 location3) (at spanner2 gate) (at spanner3 location4) (at nut1 gate) (at nut2 gate))
#:effect (and (not (at spanner1 location3)) (at spanner1 shed) (not (at nut1 gate)) (at nut1 gate)) (and (not (at spanner2 gate)) (at spanner2 gate) (not (at nut2 gate)) (at nut2 gate)))

#:action tighten_nut 
#:parameters (location1 gate location3 shed bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob location1) (at spanner1 shed) (at spanner2 gate) (at spanner3 location4) (at nut1 gate) (at nut2 gate))
#:effect (and (not (at nut1 gate)) (at nut1 shed) (not (at spanner1 shed)) (at spanner1 gate)) (and (not (at nut2 gate))) (at nut2 gate) (at nut2 shed))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s17629687.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/27)

--- Test 28/200 ---
Problem: spanner-s3-n2-l4-s1791154985
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 man) 
#:precondition (and (at man location1) (link location1 location2)) 
#:effect (and (not (at man location1)) (at man location2)))

#:action pickup_spanner 
#:parameters (location1 spanner1 man) 
#:precondition (and (at man location1) (at spanner1 location1)) 
#:effect (and (not (at spanner1 location1)) (carrying man spanner1)))

#:action tighten_nut 
#:parameters (location1 spanner1 man nut1) 
#:precondition (and (at man location1) (at nut1 location1) (at spanner1 location2) (carrying man spanner1) (useable spanner1) (loose nut1)) 
#:effect (and (not (loose nut1)) (not (useable spanner1)) (tightened nut1))))

#:action walk 
#:parameters (location1 location2 man) 
#:precondition (and (at man location2) (link location2 location1)) 
#:effect (and (not (at man location2)) (at man location1)))

#:action pickup_spanner 
#:parameters (location1 spanner1 man) 
#:precondition (and (at man location1) (at spanner1 location1)) 
#:effect (and (not (at spanner1 location1)) (carrying man spanner1)))

#:action tighten_nut 
#:parameters (location1 spanner1 man nut1) 
#:precondition (and (at man location1) (at nut1 location1) (at spanner1 location2) (carrying man spanner1) (useable spanner1) (loose nut1)) 
#:effect (and (not (loose nut1)) (not (useable spanner1)) (tightened nut1))))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1791154985.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/28)

--- Test 29/200 ---
Problem: spanner-s3-n2-l4-s1800780856
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 location4 shed gate bob nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at nut1 gate) (at spanner1 location4) (at spanner2 gate) (at spanner3 gate)))

#:action pickup_spanner 
#:parameters (location1 gate bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob location1) (at spanner1 gate) (at spanner2 gate) (at spanner3 gate) 
                     (at nut1 gate) (at nut2 gate))
#:effect (and (not (at spanner1 gate)) (at spanner1 location1) (not (at nut1 gate)) (at nut1 gate) 
             (not (at spanner2 gate)) (at spanner2 gate) (not (at nut2 gate)) (at nut2 gate))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1800780856.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/29)

--- Test 30/200 ---
Problem: spanner-s3-n2-l4-s1858288638
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Define the domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 2 4 --seed 1858288638 --problem-name spanner-s3-n2-l4-s1858288638
(define (problem spanner-s3-n2-l4-s1858288638)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location3)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location3)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Define the constraints
constraints = [
    (sometime-before, (tightened, nut1), (tightened, nut2)),
    (at-most-once, (at, bob, shed))
]

# Create a Planner instance
planner = Planner(domain, problem, constraints)

# Generate a plan
plan = planner.plan()

# Print the plan
for step in plan:
    print(f"{step})")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1858288638.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/30)

--- Test 31/200 ---
Problem: spanner-s3-n2-l4-s1865177226
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 bob gate) 
#:precondition (and (at bob gate) (link gate location1) (link location3 gate)))
#:effect (and (not (at bob gate)) (at bob location3)))

#:action pickup_spanner 
#:parameters (location1 spanner1 bob gate) 
#:precondition (and (at bob gate) (at spanner1 location1) (link gate location1)))
#:effect (and (not (at spanner1 location1)) (carrying bob spanner1)))

#:action tighten_nut 
#:parameters (location1 spanner1 gate nut1 gate) 
#:precondition (and (at bob gate) (at spanner1 location1) (at nut1 gate) 
		      	   (useable spanner1) (loose nut1))
        :effect (and (not (loose nut1))(not (useable spanner1)) (tightened nut1))))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1865177226.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/31)

--- Test 32/200 ---
Problem: spanner-s3-n2-l4-s197721644
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s3-n2-l4-s197721644"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
spanner_generator.produce_domain(domain, problem_name)

problem = "<PROBLEM>"
spanner_generator.produce_problem(problem, domain, problem_name)

rules = """
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM (:constants if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

"""

constraints = """
and
  (sometime-before (tightened nut1) (tightened nut2))
and
  (forall (?m - man) (at-most-once (at?m shed)))
"""

domain += problem_domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
"""
problem += produce_problem = """
<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 2 4 --seed 197721644 --problem-name spanner-s3-n2-l4-s197721644
(define (problem spanner-s3-n2-l4-s197721644)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location2)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location3)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
)
)
(:constraints
  """ + constraints + """
)
"""

generator = spanner_generator.spanner_generator(problem_name)

domain_lines = generator.generate_domain()
problem_lines = generator.generate_problem()
rules_lines = generator.generate_rules()

print("DOMAIN:")
for line in domain_lines:
    print(line)

print("\nPROBLEM:")
for line in problem_lines:
    print(line)

print("\nRULES:")
for line in rules_lines:
    print(line)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s197721644.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/32)

--- Test 33/200 ---
Problem: spanner-s3-n2-l4-s1989901588
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 location3 location4 shed bob spanner1 spanner2 spanner3 nut1 nut2 gate)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at spanner1 location3) (at spanner2 gate) (at spanner3 location2) (at nut1 gate) (at nut2 gate) (link location1 location2) (link location4 gate)))

#:action pickup_spanner 
#:parameters (location1 shed spanner1 spanner3 nut1 gate spanner2 location2 nut2 location4 bob)
#:precondition (and (at bob location1) (at spanner1 location3) (at spanner2 location2) (at nut1 gate) (at nut2 location4) (link location1 location2) (link location4 gate))
#:effect (and (not (at spanner1 location3)) (at spanner1 shed) (not (at spanner2 location2)) (at spanner2 gate) (not (at nut1 gate)) (at nut1 location4) (not (at nut2 location4)) (link location2 location1) (link location4 shed)) 

#:action tighten_nut 
#:parameters (location1 shed spanner1 spanner2 gate spanner3 location2 nut1 location4 nut2 bob)
#:precondition (and (at bob location1) (at spanner1 shed) (at spanner2 gate) (at spanner3 location2) (at nut1 location4) (at nut2 location4) (link location1 location2) (link location4 shed) (link location2 location1) (link location4 gate))
#:effect (and (not (at spanner1 shed)) (at spanner1 location1) (not (at spanner2 gate)) (at spanner2 location2) (not (at spanner3 location2)) (at spanner3 gate) (not (at nut1 location4)) (at nut1 location4) (not (at nut2 location4)) (not (at nut2 location4)) (tightened nut1) (tightened nut2))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s1989901588.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/33)

--- Test 34/200 ---
Problem: spanner-s3-n2-l4-s2008173602
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: Ð’Ð»Ð°Ð´Ð¸import python3
import spanner_generator
problem_name = "spanner-s3-n2-l4-s2008173602"
spanner_generator.spanner_generator(problem_name, generate_problem=True, create_symbols=False, generate_plan=True, seed=2008173602)

domain = f"""
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
(define (problem spanner-s3-n2-l4-s2008173602)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location2)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location3)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

current_state = {
    "shed": "occupied",
    "bob": "at_shed",
    "spanner1": "at_location2",
    "spanner2": "at_location1",
    "spanner3": "at_location3",
    "nut1": "at_gate",
    "nut2": "at_gate",
    "location1": "linkable",
    "location2": "linkable",
    "location3": "linkable",
    "location4": "linkable",
    "gate": "linkable"
}

available_objects = ["bob", "spanner1", "spanner2", "spanner3", "nut1", "nut2",
                      "location1", "location2", "location3", "location4", "gate"]
action_available = {
    "walk": [],
    "pickup_spanner": [],
    "tighten_nut": []
}

goal_reached = True
constraints_satisfied = True

if constraints_satisfied:
    for constraint in spanner_generator.problems[problem_name].constraints:
        if not satisfy_constraint(current_state, constraint):
            constraints_satisfied = False
            break

if constraints_satisfied:
    for obj in available_objects:
        if obj!= "gate":
            if not at_object(current_state, obj):
                action_available["walk"].append((obj, "at_gate"))
                current_state[obj] = "at_gate"

if goal_reached and constraints_satisfied:
    while action_available["walk"]:
        obj1, action_name = action_available["walk"].pop(0)
        for obj2 in available_objects:
            if obj2!= obj1 and obj2!= "gate":
                if action_name == "walk":
                    if link_at(current_state, obj1, obj2):
                        action_available["walk"].append((obj1, obj2))
                        action_available["pickup_spanner"].append((obj1, obj2))
                    elif link_available(current_state, obj1, obj2):
                        action_available["walk"].append((obj1, obj2))
                        action_available["pickup_spanner"].append((obj1, obj2))
                if action_name == "pickup_spanner":
                    if at_object(current_state, obj2):
                        action_available["pickup_spanner"].remove((obj1, obj2))
                        action_available["tighten_nut"].append((obj1, obj2))
                    elif link_at(current_state, obj1, obj2):
                        action_available["pickup_spanner"].append((obj1, obj2))
                        action_available["tighten_nut"].append((obj1, obj2))
                if action_name == "tighten_nut":
                    if at_object(current_state, obj2):
                        action_available["tighten_nut"].remove((obj1, obj2))
                        goal_reached = True
                    elif link_at(current_state, obj1, obj2):
                        action_available["tighten_nut"].append((obj1, obj2))
                        action_available["pickup_spanner"].append((obj1, obj2))

if goal_reached and constraints_satisfied:
    if action_available["tighten_nut"]:
        obj1, obj2 = action_available["tighten_nut"].pop(0)
        if at_object(current_state, obj1):
            action_available["tighten_nut"].remove((obj1, obj2))
            tightened_nuts.remove(obj2)
            current_state[obj2] = "tightened"
        elif at_object(current_state, obj2):
            action_available["tighten_nut"].remove((obj1, obj2))
            tightened_nuts.remove(obj1)
            current_state[obj1] = "tightened"
        else:
            action_available["tighten_nut"].append((obj1, obj2))

if goal_reached and constraints_satisfied:
    if available_objects:
        obj = available_objects[0]
        if at_object(current_state, obj):
            available_objects.remove(obj)
            action_available["walk"].append((obj, "at_gate"))
        else:
            action_available["pickup_spanner"].append((obj, "at_gate"))

if available_objects and action_available["pickup_spanner"]:
    obj1, obj2 = action
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s2008173602.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/34)

--- Test 35/200 ---
Problem: spanner-s3-n2-l4-s2032113295
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 location3 location4 shed bob gate nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at nut1 gate) (at spanner1 location3) (at spanner2 location4) (at spanner3 location3)))

#:action pickup_spanner 
#:parameters (location1 shed location3 gate location4 bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob location1) (at spanner1 location3) (at spanner2 location4) (at spanner3 location3) 
                     (at nut1 gate) (at nut2 gate))
#:effect (and (not (at spanner1 location3)) (at spanner1 gate) (not (at nut1 gate)) (at spanner2 gate) 
             (not (at nut2 gate)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s2032113295.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/35)

--- Test 36/200 ---
Problem: spanner-s3-n2-l4-s2059699912
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 location3 location4 shed bob gate nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at spanner1 location4) (at spanner2 location3) (at spanner3 location1) (at nut1 gate) (at nut2 gate)))

#:action pickup_spanner 
#:parameters (location1 shed spanner1 location4 spanner2 location3 spanner3 gate bob nut1 nut2)
#:precondition (and (at spanner1 location4) (at spanner2 location3) (at spanner3 location1) (at bob location1) (at nut1 gate) (at nut2 gate))
#:effect (and (not (at spanner1 location4)) (at spanner1 shed) (not (at spanner2 location3)) (at spanner2 gate) (not (at spanner3 location1)) (at spanner3 shed) (not (at nut1 gate)) (not (at nut2 gate)))

#:action tighten_nut 
#:parameters (location1 shed spanner1 gate spanner2 location3 spanner3 gate bob nut1 nut2)
#:precondition (and (at spanner1 shed) (at spanner2 gate) (at spanner3 shed) (at bob location1) (at nut1 gate) (at nut2 gate) (link shed location1) (link location4 gate) (link location1 location2) (link location2 location3) (link location3 location4))
#:effect (and (not (at spanner1 shed)) (not (at spanner2 gate)) (not (at spanner3 shed)) (at spanner1 location1) (at spanner2 gate) (at spanner3 location4) (not (at nut1 gate)) (not (at nut2 gate)) (tightened nut1) (tightened nut2))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s2059699912.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/36)

--- Test 37/200 ---
Problem: spanner-s3-n2-l4-s2119789556
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location4 shed gate bob nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) 
                       (link shed location1)
                       (link location4 gate)
                       (link location1 location2)
                       (link location2 location3)
                       (link location3 location4)
                       (at spanner1 location2)
                       (at spanner2 location3)
                       (at spanner3 location2)
                       (at nut1 gate)
                       (at nut2 gate))
#:effect (and (not (at spanner1 location2))
              (not (at spanner2 location3))
              (not (at spanner3 location2))
              (not (at nut1 gate))
              (not (at nut2 gate))
              (at bob location1)
              (tightened nut1)
              (tightened nut2))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s2119789556.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/37)

--- Test 38/200 ---
Problem: spanner-s3-n2-l4-s2128302478
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(at spanner1 location1)
(carrying bob spanner1)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location3)
(carrying spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)

(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s2128302478.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/38)

--- Test 39/200 ---
Problem: spanner-s3-n2-l4-s282191674
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location4)
(useable spanner1)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location3)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)

(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s282191674.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/39)

--- Test 40/200 ---
Problem: spanner-s3-n2-l4-s297388711
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 location3 location4 shed bob gate nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at spanner1 location1) (at spanner2 location4) (at spanner3 location4) (at nut1 gate) (at nut2 gate) (link location1 location2) (link location4 gate))
#:action pickup_spanner 
#:parameters (location1 shed gate location4 bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob location1) (at spanner1 location1) (at spanner2 location4) (at spanner3 location4) (at nut1 gate) (at nut2 gate) (link location1 location2) (link location4 gate))
#:effect (and (not (at spanner1 location1)) (at spanner1 gate) (not (at spanner2 location4)) (at spanner2 gate) (not (at spanner3 location4)) (at spanner3 gate) (not (loose nut1)) (at nut1 gate) (not (loose nut2)) (at nut2 gate))
#:action tighten_nut 
#:parameters (location1 gate shed location4 bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob gate) (at spanner1 gate) (at spanner2 gate) (at spanner3 gate) (at nut1 gate) (at nut2 gate) (link gate location1) (link location4 shed) (at spanner1 location1) (at spanner2 location4) (at spanner3 location4) (loose nut1) (useable spanner1) (loose nut2) (useable spanner2))
#:effect (and (not (loose nut1)) (at nut1 shed) (not (useable spanner1)) (not (loose nut2)) (at nut2 shed) (not (useable spanner2)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s297388711.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/40)

--- Test 41/200 ---
Problem: spanner-s3-n2-l4-s308820452
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location3)
(useable spanner1)
(at spanner2 location4)
(useable spanner2)
(at spanner3 location2)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s308820452.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/41)

--- Test 42/200 ---
Problem: spanner-s3-n2-l4-s329162299
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [from/spanner-s3-n2-l4-s329162299] 
(at bob shed)
(at spanner1 location4)
(at spanner2 location4)
(at spanner3 location3)
(at nut1 gate)
(at nut2 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(pickup_spanner bob location4 spanner1)
(tighten_nut bob location1 spanner1 nut1)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s329162299.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/42)

--- Test 43/200 ---
Problem: spanner-s3-n2-l4-s421388079
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location4)
(useable spanner2)
(at spanner3 location2)
(useable spanner3)
(at nut1 gate)
(tightened nut1)
(at nut2 gate)
(tightened nut2)

(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s421388079.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/43)

--- Test 44/200 ---
Problem: spanner-s3-n2-l4-s456537937
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
from (sys) import stdout, stderr

gen_nut_spanner_location = (open("spanner-s3-n2-l4-s456537937.out", "w"))
constraints_file = (open("spanner-s3-n2-l4-s456537937.constraints", "r"))

constraints = [(line.strip(), line.strip()) for line in constraints_file.readlines() if line.strip()]
gen_nut_spanner_location.write("-- Planning Rules\n")
gen_nut_spanner_location.write("1) Only use available symbols:\n")
gen_nut_spanner_location.write("   - objects declared under PROBLEM :objects, and\n")
gen_nut_spanner_location.write("   - constants declared under DOMAIN/PROBLEM :constants (if any).\n")
gen_nut_spanner_location.write("   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.\n")
gen_nut_spanner_location.write("2) Constraints:\n")
gen_nut_spanner_location.write("   If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.\n")
gen_nut_spanner_location.write("   If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.\n")
gen_nut_spanner_location.write("3) Plan form:\n")
gen_nut_spanner_location.write("   Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.\n")
gen_nut_spanner_location.write("4) Internal validation before emitting (do not include reasoning in the output):\n")
gen_nut_spanner_location.write("   At each step, all action preconditions hold in the current state.\n")
gen_nut_spanner_location.write("   Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.\n")
gen_nut_spanner_location.write("   If constraints exist in PROBLEM, ensure the plan satisfies all of them.\n")
gen_nut_spanner_location.write("-- Output Requirements\n")
gen_nut_spanner_location.write("- Return **ONLY** the plan steps, one per line.\n")
gen_nut_spanner_location.write("- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`\n")
gen_nut_spanner_location.write("- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).\n")
gen_nut_spanner_location.write("- No numbering, timestamps, costs, comments, headers, code fences, or extra text.\n")
gen_nut_spanner_location.write("- No blank lines at the start or end; no trailing spaces; use a single space between tokens.\n")
gen_nut_spanner_location.write("- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).\n")
gen_nut_spanner_location.write("- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`.\n")
gen_nut_spanner_location.write("-- Examples\n")
gen_nut_spanner_location.write("Bad:\n")
gen_nut_spanner_location.write("  (move a b)  (two actions on one line)\n")
gen_nut_spanner_location.write("  (move a) extra\n")
gen_nut_spanner_location.write("Good:\n")
gen_nut_spanner_location.write(" (move a b)\n")
gen_nut_spanner_location.write(" (pick a c)\n")
gen_nut_spanner_location.write(" (drop a d)\n")
constraints_file.close()

valid_constraints = (True for constraint in constraints if constraint[0] == "No-Plan" or (constraints.count((True, False)) == 0))
gen_nut_spanner_location.write("-- Constraints:\n")
gen_nut_spanner_location.write("  " + ("(" if valid_constraints else "") + "and ".join(constraint[0] for constraint in constraints) + (")" if valid_constraints else ""))
gen_nut_spanner_location.write("\n")

objects = (line.strip() for line in open("spanner-s3-n2-l4-s456537937.objects", "r"))
gen_nut_spanner_location.write("-- Objects:\n")
gen_nut_spanner_location.write("  - " + (", ".join(objects)) + "\n")

constants = (line.strip() for line in open("spanner-s3-n2-l4-s456537937.constants", "r"))
gen_nut_spanner_location.write("-- Constants:\n")
gen_nut_spanner_location.write("  - " + (", ".join(constants)) + "\n")

domain = (line.strip() for line in open("spanner-s3-n2-l4-s456537937.domain", "r"))
gen_nut_spanner_location.write("-- DOMAIN:\n")
gen_nut_spanner_location.write("  " + (", ".join(domain)) + "\n")

problem = (line.strip() for line in open("spanner-s3-n2-l4-s456537937.problem", "r"))
gen_nut_spanner_location.write("-- PROBLEM:\n")
gen_nut_spanner_location.write("  " + (", ".join(problem)) + "\n")

gen_nut_spanner_location.write("-- Planning Time Start ---\n")
stdout.write("Starting generate spanner location plan...\n")

gen_nut_spanner_location.write("-- Start Plan Generation ---\n")
gen_nut_spanner_location.write("no-input-nut-3\n")
gen_nut_spanner_location.write("walk gate shed\n")
gen_nut_spanner_location.write("pickup-spanner1 gate\n")
gen_nut_spanner_location.write("walk gate location1\n")
gen_nut_spanner_location.write("pickup-spanner2 gate\n")
gen_nut_spanner_location.write("walk gate location1\n")
gen_nut_spanner_location.write("tighten-nut1 gate\n")
gen_nut_spanner_location.write("pickup-spanner3 gate\n")
gen_nut_spanner_location.write("walk gate location4\n")
gen_nut_spanner_location.write("tighten-nut2 gate\n")
gen_nut_spanner_location.write("-- End Plan Generation ----\n")
gen_nut_spanner_location.write("-- Planning Time End ---\n")
stdout.write("Finished generating spanner location plan.\n")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s456537937.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/44)

--- Test 45/200 ---
Problem: spanner-s3-n2-l4-s456958661
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location4)
(useable spanner2)
(at spanner3 location2)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)

(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s456958661.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/45)

--- Test 46/200 ---
Problem: spanner-s3-n2-l4-s457261204
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ðŸ˜‰

<step>
  (tightened nut1)
  (tightened nut2)
</step>
<step>
  (walk bob gate)
  (walk nut1 gate)
  (walk nut2 gate)
  (pickup_spanner1 gate shed)
  (pickup_spanner2 gate shed)
  (walk spanner1 gate)
  (pickup_spanner spanner1 gate)
  (tighten_nut nut1 gate)
</step>
<step>
  (tighten_nut spanner1 gate)
  (tighten_nut nut2 gate)
  (walk spanner1 gate)
  (pickup_spanner spanner1 gate)
  (walk spanner2 gate)
  (pickup_spanner spanner2 gate)
  (walk spanner3 gate)
  (pickup_spanner spanner3 gate)
  (tighten_nut spanner3 gate)
</step>
</step>
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s457261204.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/46)

--- Test 47/200 ---
Problem: spanner-s3-n2-l4-s47576934
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 location4 bob gate nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob gate) (link gate location1) (link location4 gate) 
                     (link location1 location2) (link location2 location3) (link location3 location4))
#:effect (and (not (at bob gate)) (at bob location1) (at nut1 gate) (at nut2 gate)
             (not (link gate location1)) (not (link location4 gate))
             (not (link location1 location2)) (not (link location2 location3))
             (not (link location3 location4)) (at spanner1 location4) (at spanner2 gate) 
             (at spanner3 location1) (at nut1 gate) (at nut2 gate) (tightened nut1) 
             (tightened nut2) (useable spanner1) (useable spanner2) (carrying bob location1) 
             (carrying spanner1 location4) (carrying spanner2 gate) (carrying spanner3 location1)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s47576934.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/47)

--- Test 48/200 ---
Problem: spanner-s3-n2-l4-s479444906
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(at spanner1 location1)
(carrying bob spanner1)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location1)
(loose nut2)
(at nut2 gate)
(at nut1 gate)
(link shed location1)
(link location1 location2)
(link location2 location3)
(link location3 gate)
(link gate location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s479444906.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/48)

--- Test 49/200 ---
Problem: spanner-s3-n2-l4-s543113565
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location1)
(useable spanner1)
(at spanner2 location1)
(useable spanner2)
(at spanner3 location1)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(nut1)
(nut2)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s543113565.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/49)

--- Test 50/200 ---
Problem: spanner-s3-n2-l4-s568157228
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

@available_in_location(location1, location2, location3, location4)
@available_in_man(bob, spanner1, spanner2, spanner3, nut1, nut2)
(defuniform
  (once (at?m location1) (pickup spanner1 bob))
  (once (at?m location2) (pickup spanner2 bob))
  (once (at?m location4) (pickup spanner3 bob))
  (once (at nut1 gate) (tighten nut1))
  (once (at nut2 gate) (tighten nut2))
)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s568157228.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/50)

--- Test 51/200 ---
Problem: spanner-s3-n2-l4-s579816044
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

@inbody 
(m - man)
(c - spanner)
(n - nut)
(l1 - location)
(l2 - location)
(l3 - location)
(l4 - location)
(s - shed)
(g - gate)

(s l1)
(l1 l2)
(l2 l3)
(l3 l4)
(l4 g)
(c l2)
(n g)
(at m l1)
(useable c)
(at n g)
(at m l4)
(at c l2)
(at n l1)
(at m l4)
(tightened n)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s579816044.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/51)

--- Test 52/200 ---
Problem: spanner-s3-n2-l4-s586689033
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                      (at?s?l))
#:effect (and (not (at?s?l))
               (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location1)
(useable spanner1)
(at spanner2 location4)
(useable spanner2)
(at spanner3 location4)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s586689033.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/52)

--- Test 53/200 ---
Problem: spanner-s3-n2-l4-s60057866
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location2)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s60057866.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/53)

--- Test 54/200 ---
Problem: spanner-s3-n2-l4-s657958087
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location3)
(useable spanner2)
(at spanner3 location1)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s657958087.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/54)

--- Test 55/200 ---
Problem: spanner-s3-n2-l4-s666035715
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location4 gate bob nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob gate) (link gate location1) (link location4 gate) 
                     (at spanner1 location2) (at spanner2 location3) (at spanner3 location4))
#:effect (and (not (at spanner1 location2)) (not (at spanner2 location3)) (not (at spanner3 location4))
             (at bob location1) (at nut1 gate) (at nut2 gate))) 

(leave gate)
(link gate location1)
(link location1 location2)
(walk gate location4)
(walk location4 gate)
(pick spanner1 gate)
(pick spanner2 gate)
(pick spanner3 gate)
(tighten nut1 gate)
(tighten nut2 gate)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s666035715.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/55)

--- Test 56/200 ---
Problem: spanner-s3-n2-l4-s679114617
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 location4 bob nut1 nut2)
#:precondition (and (at bob location1) 
                        (link location1 location3) 
                        (link location3 location4))
#:effect (and (not (at bob location1)) 
                 (at bob location4)
                 (at nut1 location4)
                 (tightened nut1)
                 (at nut2 location4)
                 (tightened nut2)))

#:action tighten_nut 
#:parameters (location1 location4 bob nut1 nut2)
#:precondition (and (at bob location1) 
		      	   (at nut1 location4)
			   (at nut2 location4)
			   (at bob location4)
			   (carrying bob location4)
			   (useable nut1)
			   (loose nut2))
#:effect (and (not (loose nut2))(not (useable nut1)) (tightened nut1))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s679114617.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/56)

--- Test 57/200 ---
Problem: spanner-s3-n2-l4-s755118894
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location1)
(useable spanner2)
(at spanner3 location1)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s755118894.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/57)

--- Test 58/200 ---
Problem: spanner-s3-n2-l4-s809578076
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Load domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 2 4 --seed 809578076 --problem-name spanner-s3-n2-l4-s809578076
(define (problem spanner-s3-n2-l4-s809578076)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location3)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location3)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

# Create a Planner object
planner = Planner(from_domain=domain, from_problem=Problem())
constraints = Constraints.from_problem(planner.problem)

# Plan
plan = planner.plan constraints

# Validate the plan
planner.validate_plan(plan)

# Produce the final output
output = []
for step in plan:
    action_name = step.action.name
    if action_name.startswith('pickup_'):
        obj1 = step.action.params[0].name
        obj2 = step.action.params[1].name
        output.append(f'<{action_name}> {obj1} {obj2}')
    elif action_name.startswith('tighten_'):
        obj1 = step.action.params[0].name
        obj2 = step.action.params[1].name
        output.append(f'<{action_name}> {obj1} {obj2}')
    else:
        raise ValueError(f"Unknown action: {action_name}")

# Print the output
print('\n'.join(output))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s809578076.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/58)

--- Test 59/200 ---
Problem: spanner-s3-n2-l4-s839801557
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [â€¦] 
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s839801557.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/59)

--- Test 60/200 ---
Problem: spanner-s3-n2-l4-s891780211
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s891780211.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/60)

--- Test 61/200 ---
Problem: spanner-s3-n2-l4-s924487418
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location3)
(useable spanner2)
(at spanner3 location4)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
 
(tighten_nut shed spanner1 nut1)
(tighten_nut gate nut1)
(tighten_nut shed spanner2 nut2)
(tighten_nut gate nut2)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s924487418.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/61)

--- Test 62/200 ---
Problem: spanner-s3-n2-l4-s932838090
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 location3 location4 shed bob gate nut1 nut2 spanner1 spanner2 spanner3)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate))
#:effect (and (not (at bob shed)) (at bob location1) (at spanner1 location4) (at spanner2 location3) (at spanner3 location3) (at nut1 gate) (at nut2 gate) (not (loose nut1)) (not (useable spanner1)) (not (useable spanner2)) (not (useable spanner3)) (tightened nut1)))

#:action pickup_spanner 
#:parameters (location1 shed location4 gate bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob location1) (at spanner1 location4) (at spanner2 location3) (at spanner3 location3) (at nut1 gate) (at nut2 gate) (not (at spanner1 location4)) (not (at spanner2 location3)) (not (at spanner3 location3)) (not (loose nut1)) (not (useable spanner1)) (not (useable spanner2)) (not (useable spanner3)) (at spanner1 location1) (at spanner2 location2) (at spanner3 location2))
#:effect (and (not (at spanner1 location4)) (at spanner1 location1) (not (at spanner2 location3)) (at spanner2 location2) (not (at spanner3 location3)) (at spanner3 location2) (not (loose nut1)) (not (useable spanner1)) (not (useable spanner2)) (not (useable spanner3)) (carrying bob spanner1))

#:action tighten_nut 
#:parameters (location1 gate location4 shed bob spanner1 spanner2 spanner3 nut1 nut2)
#:precondition (and (at bob location1) (at spanner1 location4) (at spanner2 location3) (at spanner3 location2) (at nut1 gate) (at nut2 gate) (at spanner1 location1) (at spanner2 location2) (at spanner3 location2) (at nut1 gate) (not (at spanner1 location4)) (not (at spanner2 location3)) (not (at spanner3 location2)) (not (loose nut1)) (not (useable spanner1)) (not (useable spanner2)) (not (useable spanner3)) (at spanner1 location1) (at spanner2 location2) (at spanner3 location2) (loose nut1) (useable spanner1) (useable spanner2) (useable spanner3))
#:effect (and (not (at spanner1 location4)) (at spanner1 location1) (not (at spanner2 location3)) (at spanner2 location2) (not (at spanner3 location2)) (at spanner3 location2) (not (loose nut1)) (not (useable spanner1)) (useable spanner1) (not (useable spanner2)) (useable spanner2) (not (useable spanner3)) (useable spanner3) (tightened nut1))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s932838090.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/62)

--- Test 63/200 ---
Problem: spanner-s3-n2-l4-s950994990
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

@available_in_location(nut1, gate)
(at nut1 gate)
(useable nut1)

@available_in_location(spanner1, location1)
(at spanner1 location1)
(useable spanner1)

@available_in_location(spanner2, location3)
(at spanner2 location3)
(useable spanner2)

@available_in_location(spanner3, location4)
(at spanner3 location4)
(useable spanner3)

@available_in_location(bob, shed)
(at bob shed)

(link shed location1)
(at bob shed)
(link location1 location2)

(at spanner1 location1)
(at spanner2 location3)
(at spanner3 location4)

(nut1 gate)
(at spanner1 location1)
(at spanner2 location3)
(at spanner3 location4)

(at nut1 gate)
(at spanner1 location1)
(at spanner2 location3)
(at spanner3 location4)

(nut2 gate)

(at spanner1 location1)
(at spanner2 location3)
(at spanner3 location4)
(at nut1 gate)
(at nut2 gate)

(at spanner1 location1)
(at spanner2 location3)
(at spanner3 location4)
(at nut1 gate)
(at nut2 gate)
(at spanner1 location1)
(at spanner2 location3)
(at spanner3 location4)
(at nut1 gate)
(at nut2 gate)

(not (tightened nut1))
(at spanner1 location1)
(at spanner2 location3)
(at spanner3 location4)
(at nut1 gate)
(at nut2 gate)

(at spanner1 location1)
(at spanner2 location3)
(at spanner3 location4)
(at nut1 gate)
(at nut2 gate)
(tightened nut1)
(tightened nut2)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s950994990.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/63)

--- Test 64/200 ---
Problem: spanner-s3-n2-l4-s955956679
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location1)
(useable spanner1)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location4)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(tightened nut1)
(tightened nut2)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s955956679.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/64)

--- Test 65/200 ---
Problem: spanner-s3-n2-l4-s975286692
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location3)
(useable spanner2)
(at spanner3 location3)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s975286692.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/65)

--- Test 66/200 ---
Problem: spanner-s3-n2-l4-s996466159
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (bob shed location1 location2 spanner1 nut1 nut2 gate)
#:precondition (and (at bob shed) 
                    (link shed location1)
                    (at nut1 gate)
                    (at nut2 gate)
                    (link location4 gate)
                    (link location1 location2)
                    (link location2 location3)
                    (link location3 location4))
#:effect (and (not (at bob shed)) 
             (at bob location2)
             (at spanner1 location2)
             (tightened nut1)
             (tightened nut2))) 

#:action pickup_spanner 
#:parameters (bob location2 spanner1 nut1 gate location4 spanner2 nut2 gate)
#:precondition (and (at bob location2) 
                     (at spanner1 location2)
                     (at nut1 gate)
                     (at nut2 gate)
                     (link location1 location2)
                     (link location2 location3)
                     (link location3 location4)
                     (at spanner2 location3)
                     (at spanner2 gate)
                     (loose nut2))
#:effect (and (not (at spanner1 location2))
             (at spanner1 location3)
             (at spanner2 gate)
             (at bob location4)
             (at nut2 gate)
             (at nut2 location4))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s996466159.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/66)

--- Test 67/200 ---
Problem: spanner-s3-n2-l4-s999827255
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location3 bob gate) 
#:precondition (and (at bob gate) (link gate location1) (link location3 gate)) 
#:effect (and (not (at bob gate)) (at bob location1) (at bob gate)))

#:action pickup_spanner 
#:parameters (location1 spanner1 bob gate) 
#:precondition (and (at bob location1) (at spanner1 location1) (link gate location1)) 
#:effect (and (not (at spanner1 location1)) (at spanner1 gate) (carrying bob spanner1)))

#:action tighten_nut 
#:parameters (location1 spanner1 gate bob nut1) 
#:precondition (and (at bob gate) (at spanner1 gate) (at nut1 gate) (at bob location1) 
		      	   (link gate location1) (link location1 gate) (link gate location3) 
			   (at nut1 location1) (useable spanner1) (loose nut1) 
			   (carrying bob spanner1)) 
#:effect (and (not (loose nut1)) (not (useable spanner1)) (at spanner1 gate) (tightened nut1)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n2-l4-s999827255.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/67)

--- Test 68/200 ---
Problem: spanner-s3-n3-l4-s1004299524
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [â€¦]  # generate spanner-s3-n3-l4-s1004299524 problem
location1 = "shed"
spanner1 = "spanner1"
nut1 = "nut1"
location2 = "location2"
spanner2 = "spanner2"
nut2 = "nut2"
location3 = "location3"
spanner3 = "spanner3"
nut3 = "nut3"
location4 = "location4"
gate = "gate"

(at bob shed)
(at spanner1 location4)
(useable spanner1)
(at spanner2 location3)
(useable spanner2)
(at spanner3 location3)
(useable spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(tightened nut1)
(tightened nut2)
(tightened nut3)

(sometime-before (tightened nut2) (tightened nut3))
(forall (?m - man) (at-most-once (at?m shed)))

# available actions
pickup_spanner, tighten_nut, walk, pickup_nut, tighten_spanner 

# validate before emitting
available_objects = {
    'bob','spanner1','spanner2','spanner3', 'nut1', 'nut2', 'nut3',
    'location1', 'location2', 'location3', 'location4', 'gate'
}

available_links = [
    (shed, location1),
    (location4, gate),
    (location1, location2),
    (location2, location3),
    (location3, location4)
]

available_objects_and_links = set(available_objects) | set(available_links)

def validate_action(action_name, obj1, obj2):
    if action_name == 'pickup_spanner':
        if obj1!= spanner1 or obj2!= location1 or location1 not in available_objects:
            return False
        if obj2!= spanner1 or spanner1 not in available_objects:
            return False
        return True
    if action_name == 'tighten_nut':
        if obj1!= nut1 or nut1 not in available_objects:
            return False
        if obj2!= gate or gate not in available_objects:
            return False
        return True
    if action_name == 'walk':
        if obj1!= bob or bob not in available_objects:
            return False
        if obj2!= shed or shed not in available_objects:
            return False
        return True
    if action_name == 'pickup_nut':
        if obj1!= nut1 or nut1 not in available_objects:
            return False
        if obj2!= gate or gate not in available_objects:
            return False
        return True
    if action_name == 'tighten_spanner':
        if obj1!= spanner1 or spanner1 not in available_objects:
            return False
        if obj2!= nut1 or nut1 not in available_objects:
            return False
        return True

    return False

def is_valid_plan(current_state, plan):
    for action in plan:
        obj1, obj2 = action.split()
        if not validate_action(obj1, obj1_obj[current_state][obj1], obj2_obj[current_state][obj2]):
            return False
    return True

def generate_spanner_s3_n3_l4_s1004299524():
    # create a symbolic representation of the state
    available_objects = {
        'bob','spanner1','spanner2','spanner3', 'nut1', 'nut2', 'nut3',
        'location1', 'location2', 'location3', 'location4', 'gate'
    }
    obj1_obj = {obj: available_objects for obj in available_objects}
    obj2_obj = {obj2: available_objects for obj2 in available_objects}
    links = [(shed, location1), (location4, gate), (location1, location2), (location2, location3), (location3, location4)]
    link_obj = {link: links for link in links}
    state = {
        obj: False for obj in available_objects
    }
    current_state = state

    # generate initial steps
    initial_steps = []
    if current_state['bob']:
        initial_steps.append(('walk', 'bob','shed'))
        current_state['bob'] = False
    if current_state['shed']:
        initial_steps.append(('walk','shed', 'bob'))
        current_state['shed'] = False
    if current_state['spanner1']:
        initial_steps.append(('walk','spanner1','shed'))
        current_state['spanner1'] = False
    if current_state['location4']:
        initial_steps.append(('walk', 'location4','shed'))
        current_state['location4'] = False
    if current_state['spanner2']:
        initial_steps.append(('walk','spanner2', 'location4'))
        current_state['spanner2'] = False
    if current_state['location3']:
        initial_steps.append(('walk', 'location3', 'location4'))
        current_state['location3'] = False
    if current_state['nut1']:
        initial_steps.append(('walk', 'nut1', 'location4'))
        current_state['nut1'] = False
    if current_state['gate']:
        initial_steps.append(('walk', 'gate', 'nut1'))
        current_state['gate'] = False
    if current_state['nut2']:
        initial_steps.append(('walk', 'nut2', 'gate'))
        current_state['nut2'] = False
    if current_state['nut3']:
        initial_steps.append(('walk', 'nut3', 'gate'))
        current_state['nut3'] = False

    # generate constraints
    constraints = []
    constraints.append((sometime_before, (tightened_nut2, tightened_nut3))))
    constraints.append((at_most_once, (at_bob, at_shed))))

    # generate available actions
    available_actions = {
        'pickup_spanner': [('shed','spanner1')],
        'tighten_nut': [('nut1', 'gate')],
        'walk': [('bob','shed'), ('shed', 'bob'), ('spanner1','shed'), ('location4','shed'), ('spanner2', 'location4'), ('location3', 'location4'), ('nut1', 'location4'), ('gate', 'nut1')],
        'pickup_nut': [('nut1', 'gate'), ('nut2', 'gate'), ('nut3', 'gate')],
        'tighten_spanner': [('spanner1', 'nut1')]
    }

    # generate plan
    plan = []
    if is_valid_state(current_state, constraints):
        while not is_valid_state(current_state, constraints):
            available_actions_list = []
            for action_name, action_obj in available_actions.items():
                available_action_list = []
                for obj1, obj2 in action_obj:
                    if obj1 in obj1_obj[current_state] and obj2 in obj2_obj[current_state]:
                        available_action_list.append((action_name, obj1, obj2))
                if available_action_list:
                    available_actions_list.append((action_name, available_action_list))
            available_actions_list.sort(key=lambda x: len(x[1]), reverse=True)
            for available_action in available_actions_list:
                action_name, action_obj = available_action[0], available_action[1]
                for obj1, obj2 in action_obj:
                    if validate_action(action_name, obj1, obj2):
                        obj1_obj[current_state][obj1] = True
                        obj2_obj[current_state][obj2] = True
                        if (action_name == 'pickup_spanner' and obj1 =='spanner1' and obj2 =='shed') or \
                           (action_name == 'tighten_nut' and obj1 == 'nut1' and obj2 == 'gate') or \
                           (action_name == 'walk' and obj1 == 'bob' and obj2 =='shed') or \
                           (action_name == 'pickup_nut' and obj1 == 'nut1' and obj2 == 'gate') or \
                           (action_name == 'tighten_spanner' and obj1 =='spanner1' and obj2 == 'nut1'):
                            plan.append((action_name, obj1, obj2))
                            current_state[obj1] = False
                            current_state[obj2] = False
                            break
                if is_valid_state(current_state, constraints):
                    break
    return plan

# generate spanner-s3-n3-l4-s1004299524 problem
spanner_s3_n3_l4_s1004299524_problem = generate_spanner_s3_n3_l4_s1004299524()

# print spanner-s3-n3-l4-s1004299524 problem
print(spanner_s3_n3_l4_l4-s1004299524)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1004299524.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/68)

--- Test 69/200 ---
Problem: spanner-s3-n3-l4-s1014352078
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ```python
(<pickup_spanner shed spanner1 location1>
 <pickup_spanner shed spanner2 location4>
 <pickup_spanner shed spanner3 location1>)
(<walk bob location1 spanner1 shed>
 <walk bob location2 spanner2 location4>
 <walk bob location3 spanner3 location1>)
(<tighten_nut location1 spanner1 shed nut1>
 <tighten_nut location1 spanner1 shed nut2>)
(<tighten_nut location4 spanner2 shed nut3>)
</problem>
```
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1014352078.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/69)

--- Test 70/200 ---
Problem: spanner-s3-n3-l4-s1047956130
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

@available_in_location(location1, location2, location3, location4)
@available_in_man(bob, spanner1, spanner2, spanner3, nut1, nut2, nut3)
(defuniform spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner spanner span
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1047956130.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/70)

--- Test 71/200 ---
Problem: spanner-s3-n3-l4-s1062212954
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1062212954.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/71)

--- Test 72/200 ---
Problem: spanner-s3-n3-l4-s1112759645
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/console]
available_objects = [
    'bob','spanner1','spanner2','spanner3', 'nut1', 'nut2', 'nut3',
    'location1', 'location2', 'location3', 'location4','shed', 'gate'
]

constraints = [
    {'type':'sometime-before', 'p1': f'at({bob} shed)', 'p2': f'tightened(nut1)', 'constraint_name':'s3-n3-l4-s1112759645_s3_n3_l4_s1112759645_s3_n3_l4_s1112759645'},
    {'type': 'at-most-once', 'p1': f'at({bob} shed)', 'constraint_name':'spanner-s3-n3-l4-s1112759645_s3_n3_l4_s1112759645'}
]

objects = [
    {'name': bob, 'type':'man'},
    {'name': shed, 'type': 'location'},
    {'name': spanner1, 'type':'spanner'},
    {'name': spanner2, 'type':'spanner'},
    {'name': spanner3, 'type':'spanner'},
    {'name': nut1, 'type': 'nut'},
    {'name': nut2, 'type': 'nut'},
    {'name': nut3, 'type': 'nut'},
    {'name': location1, 'type': 'location'},
    {'name': location2, 'type': 'location'},
    {'name': location3, 'type': 'location'},
    {'name': location4, 'type': 'location'},
    {'name': gate, 'type': 'location'},
    {'name': bob, 'type':'man', 'initial': True},
    {'name': shed, 'type': 'location', 'initial': True},
    {'name': spanner1, 'type':'spanner', 'initial': True},
    {'name': spanner2, 'type':'spanner', 'initial': True},
    {'name': spanner3, 'type':'spanner', 'initial': True},
    {'name': nut1, 'type': 'nut', 'initial': True},
    {'name': nut2, 'type': 'nut', 'initial': True},
    {'name': nut3, 'type': 'nut', 'initial': True},
    {'name': location1, 'type': 'location', 'initial': True},
    {'name': location2, 'type': 'location', 'initial': True},
    {'name': location3, 'type': 'location', 'initial': True},
    {'name': location4, 'type': 'location', 'initial': True},
    {'name': gate, 'type': 'location', 'initial': True},
    {'name': nut1, 'type': 'nut', 'tightened': True},
    {'name': nut2, 'type': 'nut', 'tightened': True},
    {'name': nut3, 'type': 'nut', 'tightened': True},
]

actions = [
    {'name': 'walk', 'parameters': ['start', 'end', 'obj'], 'precondition': [
        {'type': 'and', 'ps': [
            {'type': 'at', 'p1': f'at({obj} {start})'},
            {'type': 'at', 'p1': f'at({obj} {end})'},
            {'type': 'link', 'p1': f'link({start} {end})'}
        ]},
        {'type': 'forall', 'p1': f'forall (?obj locatable)', 
         'p2':'sometime-before (at(?obj shed))'}
    ]},
    {'name': 'pickup_spanner', 'parameters': ['obj','spanner', 'obj2'], 'precondition': [
        {'type': 'and', 'ps': [
            {'type': 'at', 'p1': f'at({obj} {start})'},
            {'type': 'at', 'p1': f'at({spanner} {start})'},
            {'type': 'or', 'p1': 'not(useable(spanner))'},
            {'type': 'or', 'p1': 'not(at(spanner {start}))'},
            {'type': 'or', 'p1': 'not(at(spanner {end}))'},
            {'type': 'and', 'ps': [
                {'type': 'at', 'p1': f'at({obj2} {start})'},
                {'type': 'or', 'p1': 'not(useable(spanner))'},
                {'type': 'or', 'p1': 'not(at(spanner {start}))'},
                {'type': 'or', 'p1': 'not(at(spanner {end}))'},
                {'type': 'and', 'ps': [
                    {'type': 'at', 'p1': f'at({obj2} {start})'},
                    {'type': 'or', 'p1': 'not(carrying(obj))'},
                    {'type': 'or', 'p1': 'not(at(obj {start}))'},
                    {'type': 'or', 'p1': 'not(at(obj {end}))'}
                ]}
            ]}
        ]}
    ]},
    {'name': 'tighten_nut', 'parameters': ['obj','spanner', 'nut', 'obj2'], 'precondition': [
        {'type': 'and', 'ps': [
            {'type': 'at', 'p1': f'at({obj} {start})'},
            {'type': 'at', 'p1': f'at({nut} {start})'},
            {'type': 'or', 'p1': 'not(useable(spanner))'},
            {'type': 'or', 'p1': 'not(at(spanner {start}))'},
            {'type': 'or', 'p1': 'not(at(spanner {end}))'},
            {'type': 'and', 'ps': [
                {'type': 'at', 'p1': f'at({obj2} {start})'},
                {'type': 'or', 'p1': 'not(useable(spanner))'},
                {'type': 'or', 'p1': 'not(at(spanner {start}))'},
                {'type': 'or', 'p1': 'not(at(spanner {end}))'},
                {'type': 'and', 'ps': [
                    {'type': 'at', 'p1': f'at({nut} {start})'},
                    {'type': 'or', 'p1': 'not(tightened(nut))'},
                    {'type': 'or', 'p1': 'not(at(nut {start}))'},
                    {'type': 'or', 'p1': 'not(at(nut {end}))'}
                ]}
            ]}
        ]}
    ]}
]

goal_constraints = []

for constraint in constraints:
    if constraint['type'] =='sometime-before':
        p1_obj = constraint['p1']
        p2_obj = constraint['p2']
        if isinstance(p1_obj, str):
            p1_obj = [obj for obj in objects if obj['name'] == p1_obj]
            p2_obj = [obj for obj in objects if obj['name'] == p2_obj]
        if isinstance(p1_obj[0]['type'], 'at') and isinstance(p2_obj[0]['type'], 'at'):
            start = p1_obj[0]['p1'].split(' ')[1]
            end = p2_obj[0]['p1'].split(' ')[1]
            goal_constraints.append({'type':'sometime-before','start': f'at({start})', 'goal': f'at({end})'})
        elif isinstance(p1_obj[0]['type'], 'at') and isinstance(p2_obj[0]['type'], 'or'):
            start = p1_obj[0]['p1'].split(' ')[1]
            goal_constraints.append({'type':'sometime-before','start': f'at({start})', 'goal': 'at(nut)'})
        elif isinstance(p1_obj[0]['type'], 'or') and isinstance(p2_obj[0]['type'], 'at'):
            goal_constraints.append({'type':'sometime-before','start': 'at(nut)', 'goal': f'at({p2_obj[0]["p1"].split(' ')[1]})'})
        elif isinstance(p1_obj[0]['type'], 'or') and isinstance(p2_obj[0]['type'], 'or'):
            goal_constraints.append({'type':'sometime-before','start': 'at(nut)', 'goal': f'at({p2_obj[0]["p1"].split(' ')[1]})'})
    elif constraint['type'] == 'at-most-once':
        p1_obj = constraint['p1']
        if isinstance(p1_obj, str):
            p1_obj = [obj for obj in objects if obj['name'] == p1_obj]
        if isinstance(p1_obj[0]['type'], 'at'):
            start = p1_obj[0]['p1'].split(' ')[1]
            goal_constraints.append({'type': 'at-most-once','start': f'at({start})'})

def validate_plan(obj, action, obj2, start, end, spanner, nut, obj3
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1112759645.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/72)

--- Test 73/200 ---
Problem: spanner-s3-n3-l4-s1127478349
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1127478349.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/73)

--- Test 74/200 ---
Problem: spanner-s3-n3-l4-s1228015176
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [--seed=1228015176]  # No need to include in the output

<DATE>
2023-08-16 00-00-00
</DATE>

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 1228015176 --problem-name spanner-s3-n3-l4-s1228015176
(define (problem spanner-s3-n3-l4-s1228015176)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location2)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

--
(NO-PLAN)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1228015176.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/74)

--- Test 75/200 ---
Problem: spanner-s3-n3-l4-s1260724014
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:link location1 location2
#:link location2 location3
#:link location3 location4

(at bob location1)
(carrying spanner1 location1)
(useable spanner1)
(at spanner1 location2)
(link location4 gate)
(at gate location4)
(loose nut1)
(at nut1 gate)
(tightened nut1)
(at bob location4)
(carrying spanner3 location4)
(useable spanner3)
(at spanner3 gate)
(carrying spanner2 gate)
(useable spanner2)
(at spanner2 gate)
(tightened nut2)
(at nut2 gate)
(at nut2 location3)
(carrying nut3 location3)
(useable nut3)
(tightened nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1260724014.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/75)

--- Test 76/200 ---
Problem: spanner-s3-n3-l4-s1328228503
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s3-n3-l4-s1328228503"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
spanner_generator.generate_domain(domain)

problem = "<PROBLEM>"
spanner_generator.generate_problem(problem_name, domain)

# Planning Rules
print("1) Only use available symbols:")
print("   - objects declared under PROBLEM :objects, and")
print("   - constants declared under DOMAIN/PROBLEM :constants (if any).")
print(" Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.")

print("2) Constraints:")
if "constraints" in problem:
    print("   If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent),")
    print("     EVERY such constraint MUST be satisfied.")
else:
    print("   If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.")

print("3) Plan form:")
print("   Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.")

print("4) Internal validation before emitting (do not include reasoning in the output):")
print("   At each step, all action preconditions hold in the current state.")
print("   Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.")
if "constraints" in problem:
    print("   If constraints exist in PROBLEM, ensure the plan satisfies all of them.")

# Output Requirements
print("Output Requirements")
print("- Return **ONLY** the plan steps, one per line.")
print("- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`")
print("- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).")
print("- No numbering, timestamps, costs, comments, headers, code fences, or extra text.")
print("- No blank lines at the start or end; no trailing spaces; use a single space between tokens.")
print("- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).")
print("- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`")

# Examples
print("Examples")
print("Bad:")
print("  (move a b)")
print("  (two actions on one line)")
print("  (move a) extra")
print()
print("Good:")
print(" (move a b)")
print(" (pick a c)")
print(" (drop a d)")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1328228503.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/76)

--- Test 77/200 ---
Problem: spanner-s3-n3-l4-s1342257121
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: <action-pickup-spanner>
  (at bob shed)
  (at spanner1 location4)
  (at bob location1)
  (pickup spanner1 bob location1)
</action-pickup-spanner>
<action-pickup-nut>
  (at bob location1)
  (at nut1 gate)
  (at bob location1)
  (pickup nut1 bob location1)
</action-pickup-nut>
<action-walk>
  (at bob location1)
  (at nut1 location1)
  (walk bob location2)
</action-walk>
<action-pickup-nut>
  (at bob location2)
  (at nut2 gate)
  (at bob location2)
  (pickup nut2 bob location2)
</action-pickup-nut>
<action-walk>
  (at bob location2)
  (at nut2 location2)
  (walk bob location3)
</action-walk>
<action-tighten-nut>
  (at bob location3)
  (at spanner3 location4)
  (at bob location3)
  (tighten nut2 bob location3)
</action-tighten-nut>
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1342257121.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/77)

--- Test 78/200 ---
Problem: spanner-s3-n3-l4-s1376512600
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/console]
available_objects = [
    'bob','spanner1','spanner2','spanner3', 'nut1', 'nut2', 'nut3',
    'location1', 'location2', 'location3', 'location4','shed', 'gate'
]

constraints = [
    {'type':'sometime-before', 'p1': f'at({bob} shed)', 'p2': f'tightened(nut1)'},
    {'type': 'at-most-once', 'p1': f'at({bob} shed)'}
]

available_actions = {
    'bob': ['walk', 'pickup_spanner', 'tighten_nut'],
   'shed': ['link', 'unlock'],
    'location1': ['link', 'unlock'],
    'location2': ['link', 'unlock'],
    'location3': ['link', 'unlock'],
    'location4': ['link', 'unlock'],
   'spanner1': ['pickup_spanner'],
   'spanner2': ['pickup_spanner'],
   'spanner3': ['pickup_spanner'],
    'nut1': ['tighten_nut'],
    'nut2': ['tighten_nut'],
    'nut3': ['tighten_nut'],
    'gate': ['unlock']
}

action_requirements = {
    'walk': {'precondition': ['at(bob)', 'link(shed', 'location1)']},
    'pickup_spanner': {'precondition': ['at(bob)', 'at(spanner1', 'location1)', 'at(spanner2', 'location2)', 'at(spanner3', 'location2)']},
    'tighten_nut': {'precondition': ['at(bob)', 'at(nut1', 'gate)', 'at(nut2', 'gate)', 'at(nut3', 'gate)', 'at(spanner1', 'location1)', 'useable(spanner1)']}
}

def validate_plan(plan, state):
    for action in plan:
        obj1, obj2 = action.split()
        obj1 = obj1.strip()
        obj2 = obj2.strip()
        if obj1 in available_objects and obj2 in available_objects:
            if obj1 == obj2:
                raise Exception(f"Cannot perform action on object itself: {action}")
            if obj1 in available_objects and obj2 in available_objects:
                if (obj1 == 'bob' and obj2 in ['shed', 'gate']) or (obj2 == 'bob' and obj1 in ['shed', 'gate']):
                    raise Exception(f"Cannot move {obj1} to {obj2}: at_most_once constraint")
                if obj1 in ['shed', 'gate'] and obj2 in available_objects:
                    if action == 'link':
                        if obj1 =='shed' and obj2 == 'location1' and not state['shed_link']:
                            raise Exception(f"Cannot link shed to location1: shed_link constraint")
                        if obj1 == 'gate' and obj2 == 'location1' and not state['gate_link']:
                            raise Exception(f"Cannot link gate to location1: gate_link constraint")
                        if obj1 =='shed' and obj2 == 'gate' and not state['shed_gate_link']:
                            raise Exception(f"Cannot link shed to gate: shed_gate_link constraint")
                    if obj2 in ['shed', 'gate'] and obj1 in available_objects:
                        if action == 'unlock':
                            if obj2 =='shed' and not state['shed_unlocked']:
                                raise Exception(f"Cannot unlock shed: shed_unlocked constraint")
                            if obj2 == 'gate' and not state['gate_unlocked']:
                                raise Exception(f"Cannot unlock gate: gate_unlocked constraint")
                        if obj1 =='shed' and obj2 == 'gate':
                            raise Exception(f"Cannot link shed to gate: at_most_once constraint")
                if obj1 in available_objects and obj2 in available_objects:
                    if action == 'pickup_spanner':
                        if obj1 == obj2:
                            raise Exception(f"Cannot pick spanner from spanner: pickup_spanner constraint")
                    if obj1 == 'nut1' and obj2 == 'nut2' and obj1!= obj2:
                        raise Exception(f"Cannot tighten spanner: tighten_nut_constraint")
                    if obj1 == 'nut1' and obj2 == 'nut3' and obj1!= obj2:
                        raise Exception(f"Cannot tighten spanner: tighten_nut_constraint")
                    if obj1 == 'nut2' and obj2 == 'nut3' and obj1!= obj2:
                        raise Exception(f"Cannot tighten spanner: tighten_nut_constraint")
                    if obj1 == 'nut1' and obj2 == 'nut2' and obj1 == obj2:
                        if not constraints:
                            raise Exception(f"No constraints provided for tightening spanner: tighten_nut_constraint")
                        for constraint in constraints:
                            if'sometime-before' in constraint['type']:
                                if constraint['p1'].split()[0] == 'at(nut1, gate)' and constraint['p2'].split()[0] == 'at(nut2, gate)':
                                    raise Exception(f"Cannot tighten spanner: sometime-before constraint")
                            if constraint['type'] == 'at-most-once':
                                if constraint['p1'].split()[0] == 'at(nut1, gate)':
                                    raise Exception(f"Cannot tighten spanner: at_most_once constraint")
                    if obj1 == 'nut1' and obj2 == 'nut2' and obj1 == obj2:
                        if not constraints:
                            raise Exception(f"No constraints provided for tightening spanner: tighten_nut_constraint")
                        for constraint in constraints:
                            if'sometime-before' in constraint['type']:
                                if constraint['p1'].split()[0] == 'at(nut1, gate)' and constraint['p2'].split()[0] == 'at(nut2, gate)':
                                    raise Exception(f"Cannot tighten spanner: sometime-before constraint")
                            if constraint['type'] == 'at-most-once':
                                if constraint['p1'].split()[0] == 'at(nut1, gate)':
                                    raise Exception(f"Cannot tighten spanner: at_most_once constraint")
                    if obj1 == 'nut1' and obj2 == 'nut2' and obj1!= obj2:
                        if not constraints:
                            raise Exception(f"No constraints provided for tightening spanner: tighten_nut_constraint")
                        for constraint in constraints:
                            if'sometime-before' in constraint['type']:
                                if constraint['p1'].split()[0] == 'at(nut1, gate)' and constraint['p2'].split()[0] == 'at(nut2, gate)':
                                    raise Exception(f"Cannot tighten spanner: sometime-before constraint")
                            if constraint['type'] == 'at-most-once':
                                if constraint['p1'].split()[0] == 'at(nut1, gate)':
                                    raise Exception(f"Cannot tighten spanner: at_most_once constraint")
                    if obj1 == 'nut2' and obj2 == 'nut3' and obj1!= obj2:
                        if not constraints:
                            raise Exception(f"No constraints provided for tightening spanner: tighten_nut_constraint")
                        for constraint in constraints:
                            if'sometime-before' in constraint['type']:
                                if constraint['p1'].split()[0] == 'at(nut1, gate)' and constraint['p2'].split()[0] == 'at(nut2, gate)':
                                    raise Exception(f"Cannot tighten spanner: sometime-before constraint")
                            if constraint['type'] == 'at-most-once':
                                if constraint['p1'].split()[0] == 'at(nut1, gate)':
                                    raise Exception(f"Cannot tighten spanner: at_most_once constraint")
                    if obj1 == 'nut2' and obj2 == 'nut3' and obj1 == obj2:
                        if not constraints:
                            raise Exception(f"No constraints provided for tightening spanner: tighten_nut_constraint")
                        for constraint in constraints:
                            if'sometime-before' in constraint['type']:
                                if constraint['p1'].split()[0] == 'at(nut1, gate)' and constraint['p2'].split()[0] == 'at(nut2, gate)':
                                    raise Exception(f"Cannot tighten spanner: sometime-before constraint")
                            if constraint['type'] == 'at-most-once':
                                if constraint['p1'].split()[0] == 'at(nut1, gate)':
                                    raise Exception(f"Cannot tighten spanner: at_most_once constraint")
                    if obj1 == 'nut2' and obj2 == 'nut3' and obj1!= obj2:
                        if not constraints:
                            raise Exception(f"No constraints provided for tightening spanner: tighten_nut_constraint")
                        for constraint in constraints:
                            if'sometime-before' in constraint['type']:
                                if constraint['p1'].split()[0] == 'at(nut1, gate)' and constraint['p2'].split()[0] == 'at(nut2, gate)':
                                    raise Exception(f"Cannot tighten spanner: sometime-before constraint")
                            if constraint['type'] == 'at-most-once':
                                if constraint['p1'].split()[0] == 'at(nut1, gate)':
                                    raise Exception(f"Cannot tighten spanner: at_most_once constraint")
                if obj1!= obj2:
                    if action == 'pickup_spanner':
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1376512600.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/78)

--- Test 79/200 ---
Problem: spanner-s3-n3-l4-s1408015783
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1408015783.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/79)

--- Test 80/200 ---
Problem: spanner-s3-n3-l4-s1467629902
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
import (re)
from (range) import *
from (pddlvis2.gen.planning.solvers.strips.reactive.reactive_solver import ReactiveSolver) import  # NOSONE
from (pddlvis2.gen.planning.solvers.strips.reactive.reactive_planner import ReactivePlanner) import  # NOSONE
from (pddlvis2.gen.planning.solvers.strips.reactive.reactive_producer import ReactiveProducer) import  # NOSONE

# Produce the final output.
problem_name = "spanner-s3-n3-l4-s1467629902"
producer = ReactiveProducer(problem_name=problem_name, domain_name="spanner", constraints=None, template_file=None, seed=1467629902)
solver = ReactiveSolver(proproblem=producer.proproblem, solver_name="spanner-s3-n3-l4-s1467629902-solver", domain_name="spanner", constraints=None, template_file=None, seed=1467629902)
plan_generator = ReactivePlanner(proproblem=producer.proproblem, planner_name="spanner-s3-n3-l4-s1467629902-planner", domain_name="spanner", constraints=None, template_file=None, seed=1467629902)

open_file = open(f"spanner-s3-n3-l4-s1467629902.input", "w+")
producer.produce(open_file)
open_file.close()

open_file = open(f"spanner-s3-n3-l4-s1467629902.valid", "w+")
solver.solve(open_file)
open_file.close()

open_file = open(f"spanner-s3-n3-l4-s1467629902.plan", "w+")
plan_generator.generate(open_file)
open_file.close()
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1467629902.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/80)

--- Test 81/200 ---
Problem: spanner-s3-n3-l4-s1468146869
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ')?></problem>
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 1468146869 --problem-name spanner-s3-n3-l4-s1468146869
(define (problem spanner-s3-n3-l4-s1468146869)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location1)
    (useable spanner1)
    (at spanner2 location2)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)
- (move a)
- extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

```python
#: No printing allowed in this environment, but we'll use Python to generate the final output outside of the # Problem directive.
available_objects = [
    "bob", "spanner1", "spanner2", "spanner3", "nut1", "nut2", "nut3",
    "location1", "location2", "location3", "location4", "shed", "gate"
]
goal_objects = ["nut1", "nut2", "nut3"]
action_objects = [
    "walk", "pickup_spanner", "tighten_nut"
]
available_actions = [
    "pickup_spanner", "tighten_nut"
]

def generate_plan():
    plan = []
    at_bob = ("shed", bob)
    at_spanner1 = (location1, spanner1)
    at_spanner2 = (location2, spanner2)
    at_spanner3 = (location4, spanner3)
    useable_spanner1 = (location1, useable_spanner1)
    useable_spanner2 = (location2, useable_spanner2)
    useable_spanner3 = (location4, useable_spanner3)
    loose_nut1 = (gate, loose_nut1)
    at_nut1 = (gate, nut1)
    loose_nut2 = (gate, loose_nut2)
    at_nut2 = (gate, nut2)
    loose_nut3 = (gate, loose_nut3)
    at_nut3 = (gate, nut3)

    # Generate initial steps
    if at_bob[0] == at_spanner1[0]:  # Bob is at spanner1 location
        plan.append((at_bob, at_spanner1))
        at_bob = at_spanner1
    if at_spanner1[0] == at_spanner2[0]:  # Spanner1 is at spanner2 location
        plan.append((at_spanner1, at_spanner2))
        at_spanner1 = at_spanner2
    if at_spanner2[0] == at_spanner3[0]:  # Spanner2 is at spanner3 location
        plan.append((at_spanner2, at_spanner3))
        at_spanner2 = at_spanner3
    if at_spanner3[0] == at_spanner1[0]:  # Spanner3 is at spanner1 location
        at_spanner3 = at_spanner1
    if at_spanner1[0] == at_useable_spanner1[0]:  # Spanner1 is useable
        plan.append((at_spanner1, at_useable_spanner1))
        at_spanner1 = at_useable_spanner1
    if at_spanner2[0] == at_useable_spanner2[0]:  # Spanner2 is useable
        plan.append((at_spanner2, at_useable_spanner2))
        at_spanner2 = at_useable_spanner2
    if at_spanner3[0] == at_useable_spanner3[0]:  # Spanner3 is useable
        plan.append((at_spanner3, at_useable_spanner3))
        at_spanner3 = at_useable_spanner3

    if at_spanner1[1] == at_nut1[1]:  # Spanner1 is carrying nut1
        at_spanner1 = at_nut1
    if at_spanner2[1] == at_nut2[1]:  # Spanner2 is carrying nut2
        at_spanner2 = at_nut2
    if at_spanner3[1] == at_nut3[1]:  # Spanner3 is carrying nut3
        at_spanner3 = at_nut3

    # Generate goal-directed steps
    while at_spanner1[0] == at_spanner3[0] and at_spanner1[1] == at_nut1[1] and at_spanner2[0
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1468146869.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/81)

--- Test 82/200 ---
Problem: spanner-s3-n3-l4-s1480221858
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1480221858.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/82)

--- Test 83/200 ---
Problem: spanner-s3-n3-l4-s1480402990
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
import (re)
from (range) import *
from (pddlpython3) import *
goal = parse"""
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 1480402990 --problem-name spanner-s3-n3-l4-s1480402990
(define (problem spanner-s3-n3-l4-s1480402990)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location1)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location3)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

obj = []
actions = [
 "walk",
 "pickup_spanner",
 "tighten_nut"
]
args = []
for a in actions:
 if a == "walk":
  args.append([("bob", "shed"), ("bob", "location1"), ("bob", "location2"), ("bob", "location3"), ("bob", "gate"), ("bob", "nut3"), ("bob", "nut2"), ("bob", "nut1")])
  obj.append("bob")
 obj.append("shed")
 obj.append("location1")
 obj.append("location2")
 obj.append("location3")
 obj.append("gate")
 obj.append("nut1")
 obj.append("nut2")
 obj.append("nut3")
 elif a == "pickup_spanner":
  args.append([("bob", "location1"), ("bob", "nut3"), ("bob", "nut2"), ("bob", "nut1"), ("bob", "gate"), ("bob", "spanner1"), ("bob", "spanner2")])
  obj.append("bob")
 obj.append("location1")
 obj.append("nut3")
 obj.append("nut2")
 obj.append("nut1")
 obj.append("gate")
 obj.append("spanner1")
 obj.append("spanner2")
 elif a == "tighten_nut":
  args.append([("bob", "location1"), ("bob", "nut3"), ("bob", "nut2"), ("bob", "nut1"), ("bob", "gate"), ("bob", "nut3"), ("bob", "nut2"), ("bob", "nut1")])
  obj.append("bob")
 obj.append("location1")
 obj.append("nut3")
 obj.append("nut2")
 obj.append("nut1")
 obj.append("gate")
 for i in range(3):
  obj.append("nut" + str(i))
for i in range(len(obj)):
 if obj[i].find("man") == -1 and obj[i].find("spanner") == -1 and obj[i].find("nut") == -1 and obj[i].find("location") == -1 and obj[i].find("gate") == -1 and obj[i].find("shed") == -1 and obj[i].find("bob") == -1:
  obj.pop(i)
for i in range(len(args)):
 for j in range(len(args[i])):
  if args[i][j].find("location")!= -1:
   args[i][j] = args[i][j][6:]
 for i in range(len(args)):
  for j in range(len(args[i])):
   if args[i][j].find("nut")!= -1:
    args[i][j] = args[i][j][2:]
 for i in range(len(args)):
  for j in range(len(args[i])):
   if args[i][j].find("man")!= -1:
    args[i][j] = args[i][j][3:]
 for i in range(len(args)):
  for j in range(len(args[i])):
   if args[i][j].find("spanner")!= -1:
    args[i][j] = args[i][j][7:]
for i in range(len(obj)):
 for j in range(len(args)):
  if obj[i].find(args[j][0])!= -1:
   obj.pop(i)
   del args[j][0]
for i in range(len(args)):
 if len(args[i]) == 1:
  del args[i]
print("".join([(" " + a + " " + obj[i] for i in range(len(obj)) for a in args if i < len(args[i]))]))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1480402990.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/83)

--- Test 84/200 ---
Problem: spanner-s3-n3-l4-s1486314535
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1486314535.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/84)

--- Test 85/200 ---
Problem: spanner-s3-n3-l4-s1523611025
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
 :parameters (?start - location?end - location?m - man)
 :precondition (and (at?m?start) 
                     (link?start?end))
 :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
 :parameters (?l - location?s - spanner?m - man)
 :precondition (and (at?m?l) 
                     (at?s?l))
 :effect (and (not (at?s?l))
               (carrying?m?s)))

#:action tighten_nut 
 :parameters (?l - location?s - spanner?m - man?n - nut)
 :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
 :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1523611025.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/85)

--- Test 86/200 ---
Problem: spanner-s3-n3-l4-s1558051475
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

@available_action(nut1) 
(at nut1 gate)
@available_action(nut2) 
(at nut2 gate)
@available_action(nut3) 
(at nut3 gate)
@available_action(spanner1) 
(at spanner1 location3)
@available_action(spanner2) 
(at spanner2 location4)
@available_action(spanner3) 
(at spanner3 location1)
@available_action(bob) 
(at bob shed)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1558051475.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/86)

--- Test 87/200 ---
Problem: spanner-s3-n3-l4-s1564361267
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: def validate_problem(domain, problem):
    # Import necessary modules
    import PDDL3.PDDL3 as p3
    import PDDL3.PDDL3Rules as p3r
    import PDDL3.PDDL3GoalDirectors as p3g
    import PDDL3.PDDL3Constraints as p3c
    import PDDL3.PDDL3Generators as p3g1
    import PDDL3.PDDL3Utilities as p3u

    # Parse domain and problem
    domain = p3.PDDLReader(domain).read_domain()
    problem = p3.PDDLReader(problem).read_problem(domain)

    # Check if the problem includes constraints
    if problem.problems:
        # If constraints exist, check if all constraints are satisfied
        for constraint in problem.problems[0].constraints:
            if not p3u.satisfy(domain, problem, constraint):
                return False

    # Check if the problem has a goal
    if problem.object_goals:
        # If a goal exists, check if all goals are satisfied
        for obj_goal in problem.object_goals:
            if not p3u.satisfy(domain, problem, obj_goal):
                return False

    # If no constraints or goals, check if the initial state satisfies all safety constraints
    if not problem.safety_constraints:
        safe_initial_state = p3u.satisfy(domain, problem, problem.initial_state)
        if not safe_initial_state:
            return False

    # If all checks pass, return True
    return True


def generate_problem(domain_name, problem_name, num_objects, num_actions, seed, constraints=False):
    # Import necessary modules
    import random
    import string
    import PDDL3.PDDL3 as p3
    import PDDL3.PDDL3Rules as p3r
    import PDDL3.PDDL3GoalDirectors as p3g
    import PDDL3.PDDL3Constraints as p3c
    import PDDL3.PDDL3Generators as p3g1
    import PDDL3.PDDL3Utilities as p3u

    # Generate domain and problem
    domain = p3.PDDLDomainGenerator().generate_domain(
        name=domain_name,
        constants=p3.PDDLConstantGenerator().generate_constants(
            object_types=['location','man','spanner', 'nut'],
            quantity=num_objects
        )
    )
    problem = p3.PDDLProblemGenerator().generate_problem(
        name=problem_name,
        domain=domain,
        constants=p3.PDDLConstantGenerator().generate_constants(
            object_types=['man','spanner', 'nut', 'location'],
            quantity=num_objects
        )
    )

    # Add safety constraints
    if not constraints:
        safety_constraints = [
            p3c.SafetyConstraint(p3.PDDLVariable('bob'), 'inside', 'location'),
            p3c.SafetyConstraint(p3.PDDLVariable('spanner'), 'carrying','spanner'),
            p3c.SafetyConstraint(p3.PDDLVariable('nut'), 'loose', 'nut'),
            p3c.SafetyConstraint(p3.PDDLVariable('nut'), 'tightened', 'nut'),
            p3c.SafetyConstraint(p3.PDDLVariable('nut'), 'inside', 'location')
        ]
        problem.safety_constraints = safety_constraints
        problem.object_goals = [p3.PDDLGoal(p3.PDDLVariable('bob'), 'inside', 'location'),
                                p3.PDDLGoal(p3.PDDLVariable('spanner'), 'carrying','spanner'),
                                p3.PDDLGoal(p3.PDDLVariable('nut'), 'loose', 'nut'),
                                p3.PDDLGoal(p3.PDDLVariable('nut'), 'tightened', 'nut'),
                                p3.PDDLGoal(p3.PDDLVariable('nut'), 'inside', 'location')]

    # Generate initial state and goal
    initial_state = p3.PDDLStateGenerator().generate_initial_state(domain, problem)
    goal = p3.PDDLGoalGenerator().generate_goal(domain, problem)

    # Check if problem satisfies constraints
    if validate_problem(domain.name, problem.name):
        return domain, problem, initial_state, goal
    else:
        return None


def generate_spanner_s3_n3_l4_s1564361267():
    domain, problem, initial_state, goal = generate_problem('spanner','spanner-s3-n3-l4-s1564361267', 3, 3, 1564361267, constraints=True)
    return domain, problem, initial_state, goal


domain, problem, initial_state, goal = generate_spanner_s3_n3_l4_s1564361267()
print("DOMAIN:")
print(problem.domain)
print("PROBLEM:")
print(problem.problem)
print("INITIAL STATE:")
print(initial_state)
print("GOAL:")
print(goal)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1564361267.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/87)

--- Test 88/200 ---
Problem: spanner-s3-n3-l4-s1641516798
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
 :parameters (?start - location?end - location?m - man)
 :precondition (and (at?m?start) 
                     (link?start?end))
 :effect (and (not (at?m?start)) (at?m?end))

#:action pickup_spanner 
 :parameters (?l - location?s - spanner?m - man)
 :precondition (and (at?m?l) 
                     (at?s?l))
 :effect (and (not (at?s?l))
               (carrying?m?s))

#:action tighten_nut 
 :parameters (?l - location?s - spanner?m - man?n - nut)
 :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
 :effect (and (not (loose?n))(not (useable?s)) (tightened?n))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1641516798.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/88)

--- Test 89/200 ---
Problem: spanner-s3-n3-l4-s1696750966
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/console]
available_objects = [
    'bob','spanner1','spanner2','spanner3', 'nut1', 'nut2', 'nut3',
    'location1', 'location2', 'location3', 'location4','shed', 'gate'
]

constraints = None
if 'constraints' in problem.keys():
    constraints = problem['constraints']

available_objects = [obj for obj in available_objects if obj not in constraints and obj is not None]

objects = {
    obj: obj for obj in available_objects
    if obj.startswith('object_') or obj.startswith('nut_') or obj.startswith('spanner_') or obj.startswith('location_')
}

actions = {
    'walk': {
        'params': ['start_location', 'end_location','man'],
        'precondition': ['at_man_start_location', 'link_start_location_end_location'],
        'effect': ['not_at_man_start_location', 'at_man_end_location']
    },
    'pickup_spanner': {
        'params': ['man','spanner_location','spanner'],
        'precondition': ['at_man_spanner_location', 'at_spanner_spanner_location'],
        'effect': ['not_at_spanner_spanner_location', 'carrying_man_spanner']
    },
    'tighten_nut': {
        'params': ['man','spanner_location', 'nut_location','spanner', 'nut'],
        'precondition': ['at_man_spanner_location', 'at_nut_nut_location', 'carrying_man_spanner', 'useable_spanner', 'loose_nut'],
        'effect': ['not_loose_nut', 'not_useable_spanner', 'tightened_nut']
    }
}

man = objects['bob']
spanner1 = objects['spanner1']
spanner2 = objects['spanner2']
spanner3 = objects['spanner3']
nut1 = objects['nut1']
nut2 = objects['nut2']
nut3 = objects['nut3']
location1 = objects['location1']
location2 = objects['location2']
location3 = objects['location3']
location4 = objects['location4']
shed = objects['shed']
gate = objects['gate']

start_location = location1
end_location = location4
start_man_location = shed
end_man_location = gate

available_actions = list(actions.keys())

available_objects = [obj for obj in available_objects if obj!='shed' and obj!= 'gate']

available_spanners = [spanner for spanner in available_objects if spanner.startswith('spanner')]

available_nuts = [nut for nut in available_objects if nut.startswith('nut')]

available_locations = [location for location in available_objects if location.startswith('location')]

available_mans = [man for man in available_objects if man.startswith('man')]

available_objects = [obj for obj in available_objects if obj!='shed' and obj!= 'gate' and obj!= man and obj!= spanner1 and obj!= spanner2 and obj!= spanner3 and obj!= nut1 and obj!= nut2 and obj!= nut3 and obj!= start_location and obj!= end_location and obj!= start_man_location and obj!= end_man_location]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_objects = [obj for obj in available_objects if obj!='shed' and obj!= 'gate' and obj!= man and obj!= spanner1 and obj!= spanner2 and obj!= spanner3 and obj!= nut1 and obj!= nut2 and obj!= nut3 and obj!= start_location and obj!= end_location and obj!= start_man_location and obj!= end_man_location and obj!= available_spanners and obj!= available_nuts and obj!= available_locations and obj!= available_mans]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
available_nuts = [nut for nut in available_nuts if nut!= nut1 and nut!= nut2]
available_locations = [location for location in available_locations if location!= location1 and location!= location2 and location!= location3 and location!= location4]
available_mans = [man for man in available_mans if man!= man]

available_spanners = [spanner for spanner in available_spanners if spanner!= spanner1 and spanner!= spanner2 and spanner!= spanner3]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1696750966.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/89)

--- Test 90/200 ---
Problem: spanner-s3-n3-l4-s1759715865
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
 :parameters (?start - location?end - location?m - man)
 :precondition (and (at?m?start) 
                     (link?start?end))
 :effect (and (not (at?m?start)) (at?m?end))

#:action pickup_spanner 
 :parameters (?l - location?s - spanner?m - man)
 :precondition (and (at?m?l) 
                     (at?s?l))
 :effect (and (not (at?s?l))
               (carrying?m?s))

#:action tighten_nut 
 :parameters (?l - location?s - spanner?m - man?n - nut)
 :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
 :effect (and (not (loose?n))(not (useable?s)) (tightened?n))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1759715865.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/90)

--- Test 91/200 ---
Problem: spanner-s3-n3-l4-s1829016842
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s1829016842.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/91)

--- Test 92/200 ---
Problem: spanner-s3-n3-l4-s2008090643
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

@available_actions = [
  "walk", "pickup_spanner", "tighten_nut"
]

@objects = {
 'man': ['bob'],
 'spanner': ['spanner1','spanner2','spanner3'],
  'nut': ['nut1', 'nut2', 'nut3'],
  'location': ['location1', 'location2', 'location3', 'location4'],
 'shed':'shed',
  'gate': 'gate'
}

@constraints = []

@available_objects = objects.keys()

@available_links = [
  ('shed', 'location1'),
  ('location4', 'gate'),
  ('shed', 'location1'),
  ('location1', 'location2'),
  ('location2', 'location3'),
  ('location3', 'location4')
]

@available_variables = objects.keys() + links.keys()

@current_state = {
  'at': {'bob':'shed'},
  'carrying': {'bob':'spanner1'},
  'useable': {'spanner1': True,'spanner2': True,'spanner3': True},
  'loose': {'nut1': True, 'nut2': True, 'nut3': True},
  'link': {
    ('shed', 'location1'): True,
    ('location4', 'gate'): True,
    ('shed', 'location1'): True,
    ('location1', 'location2'): True,
    ('location2', 'location3'): True,
    ('location3', 'location4'): True
  }
}

available_actions = [action for action in available_actions if available_state(action, current_state)]

def available_state(action, state):
  if action == "walk":
    return (state['at']['bob'] =='shed') and (state['link'][('shed', 'location1')]) and (state['link'][( 'location1', 'location2')]) and (state['link'][( 'location2', 'location3')]) and (state['link'][( 'location3', 'location4')]) and (state['link'][( 'location4', 'gate')]) 
  elif action == "pickup_spanner":
    return (state['at']['bob'] =='shed') and (state['link'][('shed', 'location1')]) and (state['link'][( 'location1', 'location2')]) and (state['link'][( 'location2', 'location3')]) and (state['link'][( 'location3', 'location4')]) and (state['link'][( 'location4', 'gate')]) and (state['carrying']['bob']) and (state['useable']['spanner1']) and (state['loose']['nut2']) and (state['loose']['nut3'])
    return False
  elif action == "tighten_nut":
    return (state['at']['bob'] =='shed') and (state['link'][('shed', 'location1')]) and (state['link'][( 'location1', 'location2')]) and (state['link'][( 'location2', 'location3')]) and (state['link'][( 'location3', 'location4')]) and (state['link'][( 'location4', 'gate')]) and (state['carrying']['bob']) and (state['useable']['spanner1']) and (state['loose']['nut1']) and (state['loose']['nut2']) and (state['loose']['nut3']) and (state['at']['nut1'] == 'gate') and (state['at']['nut2'] == 'gate') and (state['at']['nut3'] == 'gate')
    return False

def generate_plan():
  global available_actions, available_objects, available_links, current_state
  available_objects = objects.keys()
  available_links = links.keys()
  available_objects = [obj for obj in available_objects if (obj!= 'gate') and (obj!='shed')]
  available_objects = [obj for obj in available_objects if (obj == 'bob') or (obj =='spanner1') or (obj =='spanner2') or (obj =='spanner3') or (obj == 'nut1') or (obj == 'nut2') or (obj == 'nut3') or (obj == 'location1') or (obj == 'location2') or (obj == 'location3') or (obj == 'link1') or (obj == 'link2') or (obj == 'link3') or (obj == 'link4')]
  available_objects = [obj for obj in available_objects if (available_state(obj, current_state))]
  available_objects = [obj for obj in available_objects if (obj!= 'gate') and (obj!='shed')]
  available_objects = [obj for obj in available_objects if (obj == 'bob') or (obj =='spanner1') or (obj =='spanner2') or (obj =='spanner3') or (obj == 'nut1') or (obj == 'nut2') or (obj == 'nut3') or (obj == 'location1') or (obj == 'location2') or (obj == 'location3') or (obj == 'link1') or (obj == 'link2') or (obj == 'link3') or (obj == 'link4')]
  available_objects = [obj for obj in available_objects if (obj!= 'gate') and (obj!='shed')]
  available_objects = [obj for obj in available_objects if (obj == 'bob') or (obj =='spanner1') or (obj =='spanner2') or (obj =='spanner3') or (obj == 'nut1') or (obj == 'nut2') or (obj == 'nut3') or (obj == 'location1') or (obj == 'location2') or (obj == 'location3') or (obj == 'link1') or (obj == 'link2') or (obj == 'link3') or (obj == 'link4')]
  available_objects = [obj for obj in available_objects if (obj!= 'gate') and (obj!='shed')]
  available_objects = [obj for obj in available_objects if (obj == 'bob') or (obj =='spanner1') or (obj =='spanner2') or (obj =='spanner3') or (obj == 'nut1') or (obj == 'nut2') or (obj == 'nut3') or (obj == 'location1') or (obj == 'location2') or (obj == 'location3') or (obj == 'link1') or (obj == 'link2') or (obj == 'link3') or (obj == 'link4')]
  available_objects = [obj for obj in available_objects if (obj!= 'gate') and (obj!='shed')]
  available_objects = [obj for obj in available_objects if (obj == 'bob') or (obj =='spanner1') or (obj =='spanner2') or (obj =='spanner3') or (obj == 'nut1') or (obj == 'nut2') or (obj == 'nut3') or (obj == 'location1') or (obj == 'location2') or (obj == 'location3') or (obj == 'link1') or (obj == 'link2') or (obj == 'link3') or (obj == 'link4')]
  available_objects = [obj for obj in available_objects if (obj!= 'gate') and (obj!='shed')]
  available_objects = [obj for obj in available_objects if (obj == 'bob') or (obj =='spanner1') or (obj =='spanner2') or (obj =='spanner3') or (obj == 'nut1') or (obj == 'nut2') or (obj == 'nut3') or (obj == 'location1') or (obj == 'location2') or (obj == 'location3') or (obj == 'link1') or (obj == 'link2') or (obj == 'link3') or (obj == 'link4')]
  available_objects = [obj for obj in available_objects if (obj!= 'gate') and (obj!='shed')]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s2008090643.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/92)

--- Test 93/200 ---
Problem: spanner-s3-n3-l4-s2013773030
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s2013773030.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/93)

--- Test 94/200 ---
Problem: spanner-s3-n3-l4-s2037530085
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s2037530085.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/94)

--- Test 95/200 ---
Problem: spanner-s3-n3-l4-s2065870853
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s2065870853.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/95)

--- Test 96/200 ---
Problem: spanner-s3-n3-l4-s2143859948
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s2143859948.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/96)

--- Test 97/200 ---
Problem: spanner-s3-n3-l4-s289329007
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Define the domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 289329007 --problem-name spanner-s3-n3-l4-s289329007
(define (problem spanner-s3-n3-l4-s289329007)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location4)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location3)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Define the constraints
constraints = [
    (sometime-before, (tightened, nut2), (tightened, nut3)),
    (at-most-once, (at, bob, shed))
]

# Create a Planner object
planner = Planner(domain, problem, constraints)

# Generate a plan
plan = planner.generate_plan()

# Print the plan
for step in plan:
    print(step)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s289329007.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/97)

--- Test 98/200 ---
Problem: spanner-s3-n3-l4-s309631567
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ```python
(walk shed location1)
(pick spanner1 location1)
(tighten_nut shed spanner1 nut1)
(walk shed)
(pick spanner2 location1)
(tighten_nut shed spanner2 nut2)
(walk gate)
(pick spanner3 gate)
(tighten_nut gate nut3)
```
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s309631567.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/98)

--- Test 99/200 ---
Problem: spanner-s3-n3-l4-s360169873
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: Assassination no problem and lock problem constraints:
 
â€œ : (sometime-before (tightened nut2) (tightened nut3))
 (and (sometime-before (tightened nut2) (tightened nut3))
  (forall (?m - man) (at-most-once (at?m shed)))
)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s360169873.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/99)

--- Test 100/200 ---
Problem: spanner-s3-n3-l4-s411595421
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Symbols, Constraints

# Define the domain and problem symbols
domain = {
    'domain':'spanner',
    'types': ['location', 'locatable','man', 'nut','spanner'],
    'predicates': ['at', 'carrying', 'useable', 'link', 'tightened', 'loose'],
    'constants': ['shed', 'gate', 'location1', 'location2', 'location3', 'location4', 'bob','spanner1','spanner2','spanner3', 'nut1', 'nut2', 'nut3'],
    'constraints': [
        ('sometime-before', [( 'tightened', [ 'nut2' ], [ 'nut3' ])]),
        ('at-most-once', [( 'at', [ 'bob' ], ['shed' ])])
    ]
}

problem = {
    'problem':'spanner-s3-n3-l4-s411595421',
    'objects': {
        'bob':'man',
       'spanner1':'spanner',
       'spanner2':'spanner',
       'spanner3':'spanner',
        'nut1': 'nut',
        'nut2': 'nut',
        'nut3': 'nut',
        'location1': 'location',
        'location2': 'location',
        'location3': 'location',
        'location4': 'location',
       'shed': 'location',
        'gate': 'location'
    },
    'init': [
        ('at', ['bob'], ['shed']),
        ('at', ['spanner1'], ['location3']),
        ('at', ['spanner2'], ['location3']),
        ('at', ['spanner3'], ['location3']),
        ('useable', ['spanner1']),
        ('useable', ['spanner2']),
        ('useable', ['spanner3']),
        ('at', ['nut1'], ['gate']),
        ('loose', ['nut1']),
        ('at', ['nut2'], ['gate']),
        ('loose', ['nut2']),
        ('at', ['nut3'], ['gate']),
        ('loose', ['nut3'])
    ],
    'goal': [
        ('tightened', ['nut1']),
        ('tightened', ['nut2']),
        ('tightened', ['nut3'])
    ]
}

# Create a new planner
planner = Planner(domain, problem)

# Generate a plan
plan = planner.generate_plan()

# Validate the plan
if plan:
    for step in plan:
        # Check if the action preconditions hold
        if not all(planner.action_preconditions(step)):
            print(f"Invalid precondition for action {step['action']} at step {step['step']}")
            break
    else:
        # Check if the plan satisfies all constraints
        if planner.check_constraints(plan):
            print("Plan satisfies all constraints")
        else:
            print("Plan does not satisfy all constraints")
else:
    print("No plan generated")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s411595421.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/100)

--- Test 101/200 ---
Problem: spanner-s3-n3-l4-s462137248
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location2)
(useable spanner1)
(at bob shed)
(loose nut1)
(at nut1 gate)
(at nut2 gate)
(at nut2 gate)
(tightened nut1)
(tightened nut2)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s462137248.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/101)

--- Test 102/200 ---
Problem: spanner-s3-n3-l4-s503961419
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
(walk location1 location2)
(pickup_spanner location2 spanner1 bob)
(walk location2 location3)
(pickup_spanner location3 spanner1 bob)
(walk location3 location4)
(pickup_spanner location4 spanner1 bob)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s503961419.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/102)

--- Test 103/200 ---
Problem: spanner-s3-n3-l4-s50432004
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s3-n3-l4-s50432004"

gen = spanner_generator.spanner_generator(problem_name)
location1, location2, location3, location4, shed, gate, bob, spanner1, spanner2, spanner3, nut1, nut2, nut3 = gen.generate_objects()
init = gen.generate_init()
goal = gen.generate_goal()
constraints = gen.generate_constraints()

gen.generate_plan(init, goal, constraints)

# Validate each step before emitting
valid_steps = []
for step in gen.plan:
    if gen.validate_step(step, gen.state, init, goal, constraints):
        valid_steps.append(step)

# Emit only valid steps
for step in valid_steps:
    action_name = step[0].name
    obj1 = step[1].name
    obj2 = step[2].name
    print(f"{action_name} {obj1} {obj2}")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s50432004.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/103)

--- Test 104/200 ---
Problem: spanner-s3-n3-l4-s594208720
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location4)
(useable spanner2)
(at spanner3 location4)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s594208720.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/104)

--- Test 105/200 ---
Problem: spanner-s3-n3-l4-s596219298
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location2)
(useable spanner1)
(at bob shed)
(loose nut1)
(at nut1 gate)
(at nut2 gate)
(at nut2 gate)
(tightened nut1)
(tightened nut2)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s596219298.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/105)

--- Test 106/200 ---
Problem: spanner-s3-n3-l4-s66307754
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
import (re)

# Produce a valid, grounded, totally-ordered plan for the input below.
# <DOMAIN>
# (domain spanner)
# (:requirements :typing :strips :constraints)
#
# (:types 
#     location locatable - object
#     man nut spanner - locatable   
# )
#
# (:predicates 
#     (at?m - locatable?l - location)
#     (carrying?m - man?s - spanner)
#     (useable?s - spanner)
#     (link?l1 - location?l2 - location)
#     (tightened?n - nut)
#     (loose?n - nut))
#
# (:action walk 
#        :parameters (?start - location?end - location?m - man)
#        :precondition (and (at?m?start) 
#                           (link?start?end))
#        :effect (and (not (at?m?start)) (at?m?end)))
#
# (:action pickup_spanner 
#        :parameters (?l - location?s - spanner?m - man)
#        :precondition (and (at?m?l) 
#                           (at?s?l))
#        :effect (and (not (at?s?l))
#                     (carrying?m?s)))
#
# (:action tighten_nut 
#        :parameters (?l - location?s - spanner?m - man?n - nut)
#        :precondition (and (at?m?l) 
#		      	   (at?n?l)
#			   (carrying?m?s)
#			   (useable?s)
#			   (loose?n))
#        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
# )
# </DOMAIN>

# <PROBLEM>
#  ; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 66307754 --problem-name spanner-s3-n3-l4-s66307754
# (define (problem spanner-s3-n3-l4-s66307754)
#  (:domain spanner)
#  (:objects 
#     bob - man
#     spanner1 spanner2 spanner3 - spanner
#     nut1 nut2 nut3 - nut
#     location1 location2 location3 location4 - location
#     shed gate - location
#    )
#  (:init 
#     (at bob shed)
#     (at spanner1 location2)
#     (useable spanner1)
#     (at spanner2 location2)
#     (useable spanner2)
#     (at spanner3 location4)
#     (useable spanner3)
#     (loose nut1)
#     (at nut1 gate)
#     (loose nut2)
#     (at nut2 gate)
#     (loose nut3)
#     (at nut3 gate)
#     (link shed location1)
#     (link location4 gate)
#     (link location1 location2)
#     (link location2 location3)
#     (link location3 location4)
# )
#  (:goal
#   (and
#    (tightened nut1)
#    (tightened nut2)
#    (tightened nut3)
#   )
# )
# (:constraints
#  (and
#    (sometime-before (tightened nut1) (tightened nut2))
#    (forall (?m - man) (at-most-once (at?m shed)))
#  )
#)
# </PROBLEM>

## Planning Rules
# 1) Only use available symbols:
#    - objects declared under PROBLEM :objects, and
#    - constants declared under DOMAIN/PROBLEM :constants (if any).
#    Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

# 2) Constraints:
#    - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
#    - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

# 3) Plan form:
#    - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

# 4) Internal validation before emitting (do not include reasoning in the output):
#    - At each step, all action preconditions hold in the current state.
#    - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
#    - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
# - Return **ONLY** the plan steps, one per line.
# - Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
# - Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
# - No numbering, timestamps, costs, comments, headers, code fences, or extra text.
# - No blank lines at the start or end; no trailing spaces; use a single space between tokens.
# - If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
# - If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
# Bad:
# - Plan:
# - Here is the plan:
# - (move a b)  (two actions on one line)
# - (move a) extra

# Good:
# (move a b)
# (pick a c)
# (drop a d)

## Produce a valid, grounded, totally-ordered plan for the input below.
objects = (
    ("bob", "man")
    ("spanner1", "spanner")
    ("spanner2", "spanner")
    ("spanner3", "spanner")
    ("nut1", "nut")
    ("nut2", "nut")
    ("nut3", "nut")
    ("location1", "location")
    ("location2", "location")
    ("location3", "location")
    ("location4", "location")
    ("shed", "location")
    ("gate", "location")
)
constraints = (
    # No constraints provided
)

actions = (
    ("walk", "action")
    ("pickup_spanner", "action")
    ("tighten_nut", "action")
)

predicates = (
    ("at", "predicate")
    ("carrying", "predicate")
    ("useable", "predicate")
    ("link", "predicate")
    ("tightened", "predicate")
    ("loose", "predicate")
)

domain_rules = (
    # (domain spanner)
    (#requirements :typing :strips :constraints),      

    (#types 
     (location locatable - object)
     (man nut spanner - locatable   
     ),      

    (#predicates 
     (at?m - locatable?l - location)
     (carrying?m - man?s - spanner)
     (useable?s - spanner)
     (link?l1 - location?l2 - location)
     (tightened?n - nut)
     (loose?n - nut)
     ),      

    (#action walk 
     (parameters (?start - location?end - location?m - man)
     (precondition (and (at?m?start) 
                           (link?start?end)))
     (effect (and (not (at?m?start)) (at?m?end)))
     ),      

    (#action pickup_spanner 
     (parameters (?l - location?s - spanner?m - man)
     (precondition (and (at?m?l) 
                           (at?s?l)))
     (effect (and (not (at?s?l))
                   (carrying?m?s)))
     ),      

    (#action tighten_nut 
     (parameters (?l - location?s - spanner?m - man?n - nut)
     (precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
     (effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
     )
    )

objects = tuple(objects)
constraints = tuple(constraints)
actions = tuple(actions)
predicates = tuple(predicates)
domain_rules = tuple(domain_rules)

# Produce a valid, grounded, totally-ordered plan for the input below.
available_objects = objects
constraints = constraints
available_actions = [action_ for action_, action in zip(actions, domain_rules) if action_ == action]
plan = []

def validate_plan(available_objects, available_actions, objects, constraints, predicates, domain_rules, plan):
    objects_used = set()
    actions_used = set()

    for obj in plan:
        if obj in objects_used:
            return False
        objects_used.add(obj)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s66307754.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/106)

--- Test 107/200 ---
Problem: spanner-s3-n3-l4-s729399419
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location3)
(useable spanner1)
(at bob gate)
(loose nut1)
(at nut1 gate)
(at nut2 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s729399419.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/107)

--- Test 108/200 ---
Problem: spanner-s3-n3-l4-s741455592
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
 :parameters (?start - location?end - location?m - man)
 :precondition (and (at?m?start) 
		      	   (link?start?end))
 :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
 :parameters (?l - location?s - spanner?m - man)
 :precondition (and (at?m?l) 
		      	   (at?s?l))
 :effect (and (not (at?s?l))
                  (carrying?m?s)))

#:action tighten_nut 
 :parameters (?l - location?s - spanner?m - man?n - nut)
 :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
 :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(at spanner1 location2)
(carrying bob)
(useable spanner1)
(at spanner2 location4)
(useable spanner2)
(at spanner3 location2)
(carrying spanner3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s741455592.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/108)

--- Test 109/200 ---
Problem: spanner-s3-n3-l4-s746303720
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
from (sys) import stdin, stdout, stderr; submit = (stdin is stdin); print_to_file = (open('output.txt', 'w') is None); extra_stderr = (stderr is not None)

def (input):
    return next(stdin.readline(), None)

def (input):
    return input()

def (input):
    return input().strip()

def (input):
    return input().split()

def (input):
    return input().strip().split()

def (input):
    return list(map(input, input()))

def (input, def_val=0, typ=int):
    return typ(input()) if typ!= int else input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return input() if input else def_val

def (input):
    return input() + input()

def (input, def_val=0):
    return input() + str(def_val)

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
    return input() if input else def_val

def (input, def_val=""):
    return def_val + input()

def (input):
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s746303720.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/109)

--- Test 110/200 ---
Problem: spanner-s3-n3-l4-s832689597
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
import (re)

# Produce the final output
problem_name = "spanner-s3-n3-l4-s832689597"
domain_problem = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (not (carrying?m?s))))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (not (carrying?m?s))
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 832689597 --problem-name spanner-s3-n3-l4-s832689597
(define (problem spanner-s3-n3-l4-s832689597)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location4)
    (useable spanner1)
    (at spanner2 location2)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

# Open the problem file for writing
with open(f"spanner-s3-n3-l4-s832689597.py", "w") as problem_file:
    # Write the domain
    problem_file.write("<DOMAIN>\n")
    problem_file.write("(define (domain spanner)\n")
    problem_file.write("  (:requirements :typing :strips :constraints))\n")
    problem_file.write("  (:types \n")
    problem_file.write("    location locatable - object\n")
    problem_file.write("    man nut spanner - locatable\n")
    problem_file.write("  ))\n")
    problem_file.write("  (:predicates \n")
    problem_file.write("    (at?m - locatable?l - location)\n")
    problem_file.write("    (carrying?m - man?s - spanner)\n")
    problem_file.write("    (useable?s - spanner)\n")
    problem_file.write("    (link?l1 - location?l2 - location)\n")
    problem_file.write("    (tightened?n - nut)\n")
    problem_file.write("    (loose?n - nut))\n")
    problem_file.write("  :\n")
    problem_file.write("    (at-most-once (at?m shed))\n")
    problem_file.write("  )\n")
    problem_file.write("(:action walk \n")
    problem_file.write("  (:parameters (?start - location?end - location?m - man))\n")
    problem_file.write("  (:precondition (and (at?m?start) (link?start?end)))\n")
    problem_file.write("  (:effect (and (not (at?m?start)) (at?m?end))))\n")
    problem_file.write(")\n")
    problem_file.write("(:action pickup_spanner \n")
    problem_file.write("  (:parameters (?l - location?s - spanner?m - man))\n")
    problem_file.write("  (:precondition (and (at?m?l) (at?s?l)))\n")
    problem_file.write("  (:effect (and (not (at?s?l)) (not (carrying?m?s))))\n")
    problem_file.write(")\n")
    problem_file.write("(:action tighten_nut \n")
    problem_file.write("  (:parameters (?l - location?s - spanner?m - man?n - nut))\n")
    problem_file.write("  (:precondition (and (at?m?l) (at?n?l) (not (carrying?m?s)) (useable?s) (loose?n)))\n")
    problem_file.write("  (:effect (and (not (loose?n)) (not (useable?s)) (tightened?n))))\n")
    problem_file.write(")\n")
    problem_file.write("</DOMAIN>\n")

    # Write the problem
    problem_file.write("<PROBLEM>\n")
    problem_file.write("  ; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 832689597 --problem-name spanner-s3-n3-l4-s832689597\n")
    problem_file.write("(define (problem spanner-s3-n3-l4-s832689597)\n")
    problem_file.write("  (:domain spanner)\n")
    problem_file.write("  (:objects \n")
    problem_file.write("     bob - man\n")
    problem_file.write("     spanner1 spanner2 spanner3 - spanner\n")
    problem_file.write("
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s832689597.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/110)

--- Test 111/200 ---
Problem: spanner-s3-n3-l4-s87291057
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
import (re)

# Produce the final output
problem_name = "spanner-s3-n3-l4-s87291057"
domain_problem = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (not (carrying?m?s))))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (not (carrying?m?s))
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 87291057 --problem-name spanner-s3-n3-l4-s87291057
(define (problem spanner-s3-n3-l4-s87291057)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location4)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

# Open the problem file for writing
with open(f"spanner-s3-n3-l4-s87291057.py", "w") as problem_file:
    # Write the domain
    problem_file.write(f"""
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (not (carrying?m?s))))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (not (carrying?m?s))
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 3 3 4 --seed 87291057 --problem-name spanner-s3-n3-l4-s87291057
(define (problem spanner-s3-n3-l4-s87291057)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location4)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
)
)
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

# Write the initial state
problem_file.write("""
(:init 
)
""")
# Write the constraints (if any)
if "constraints" in dir(problem_file):
    problem_file.write("""
(:constraints
)
""")

# Write the goal
problem
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s87291057.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/111)

--- Test 112/200 ---
Problem: spanner-s3-n3-l4-s901003479
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [/code]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s3-n3-l4-s901003479.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/112)

--- Test 113/200 ---
Problem: spanner-s4-n3-l4-s1000143947
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ).</PROBLEM>

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
                           (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 4 --seed 1000143947 --problem-name spanner-s4-n3-l4-s1000143947
(define (problem spanner-s4-n3-l4-s1000143947)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location3)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location2)
    (useable spanner3)
    (at spanner4 location3)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

```python
#: No code needed. Produce grounded, sequential PDDL2 plan steps directly below.
@
walk(bob location1 location3)
(pick spanner1 location3 shed)
walk(spanner1 shed location2)
(tighten_nut nut1 location3 gate)
walk(spanner1 location2 gate)
(tighten_nut nut2 location1 gate)
@
```

Note: No validation code is required here; the planner must ensure that every step satisfies the current state and constraints.
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1000143947.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/113)

--- Test 114/200 ---
Problem: spanner-s4-n3-l4-s1036506237
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
(walk location4 gate)
(pickup_spanner location4 spanner4 bob)
(tighten_nut location4 spanner4 bob nut1)
(tighten_nut location4 spanner4 bob nut2)
(tighten_nut location4 spanner4 bob nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1036506237.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/114)

--- Test 115/200 ---
Problem: spanner-s4-n3-l4-s1040745252
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 gate)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1040745252.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/115)

--- Test 116/200 ---
Problem: spanner-s4-n3-l4-s1042138051
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location2)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 gate)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1042138051.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/116)

--- Test 117/200 ---
Problem: spanner-s4-n3-l4-s1102775277
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location4)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(walk shed location1 bob)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
(walk location2 bob)
(pickup_spanner location2 spanner1 bob)
(tighten_nut location2 spanner1 bob nut1)
(tighten_nut location2 spanner1 bob nut2)
(walk location3 bob)
(pickup_spanner location3 spanner1 bob)
(tighten_nut location3 spanner1 bob nut1)
(tighten_nut location3 spanner1 bob nut2)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1102775277.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/117)

--- Test 118/200 ---
Problem: spanner-s4-n3-l4-s1120841919
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
 :parameters (?start - location?end - location?m - man)
 :precondition (and (at?m?start) 
                     (link?start?end))
 :effect (and (not (at?m?start)) (at?m?end))

#:action pickup_spanner 
 :parameters (?l - location?s - spanner?m - man)
 :precondition (and (at?m?l) 
                      (at?s?l))
 :effect (and (not (at?s?l))
                (carrying?m?s))

#:action tighten_nut 
 :parameters (?l - location?s - spanner?m - man?n - nut)
 :precondition (and (at?m?l) 
                       (at?n?l)
                       (carrying?m?s)
                       (useable?s)
                       (loose?n))
 :effect (and (not (loose?n))(not (useable?s)) (tightened?n))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1120841919.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/118)

--- Test 119/200 ---
Problem: spanner-s4-n3-l4-s116834475
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Symbols, Constraints

domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 4 --seed 116834475 --problem-name spanner-s4-n3-l4-s116834475
(define (problem spanner-s4-n3-l4-s116834475)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location2)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (at spanner4 location2)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

domain.constraints = [
    (Constraints.from_string(
        """
        (sometime-before (tightened nut1) (tightened nut2))
        """,
        Symbols(
            (domain), (problem)
        )
    )),
    (Constraints.from_string(
        """
        (forall (?m - man) (at-most-once (at?m shed)))
        """,
        Symbols(
            (domain), (problem)
        )
    ))
]

problem.objects = [
    Symbols(
        (domain),
        problem
    ),
    ("bob", Symbols(domain.objects, problem.objects, locatable, man)),
    ("spanner1", Symbols(domain.objects, problem.objects, spanner)),
    ("spanner2", Symbols(domain.objects, problem.objects, spanner)),
    ("spanner3", Symbols(domain.objects, problem.objects, spanner)),
    ("spanner4", Symbols(domain.objects, problem.objects, spanner)),
    ("nut1", Symbols(domain.objects, problem.objects, nut)),
    ("nut2", Symbols(domain.objects, problem.objects, nut)),
    ("nut3", Symbols(domain.objects, problem.objects, nut)),
    ("location1", Symbols(domain.objects, problem.objects, location)),
    ("location2", Symbols(domain.objects, problem.objects, location)),
    ("location3", Symbols(domain.objects, problem.objects, location)),
    ("location4", Symbols(domain.objects, problem.objects, location)),
    ("shed", Symbols(domain.objects, problem.objects, location)),
    ("gate", Symbols(domain.objects, problem.objects, location)),
]

problem.init = [
    (Constraints.from_tuple(
        """
        (at bob shed)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbols(domain.objects, problem.objects, locatable, man), "bob", Symbols(domain.objects, problem.objects, location, shed)] + [(Symbol(domain.objects, problem.objects, predicate), value) for predicate, value in [(domain.preds[locatable], shed), (domain.preds[at], bob), (domain.preds[at], shed)]]
    )),
    (Constraints.from_tuple(
        """
        (at spanner1 location2)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbols(domain.objects, problem.objects, locatable, spanner), "spanner1", Symbols(domain.objects, problem.objects, location, location2)] + [(Symbol(domain.objects, problem.objects, predicate), value) for predicate, value in [(domain.preds[at], spanner1), (domain.preds[carrying], spanner1), (domain.preds[at], location2)]]
    )),
    (Constraints.from_tuple(
        """
        (at spanner2 location1)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbols(domain.objects, problem.objects, locatable, spanner), "spanner2", Symbols(domain.objects, problem.objects, location, location1)] + [(Symbol(domain.objects, problem.objects, predicate), value) for predicate, value in [(domain.preds[at], spanner2), (domain.preds[carrying], spanner2), (domain.preds[at], location1)]]
    )),
    (Constraints.from_tuple(
        """
        (at spanner3 location4)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbols(domain.objects, problem.objects, locatable, spanner), "spanner3", Symbols(domain.objects, problem.objects, location, location4)] + [(Symbol(domain.objects, problem.objects, predicate), value) for predicate, value in [(domain.preds[at], spanner3), (domain.preds[carrying], spanner3), (domain.preds[at], location4)]]
    )),
    (Constraints.from_tuple(
        """
        (at spanner4 location2)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbols(domain.objects, problem.objects, locatable, spanner), "spanner4", Symbols(domain.objects, problem.objects, location, location2)] + [(Symbol(domain.objects, problem.objects, predicate), value) for predicate, value in [(domain.preds[at], spanner4), (domain.preds[carrying], spanner4), (domain.preds[at], location2)]]
    )),
    (Constraints.from_tuple(
        """
        (at nut1 gate)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbols(domain.objects, problem.objects, locatable, nut), "nut1", Symbols(domain.objects, problem.objects, location, gate)] + [(Symbol(domain.objects, problem.objects, predicate), value) for predicate, value in [(domain.preds[at], nut1), (domain.preds[carrying], nut1), (domain.preds[at], gate)]]
    )),
    (Constraints.from_tuple(
        """
        (at nut2 gate)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbols(domain.objects, problem.objects, locatable, nut), "nut2", Symbols(domain.objects, problem.objects, location, gate)] + [(Symbol(domain.objects, problem.objects, predicate), value) for predicate, value in [(domain.preds[at], nut2), (domain.preds[carrying], nut2), (domain.preds[at], gate)]]
    )),
    (Constraints.from_tuple(
        """
        (at nut3 gate)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbols(domain.objects, problem.objects, locatable, nut), "nut3", Symbols(domain.objects, problem.objects, location, gate)] + [(Symbol(domain.objects, problem.objects, predicate), value) for predicate, value in [(domain.preds[at], nut3), (domain.preds[carrying], nut3), (domain.preds[at], gate)]]
    )),
    (Constraints.from_tuple(
        """
        (link shed location1)
        """,
        Symbols(
            (domain), (problem)
        ),
        [(Symbol(domain.objects, predicate), value) for predicate, value in [(domain.p
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s116834475.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/119)

--- Test 120/200 ---
Problem: spanner-s4-n3-l4-s1224833953
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [(pickup_spanner 
        (at bob shed)
        (at spanner1 location3)
        (at bob shed)
        (at spanner1 location3)
        (at bob location1)
        (at spanner1 location3))
 
 (walk 
  (at bob shed)
  (at spanner1 location3)
  (at bob location1)
  (at spanner1 location3)
  (at bob location2)
  (at spanner1 location3))
 
 (pickup_spanner 
  (at bob location1)
  (at spanner1 location3)
  (at bob location2)
  (at spanner1 location3)
  (at bob location3)
  (at spanner1 location3))
 
 (tighten_nut 
  (at bob location3)
  (at spanner1 location3)
  (at bob location3)
  (at spanner1 location3)
  (at nut1 gate)
  (at spanner1 location3)
  (at nut1 gate)
  (at spanner1 location3)
  (at nut1 gate)
  (at spanner1 location3)
  (at nut1 gate)
  (at nut1 gate)
  (at spanner1 location3)
  (at nut1 gate)
  (at nut2 gate)
  (at spanner1 location3)
  (at nut2 gate)
  (at nut2 gate)
  (at spanner1 location3)
  (at nut2 gate)
  (at nut2 gate)
  (at spanner1 location3)
  (at nut2 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (at nut3 gate)
  (at spanner1 location3)
  (at nut3 gate)
  (
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1224833953.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/120)

--- Test 121/200 ---
Problem: spanner-s4-n3-l4-s1259814300
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: (#) <spanner-s4-n3-l4-s1259814300>
(:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
(:init 
    (at bob shed)
    (at spanner1 location1)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location1)
    (useable spanner3)
    (at spanner4 location1)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
(:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

(); no constraints in this problem

(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
                           (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(available-action (at?obj location1))
  (let ((obj (if (man?obj) 'bob (if (spanner?obj) spanner1 (if (nut?obj) nut1 nut2)))))
    (and (at obj location1) (not (carrying obj anything)) (not (loose obj)) (useable spanner1)))
  ) =available-near-nut-1
  (not (at bob shed))
  (at bob shed) =at-near-shed-1
)(available-action (at?obj gate))
  (let ((obj (if (man?obj) 'bob (if (spanner?obj) spanner1 (if (nut?obj) nut1 nut2)))))
    (and (at obj gate) (not (carrying obj anything)) (not (loose obj)) (useable spanner1)))
  ) =available-near-gate-1
)(available-nut-nut2)
  (not (at bob shed))
  (at bob shed) =at-near-shed-1
)(tighten-nut-1)
  (at bob gate)
  (and (at bob) (at gate) 
       (at nut2 gate) (tightened nut1) (useable spanner1) (loose nut2))
  ) =tighten-nut-near-nut2-1
  (not (at nut2 gate))
  (at nut2 gate) (tightened nut1) (useable spanner1) (loose nut2) =at-near-nut2-1
)(tighten-nut-2)
  (at bob gate)
  (and (at bob) (at gate) 
       (at nut1 gate) (tightened nut2) (useable spanner1) (loose nut1))
  ) =tighten-nut-near-nut1-1
  (not (at nut1 gate))
  (at nut1 gate) (tightened nut2) (useable spanner1) (loose nut1) =at-near-nut1-1
)(available-spanner-spanner4)
  (at spanner4 location1)
  (and (at spanner4 location1) (not (carrying spanner4 anything)) (useable spanner4))
  ) =available-spanner-spanner4-1
)(available-spanner-spanner3)
  (at spanner3 location1)
  (and (at spanner3 location1) (not (carrying spanner3 anything)) (useable spanner3))
  ) =available-spanner-spanner3-1
)(available-spanner-spanner2)
  (at spanner2 location3)
  (and (at spanner2 location3) (not (carrying spanner2 anything)) (useable spanner2))
  ) =available-spanner-spanner2-1
)(walk-near-spanner1-nut2-1)
  (at spanner1 location1)
  (and (at spanner1 location1) (at nut2 gate) (useable spanner1) (loose nut2))
  ) =walk-near-spanner1-nut2-1
  (at spanner1 location1)
  (and (at spanner1 location1) (at nut2 gate) (useable spanner1) (loose nut2)) =at-near-spanner1-nut2-1
)(walk-near-spanner1-nut1-1)
  (at spanner1 location1)
  (and (at spanner1 location1) (at nut1 gate) (useable spanner1) (loose nut1))
  ) =walk-near-spanner1-nut1-1
  (at spanner1 location1)
  (and (at spanner1 location1) (at nut1 gate) (useable spanner1) (loose nut1)) =at-near-spanner1-nut1-1
)(tighten-nut-3)
  (at spanner1 gate)
  (and (at spanner1 gate) (at nut3 gate) (useable spanner1) (loose nut3))
  ) =tighten-nut-near-nut3-1
  (not (at nut3 gate))
  (at spanner1 gate) (at nut3 gate) (useable spanner1) (loose nut3) =at-near-nut3-1
)(tighten-nut-3)
  (at spanner3 gate)
  (and (at spanner3 gate) (at nut3 gate) (useable spanner3) (loose nut3))
  ) =tighten-nut-near-nut3-1
  (not (at nut3 gate))
  (at spanner3 gate) (at nut3 gate) (useable spanner3) (loose nut3) =at-near-nut3-1
)(available-spanner-spanner1)
  (at spanner1 gate)
  (and (at spanner1 gate) (not (carrying spanner1 anything)) (useable spanner1))
  ) =available-spanner-spanner1-1
)(available-spanner-spanner3)
  (at spanner3 gate)
  (and (at spanner3 gate) (not (carrying spanner3 anything)) (useable spanner3))
  ) =available-spanner-spanner3-1
)(available-spanner-spanner2)
  (at spanner2 gate)
  (and (at spanner2 gate) (not (carrying spanner2 anything)) (useable spanner2))
  ) =available-spanner-spanner2-1
)(walk-near-spanner2-nut2-1)
  (at spanner2 location3)
  (and (at spanner2 location3) (at nut2 gate) (useable spanner2) (loose nut2))
  ) =walk-near-spanner2-nut2-1
  (at spanner2 location3)
  (and (at spanner2 location3) (at nut2 gate) (useable spanner2) (loose nut2)) =at-near-spanner2-nut2-1
)(walk-near-spanner2-nut1-1)
  (at spanner2 location3)
  (and (at spanner2 location3) (at nut1 gate) (useable spanner2) (loose nut1))
  ) =walk-near-spanner2-nut1-1
  (at spanner2 location3)
  (and (at spanner2 location3) (at nut1 gate) (use
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1259814300.soln
âœ— Invalid solution: Validation failed: Type-checking walk
...action passes type checking.
Type-checking pickup_spanner
...action passes type checking.
Type-checking tighten_nut
...action passes type checking.
Checking plan: /tmp/2317655.1.gpu/tmpgyax4sys.soln
#Bad plan description!


Failed plans:
 /tmp/2317655.1.gpu/tmpgyax4sys.soln 

Current success rate: 0.0% (0/121)

--- Test 122/200 ---
Problem: spanner-s4-n3-l4-s1370976012
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                      (at?s?l))
#:effect (and (not (at?s?l))
               (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location3)
(useable spanner2)
(at spanner3 location3)
(useable spanner3)
(at spanner4 location4)
(useable spanner4)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1370976012.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/122)

--- Test 123/200 ---
Problem: spanner-s4-n3-l4-s1519737071
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location4)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(at bob shed)
(tightened nut1)
(tightened nut2)
(tightened nut3)
 
(no-nut-nut)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1519737071.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/123)

--- Test 124/200 ---
Problem: spanner-s4-n3-l4-s1583382869
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location4)
(useable spanner1)
(at bob shed)
(at spanner2 location1)
(useable spanner2)
(at spanner3 location4)
(useable spanner3)
(at spanner4 location1)
(useable spanner4)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1583382869.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/124)

--- Test 125/200 ---
Problem: spanner-s4-n3-l4-s162145046
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import gi

gi.require_version('PDDL3', '1.0')
gi.require_version('PDDL2', '2.0')
from PDDL3 import *
from PDDL2 import *

problem = Problem(name='spanner-s4-n3-l4-s162145046')
problem.domain = Domain(name='spanner')
problem.objects = ['bob','spanner1','spanner2','spanner3','spanner4', 'nut1', 'nut2', 'nut3', 'location1', 'location2', 'location3', 'location4','shed', 'gate']
problem.constants = ['bob', 'location1', 'location2', 'location3', 'location4','shed', 'gate','spanner1','spanner2','spanner3','spanner4', 'nut1', 'nut2', 'nut3']
problem.types = ['man','spanner', 'nut', 'location', 'gate']
problem.preds = [
    ('at', ['man', 'location'], 3), ('under', ['spanner', 'nut'], 2), 
    ('carryable', ['man','spanner'], 3), ('movable', ['nut','spanner'], 2), 
    ('at', ['nut', 'gate'], 3), ('useable', ['spanner'], 3), 
    ('link', ['location', 'location'], 2), ('tightened', ['nut'], 2), 
    ('under', ['spanner', 'nut'], 2), ('loose', ['nut'], 3), 
    ('under', ['spanner','spanner'], 2), ('at', ['man','shed'], 3), 
    ('under', [], 0), ('tightened', [], 0), ('tightened', ['nut1'], 0), 
    ('tightened', ['nut2'], 0), ('tightened', ['nut3'], 0), 
    ('at-most-once', ['man'], 0), ('sometime-before', ['nut1', 'nut2'], 0)
    ]

problem.action_names = ['walk', 'pickup_spanner', 'tighten_nut']
problem.action_args = [
    (['man', 'location','spanner'], 3, ['man', 'location','spanner'], 3),
    (['man', 'location','spanner', 'nut','spanner'], 4, [], 0),
    (['man', 'location','spanner', 'nut','spanner', 'nut'], 4, [], 0)
]

solution = Plan()

goal = AndConstraint(
    OrConstraint(
        ExistsConstraint(['man'], ['at', ['man','shed'], 0]),
        ExistsConstraint([], ['under', [], 0])
    ),
    ImpliesConstraint(
        AndConstraint(
            ExistsConstraint(['nut'], ['at', ['nut', 'gate'], 0]),
            AndConstraint(
                ExistsConstraint(['spanner'], ['at', ['spanner1', 'location2'], 0]),
                ExistsConstraint(['spanner'], ['at', ['spanner2', 'location3'], 0]),
                ExistsConstraint(['spanner'], ['at', ['spanner3', 'location4'], 0])
            )
        ),
        AndConstraint(
            ExistsConstraint(['nut'], ['tightened', ['nut1'], 0]),
            ExistsConstraint(['nut'], ['tightened', ['nut2'], 0]),
            ExistsConstraint(['nut'], ['tightened', ['nut3'], 0])
        )
    )
)

for action in problem.action_names:
    action_obj = Action(name=action, args=problem.action_args[action])
    action_obj.precondition = goal
    solution.append(action_obj)

print(solution)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s162145046.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/125)

--- Test 126/200 ---
Problem: spanner-s4-n3-l4-s1622992383
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: # Your code here
#
# Before writing the plan, do internal validation:
#   At each step, all action preconditions hold in the current state.
#   Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
#   If constraints exist in PROBLEM, ensure the plan satisfies all of them

at_bob_shed = True
at_spanner1_location2 = True
useable_spanner1 = True
at_spanner2_location1 = True
useable_spanner2 = True
at_spanner3_location4 = True
useable_spanner3 = True
at_spanner4_location2 = True
useable_spanner4 = True
loose_nut1 = True
at_nut1_gate = True
loose_nut2 = True
at_nut2_gate = True
loose_nut3 = True
at_nut3_gate = True

link_shed_location1 = True
link_location4_gate = True
link_location1_location2 = True
link_location2_location3 = True
link_location3_location4 = True

tightened_nut1 = False
tightened_nut2 = False
tightened_nut3 = False

for n in [nut1, nut2, nut3]:
    if loose_nut1 == loose_nut2 == loose_nut3:
        if n == nut1:
            at_nut1_gate = False
        if n == nut2:
            at_nut2_gate = False
        if n == nut3:
            at_nut3_gate = False

for m in [bob]:
    if at_bob_shed:
        at_bob_shed = False
        for l in [location1, location2, location3, location4]:
            if link_shed_location1:
                if l == location1:
                    link_shed_location1 = False
                    at_spanner1_location2 = True
                if l == location2:
                    link_location1_location2 = True
                    at_spanner2_location1 = True
                if l == location3:
                    link_location2_location3 = True
                    at_spanner3_location2 = True
                if l == location4:
                    link_location3_location4 = True
                    at_spanner4_location3 = True
            if link_l1_l2:
                if l == location1:
                    link_l1_l2 = False
                    at_spanner1_location2 = True
                if l == location2:
                    link_location1_location2 = True
                    at_spanner2_location1 = True
                    at_spanner1_location2 = False
            if link_l2_l3:
                if l == location2:
                    link_l2_l3 = False
                    at_spanner2_location1 = False
                    at_spanner3_location2 = True
                if l == location3:
                    link_location2_location3 = True
                    at_spanner3_location2 = True
                    at_spanner2_location1 = False
            if link_l3_l4:
                if l == location3:
                    link_l3_l4 = False
                    at_spanner3_location2 = False
                    at_spanner4_location3 = True
                if l == location4:
                    link_location3_location4 = True
                    at_spanner4_location3 = True
                    at_spanner3_location2 = False
            if link_l4_l1:
                if l == location4:
                    link_l4_l1 = False
                    at_spanner4_location3 = False
                    at_spanner1_location2 = True
                if l == location1:
                    link_location4_gate = True
                    at_spanner1_location2 = True
                    at_spanner4_location3 = False

if link_shed_location1 or link_location4_gate:
    print("NO-PLAN")
else:
    if not useable_spanner1 or not useable_spanner2 or not useable_spanner3 or not useable_spanner4:
        print("NO-PLAN")
    else:
        if not tightened_nut1 or not tightened_nut2 or not tightened_nut3:
            print("NO-PLAN")
        else:
            print("No validation code here since all constraints are satisfied")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1622992383.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/126)

--- Test 127/200 ---
Problem: spanner-s4-n3-l4-s1636925766
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
(walk location1 location2)
(pickup_spanner location2 spanner2 bob)
(tighten_nut location2 spanner2 bob nut1)
(tighten_nut location2 spanner2 bob nut2)
(tighten_nut location2 spanner2 bob nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1636925766.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/127)

--- Test 128/200 ---
Problem: spanner-s4-n3-l4-s1684117974
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Define the domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
problem = """
<PROBLEM>
 ; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 4 --seed 1684117974 --problem-name spanner-s4-n3-l4-s1684117974
(define (problem spanner-s4-n3-l4-s1684117974)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location3)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location2)
    (useable spanner3)
    (at spanner4 location2)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Define the planner and constraints
planner = Planner()
constraints = Constraints()

# Create the problem and domain objects
problem_obj = problem.create_problem_object()
domain_obj = domain.create_domain_object()

# Add objects to the problem
problem_obj.add_object("bob", "man")
problem_obj.add_object("spanner1", "spanner")
problem_obj.add_object("spanner2", "spanner")
problem_obj.add_object("spanner3", "spanner")
problem_obj.add_object("spanner4", "spanner")
problem_obj.add_object("nut1", "nut")
problem_obj.add_object("nut2", "nut")
problem_obj.add_object("nut3", "nut")
problem_obj.add_object("location1", "location")
problem_obj.add_object("location2", "location")
problem_obj.add_object("location3", "location")
problem_obj.add_object("location4", "location")
problem_obj.add_object("shed", "location")
problem_obj.add_object("gate", "location")

# Add constraints to the problem
constraints.add_constraint(problem_obj, "(sometime-before (tightened nut2) (tightened nut3))")
constraints.add_constraint(problem_obj, "(forall (man?m) (at-most-once (at?m shed))))")

# Create the plan
plan = planner.create_plan(domain_obj, problem_obj, constraints)

# Print the plan
for step in plan:
    print(step)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1684117974.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/128)

--- Test 129/200 ---
Problem: spanner-s4-n3-l4-s1751937887
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location4 gate bob shed) 
#:precondition (and (at bob gate) (link gate shed)) 
#:effect (and (not (at bob gate)) (at bob shed)))

#:action pickup_spanner 
#:parameters (location1 location3 gate spanner1 spanner2 bob) 
#:precondition (and (at bob shed) (at spanner1 location3) (at bob location1)) 
#:effect (and (not (at spanner1 location3)) (at spanner1 gate)))

#:action pickup_spanner 
#:parameters (location1 location4 gate spanner3 spanner4 bob) 
#:precondition (and (at bob shed) (at spanner3 location4) (at bob location1)) 
#:effect (and (not (at spanner3 location4)) (at spanner3 gate)))

#:action tighten_nut 
#:parameters (location1 gate spanner1 spanner2 bob nut1 nut2) 
#:precondition (and (at bob gate) (at spanner1 gate) (at spanner2 gate) (at bob shed) (at nut1 shed) (at nut2 shed)) 
#:effect (and (not (loose nut1)) (not (useable spanner1))) (and (not (loose nut2)) (not (useable spanner2))) (and (not (loose nut3)) (not (useable spanner3))) (tightened nut1) (tightened nut2) (tightened nut3)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1751937887.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/129)

--- Test 130/200 ---
Problem: spanner-s4-n3-l4-s1780492697
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(nothing)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1780492697.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/130)

--- Test 131/200 ---
Problem: spanner-s4-n3-l4-s1824187062
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location3)
(useable spanner2)
(at spanner3 location4)
(useable spanner3)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
(walk location4 gate)
(pickup_spanner location4 spanner4 bob)
(tighten_nut location4 spanner4 bob nut1)
(tighten_nut location4 spanner4 bob nut2)
(tighten_nut location4 spanner4 bob nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1824187062.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/131)

--- Test 132/200 ---
Problem: spanner-s4-n3-l4-s1841383707
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ]]>system

(<pickup_spanner "location1" "spanner1" "bob"})
(<walk "location1" "location2" "bob"})
(<pickup_spanner "location2" "spanner2" "bob"})
(<walk "location2" "location3" "bob"})
(<pickup_spanner "location3" "spanner3" "bob"})
(<walk "location3" "location4" "bob"})
(<pickup_spanner "location4" "spanner4" "bob"})
(<walk "location4" "gate" "bob"})
(<tighten_nut "gate" "nut1" "bob"))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1841383707.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/132)

--- Test 133/200 ---
Problem: spanner-s4-n3-l4-s1887471672
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: (<pickup_spanner "location1" "spanner1" "bob"))
(<pickup_spanner "location1" "spanner2" "bob"))
(<pickup_spanner "location1" "spanner3" "bob"))
(<pickup_spanner "location1" "spanner4" "bob"))
(<walk "location1" "location2" "bob"))
(<tighten_nut "location2" "spanner1" "bob" "nut1"))
(<tighten_nut "location2" "spanner2" "bob" "nut2"))
(<tighten_nut "location2" "spanner3" "bob" "nut3"))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1887471672.soln
âœ— Invalid solution: Validation failed: Type-checking walk
...action passes type checking.
Type-checking pickup_spanner
...action passes type checking.
Type-checking tighten_nut
...action passes type checking.
Checking plan: /tmp/2317655.1.gpu/tmp8arf52mh.soln
Bad plan description!


Failed plans:
 /tmp/2317655.1.gpu/tmp8arf52mh.soln 

Current success rate: 0.0% (0/133)

--- Test 134/200 ---
Problem: spanner-s4-n3-l4-s1919649554
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob gate)
(loose nut1)
(at nut1 gate)
(at nut2 gate)
(at nut2 location1)
(useable spanner2)
(at spanner2 location1)
(useable spanner3)
(at spanner3 location3)
(tightened nut1)
(tightened nut2)
(tightened nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1919649554.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/134)

--- Test 135/200 ---
Problem: spanner-s4-n3-l4-s1931076887
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
 :parameters (?start - location?end - location?m - man)
 :precondition (and (at?m?start) 
                     (link?start?end))
 :effect (and (not (at?m?start)) (at?m?end))

#:action pickup_spanner 
 :parameters (?l - location?s - spanner?m - man)
 :precondition (and (at?m?l) 
                     (at?s?l))
 :effect (and (not (at?s?l))
               (carrying?m?s))

#:action tighten_nut 
 :parameters (?l - location?s - spanner?m - man?n - nut)
 :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
 :effect (and (not (loose?n))(not (useable?s)) (tightened?n))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s1931076887.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/135)

--- Test 136/200 ---
Problem: spanner-s4-n3-l4-s2042158317
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location4)
(useable spanner1)
(at bob shed)
(loose nut1)
(at nut1 gate)
(at nut2 gate)
(at nut2 gate)
(tightened nut1)
(tightened nut2)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s2042158317.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/136)

--- Test 137/200 ---
Problem: spanner-s4-n3-l4-s2064453291
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (location1 location2 location3 location4 bob shed spanner1 spanner2 spanner3 spanner4 nut1 nut2 nut3 gate)
#:precondition (and (at bob shed) (link shed location1) (link location4 gate) 
                   (or (at spanner1 location1) (at spanner2 location3) (at spanner3 location2) 
                       (at spanner4 location1)) 
                   (and (at nut1 gate) (at nut2 gate) (at nut3 gate))
               )
#:effect (and (not (at bob shed)) (not (at spanner1 location1)) (not (at spanner2 location3))
               (not (at spanner3 location2)) (not (at spanner4 location1))
               (not (at nut1 gate)) (not (at nut2 gate)) (not (at nut3 gate))
               (link location1 location2) (link location4 gate)
               (at bob location4) (at spanner1 location4) (at spanner2 location1)
               (at spanner3 location2) (at spanner4 location3) (useable spanner1)
               (tightened nut1) (tightened nut2) (tightened nut3)
               ))

#:action tighten_nut 
#:parameters (location1 location2 location3 location4 bob shed spanner1 spanner2 spanner3 spanner4 nut1 nut2 nut3 gate)
#:precondition (and (at bob location4) (at spanner1 location4) (at spanner2 location1)
                   (at spanner3 location2) (at spanner4 location3) 
                   (at nut1 gate) (at nut2 gate) (at nut3 gate)
               )
#:effect (and (not (at bob shed)) (not (at spanner1 location4)) (not (at spanner2 location1))
               (not (at spanner3 location2)) (not (at spanner4 location3))
               (not (at nut1 gate)) (not (at nut2 gate)) (not (at nut3 gate))
               (not (useable spanner1)) (tightened nut1) (tightened nut2)
               (loose spanner1) (loose spanner2) (loose spanner3)
               (at spanner1 gate) (at spanner2 gate) (at spanner3 gate) (tightened nut3)
               ))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s2064453291.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/137)

--- Test 138/200 ---
Problem: spanner-s4-n3-l4-s2141896940
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) (at?s?l))
#:effect (and (not (at?s?l)) (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) (at?n?l) (carrying?m?s) (useable?s) (loose?n))
#:effect (and (not (loose?n)) (not (useable?s)) (tightened?n)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s2141896940.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/138)

--- Test 139/200 ---
Problem: spanner-s4-n3-l4-s256131712
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l4-s256131712"
shed, bob, spanner1, spanner2, spanner3, spanner4, nut1, nut2, nut3, location1, location2, location3, location4, gate = spanner_generator.generate_problem(problem_name)

init_state = f"""
(at {bob} {shed})
(at {spanner1} {location1})
(useable {spanner1})
(at {spanner2} {location3})
(useable {spanner2})
(at {spanner3} {location3})
(useable {spanner3})
(at {spanner4} {location4})
(useable {spanner4})
(at {nut1} {gate})
(loose {nut1})
(at {nut2} {gate})
(loose {nut2})
(at {nut3} {gate})
(loose {nut3})
"""
 
constraints = f"""
(sometime-before (tightened {nut1}) (tightened {nut2}))
(forall (?m - man) (at-most-once (at?m {shed})))
"""

available_actions = {
    'bob': ['walk', 'pickup_spanner', 'tighten_nut'],
   'spanner1': ['pickup_spanner', 'tighten_nut'],
   'spanner2': ['pickup_spanner', 'tighten_nut'],
   'spanner3': ['pickup_spanner', 'tighten_nut'],
   'spanner4': ['pickup_spanner', 'tighten_nut'],
    'nut1': ['tighten_nut'],
    'nut2': ['tighten_nut'],
    'nut3': ['tighten_nut'],
    'location1': [],
    'location2': [],
    'location3': [],
    'location4': [],
    'gate': ['tighten_nut']
}

goal_state = "tightened nut1 tightened nut2 tightened nut3"

def validate_plan(plan):
    current_state = init_state.split('\n')
    for action in plan:
        action_parts = action.split()
        obj1 = obj2 = action_parts[0]
        if obj1 in available_actions.keys():
            obj1 = obj1 +'(' + obj1 + ')'
            obj2 = obj2 +'(' + obj2 + ')'
        if obj1 in current_state:
            obj1_index = current_state.index(obj1)
            obj2_index = current_state.index(obj2)
            if obj1_index < obj2_index:
                current_state.pop(obj2_index)
                current_state.pop(obj1_index)
                current_state.insert(obj2_index, action)
                return True
            else:
                return False
        else:
            return False
    return len(current_state) == len(goal_state.split())

def generate_plan():
    available_objects = {
        'bob': [shed, gate],
       'spanner1': [location1, location3, location4],
       'spanner2': [location3, location4],
       'spanner3': [location3, location4],
       'spanner4': [location4],
        'nut1': [gate],
        'nut2': [gate],
        'nut3': [gate],
        'location1': [shed, location2, location3, location4],
        'location2': [shed, location1, location3, location4],
        'location3': [shed, location1, location2, location4],
        'location4': [shed, location1, location2, location3],
        'gate': [shed, location1, location2, location3, location4]
    }
    available_objects = {obj: objects for obj, objects in available_objects.items() if len(objects) > 0}
    available_objects = {obj: objects for obj, objects in available_objects.items() for obj in objects}

    available_actions = {
        'bob': ['walk', 'pickup_spanner', 'tighten_nut'],
       'spanner1': ['pickup_spanner', 'tighten_nut'],
       'spanner2': ['pickup_spanner', 'tighten_nut'],
       'spanner3': ['pickup_spanner', 'tighten_nut'],
       'spanner4': ['pickup_spanner', 'tighten_nut'],
        'nut1': ['tighten_nut'],
        'nut2': ['tighten_nut'],
        'nut3': ['tighten_nut'],
        'location1': [],
        'location2': [],
        'location3': [],
        'location4': [],
        'gate': ['tighten_nut']
    }
    available_actions = {obj: actions for obj, actions in available_actions.items() if len(actions) > 0}
    available_actions = {obj: actions for obj, actions in available_actions.items() for action in actions}

    if len(available_objects.keys()) == 0 or len(available_actions.keys()) == 0:
        return []

    start_obj = min(available_objects.keys(), key=lambda obj: len(available_objects[obj]))
    start_action = min(available_actions.keys(), key=lambda obj: len(available_actions[obj]))

    if start_obj == 'gate':
        start_obj ='shed'
        start_action = 'walk'

    if validate_plan([start_action +'' + obj for obj in available_objects[start_obj] for start_action in available_actions[start_obj]]):
        return [start_action +'' + obj for obj in available_objects[start_obj] for start_action in available_actions[start_obj]]

    return generate_plan()

plan = generate_plan()
if validate_plan(plan):
    for action in plan:
        print(action)
else:
    print("NO-PLAN")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s256131712.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/139)

--- Test 140/200 ---
Problem: spanner-s4-n3-l4-s315153356
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import random

# Generate a valid, grounded, totally-ordered plan for the input below.
# <DOMAIN>
# (domain spanner)
# (:requirements :typing :strips :constraints)
#
# (:types 
# 	location locatable - object
# 	man nut spanner - locatable	
# )
#
# (:predicates 
# 	(at?m - locatable?l - location)
# 	(carrying?m - man?s - spanner)
# 	(useable?s - spanner)
# 	(link?l1 - location?l2 - location)
# 	(tightened?n - nut)
# 	(loose?n - nut)
# )
#
# (:action walk 
#        :parameters (?start - location?end - location?m - man)
#        :precondition (and (at?m?start) 
#                           (link?start?end))
#        :effect (and (not (at?m?start)) (at?m?end)))
#
# (:action pickup_spanner 
#        :parameters (?l - location?s - spanner?m - man)
#        :precondition (and (at?m?l) 
#                           (at?s?l))
#        :effect (and (not (at?s?l))
#                     (carrying?m?s)))
#
# (:action tighten_nut 
#        :parameters (?l - location?s - spanner?m - man?n - nut)
#        :precondition (and (at?m?l) 
#		      	   (at?n?l)
#			   (carrying?m?s)
#			   (useable?s)
#			   (loose?n))
#        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
# )
# </DOMAIN>

# <PROBLEM>
# ; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 4 --seed 315153356 --problem-name spanner-s4-n3-l4-s315153356
# (define (problem spanner-s4-n3-l4-s315153356)
#  (:domain spanner)
#  (:objects 
#     bob - man
#     spanner1 spanner2 spanner3 spanner4 - spanner
#     nut1 nut2 nut3 - nut
#     location1 location2 location3 location4 - location
#     shed gate - location
#    )
# (:init 
#     (at bob shed)
#     (at spanner1 location4)
#     (useable spanner1)
#     (at spanner2 location2)
#     (useable spanner2)
#     (at spanner3 location1)
#     (useable spanner3)
#     (at spanner4 location2)
#     (useable spanner4)
#     (loose nut1)
#     (at nut1 gate)
#     (loose nut2)
#     (at nut2 gate)
#     (loose nut3)
#     (at nut3 gate)
#     (link shed location1)
#     (link location4 gate)
#     (link location1 location2)
#     (link location2 location3)
#     (link location3 location4)
# )
# (:goal
#  (and
#   (tightened nut1)
#   (tightened nut2)
#   (tightened nut3)
# ))
# (:constraints
#  (and
#    (sometime-before (tightened nut2) (tightened nut3))
#    (forall (?m - man) (at-most-once (at?m shed)))
#  )
#)
#)</PROBLEM>

## Planning Rules
# 1) Only use available symbols:
#   - objects declared under PROBLEM :objects, and
#   - constants declared under DOMAIN/PROBLEM :constants (if any).
#   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

# 2) Constraints:
#   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
#   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

# 3) Plan form:
#   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

# 4) Internal validation before emitting (do not include reasoning in the output):
#   - At each step, all action preconditions hold in the current state.
#   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
#   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
# - Return **ONLY** the plan steps, one per line.
# - Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
# - Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
# - No numbering, timestamps, costs, comments, headers, code fences, or extra text.
# - No blank lines at the start or end; no trailing spaces; use a single space between tokens.
# - If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
# - If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
# Bad:
# - Plan:
# - Here is the plan:
# - (move a b)  (two actions on one line)
# - (move a) extra

# Good:
# (move a b)
# (pick a c)
# (drop a d)

# Now produce the final output.
def solve_spanner_problem():
    # Generate a valid, grounded, totally-ordered plan for the input below.
    # <DOMAIN>
    # (domain spanner)
    # (:requirements :typing :strips :constraints)
    #
    # (:types 
    # 	location locatable - object
    # 	man nut spanner - locatable	
    # )
    #
    # (:predicates 
    # 	(at?m - locatable?l - location)
    # 	(carrying?m - man?s - spanner)
    # 	(useable?s - spanner)
    # 	(link?l1 - location?l2 - location)
    # 	(tightened?n - nut)
    # 	(loose?n - nut)
    # )
    #
    # (:action walk 
    #        :parameters (?start - location?end - location?m - man)
    #        :precondition (and (at?m?start) 
    #                           (link?start?end))
    #        :effect (and (not (at?m?start)) (at?m?end)))
    #
    # (:action pickup_spanner 
    #        :parameters (?l - location?s - spanner?m - man)
    #        :precondition (and (at?m?l) 
    #                           (at?s?l))
    #        :effect (and (not (at?s?l))
    #                     (carrying?m?s)))
    #
    # (:action tighten_nut 
    #        :parameters (?l - location?s - spanner?m - man?n - nut)
    #        :precondition (and (at?m?l) 
    #		      	   (at?n?l)
    #			   (carrying?m?s)
    #			   (useable?s)
    #			   (loose?n))
    #        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
    # )
    # </DOMAIN>

    # <PROBLEM>
    # ; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 4 --seed 315153356 --problem-name spanner-s4-n3-l4-s315153356
    # (define (problem spanner-s4-n3-l4-s315153356)
    #  (:domain spanner)
    #  (:objects 
    #     bob - man
    #     spanner1 spanner2 spanner3 spanner4 - spanner
    #     nut1 nut2 nut3 - nut
    #     location1 location2 location3 location4 - location
    #     shed gate - location
    #    )
    # (:init 
    #     (at bob shed)
    #     (at spanner1 location4)
    #     (useable spanner1)
    #     (at spanner2 location2)
    #     (useable spanner2)
    #     (at spanner3 location1)
    #     (useable spanner3)
    #     (at spanner4 location2)
    #     (useable
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s315153356.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/140)

--- Test 141/200 ---
Problem: spanner-s4-n3-l4-s395791879
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(at spanner1 location4)
(useable spanner1)
(at spanner3 location3)
(useable spanner3)
(tightened nut1)
(tightened nut2)
(tightened nut3)
(not (at shed))
 
walk 
  (pickup_spanner 
   location1 
   spanner1 
   bob) 
  (pickup_spanner 
   location1 
   spanner2 
   bob) 
  (pickup_spanner 
   location4 
   spanner3 
   bob) 
  (tighten_nut 
   location1 
   spanner1 
   bob 
   nut1) 
  (tighten_nut 
   location1 
   spanner1 
   bob 
   nut2) 
  (tighten_nut 
   location1 
   spanner1 
   bob 
   nut3) 
  (tighten_nut 
   location4 
   spanner3 
   bob 
   nut1) 
  (tighten_nut 
   location4 
   spanner3 
   bob 
   nut2) 
  (tighten_nut 
   location4 
   spanner3 
   bob 
   nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s395791879.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/141)

--- Test 142/200 ---
Problem: spanner-s4-n3-l4-s424981847
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l4-s424981847"
spanner_generator.generate_spanner_problem(problem_name)
domain = spanner_generator.get_domain(problem_name)
problem = spanner_generator.get_problem(problem_name)

objects = problem.objects
constants = spanner_generator.get_constants(domain, problem)

available_objects = []
for obj in objects:
    if obj.startswith('spanner') or obj.startswith('nut') or obj.startswith('location'):
        available_objects.append(obj)

available_actions = []
for action in spanner_generator.get_available_actions(domain, problem, objects, constants):
    args = spanner_generator.get_action_args(action, domain, problem, objects, constants)
    if len(args) == len(available_objects):
        available_actions.append((action, args))

available_actions = spanner_generator.filter_constraints(available_actions, problem)

sequential_available_actions = []
for action, args in available_actions:
    if spanner_generator.is_action_sequential(action, domain, problem):
        sequential_available_actions.append((action, args))

sequential_available_actions = spanner_generator.filter_initial_state(sequential_available_actions, domain, problem)

goal = problem.goal
constraints = spanner_generator.get_constraints(problem)

sequential_goal_actions = spanner_generator.get_goal_actions(sequential_available_actions, goal, constraints)

sequential_goal_actions = spanner_generator.filter_internal_validation(sequential_goal_actions, domain, problem)

if len(sequential_goal_actions) == 0:
    print("NO-PLAN")
else:
    plan = spanner_generator.generate_plan(sequential_goal_actions, domain, problem)
    for step in plan:
        print(step)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s424981847.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/142)

--- Test 143/200 ---
Problem: spanner-s4-n3-l4-s458508792
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
 :parameters (?start - location?end - location?m - man)
 :precondition (and (at?m?start) 
                     (link?start?end))
 :effect (and (not (at?m?start)) (at?m?end))

#:action pickup_spanner 
 :parameters (?l - location?s - spanner?m - man)
 :precondition (and (at?m?l) 
                     (at?s?l))
 :effect (and (not (at?s?l))
               (carrying?m?s))

#:action tighten_nut 
 :parameters (?l - location?s - spanner?m - man?n - nut)
 :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
 :effect (and (not (loose?n))(not (useable?s)) (tightened?n))

@target-nodes = [location1, location2, location3, location4, shed, gate, bob, spanner1, spanner2, spanner3, spanner4, nut1, nut2, nut3]
@target-actions = [walk, pickup_spanner, tighten_nut]
@objects = {
  :bob => [bob], :location1 => [location1], :location2 => [location2], :location3 => [location3], :location4 => [location4], :shed => [shed], :gate => [gate], :spanner1 => [spanner1], :spanner2 => [spanner2], :spanner3 => [spanner3], :spanner4 => [spanner4], :nut1 => [nut1], :nut2 => [nut2], :nut3 => [nut3]
}
@constraints = [
  (tightened nut1, tightened nut2, tightened nut3), 
  (sometime-before [tightened nut2] [tightened nut3]), 
  (forall [bob] (at-most-once (at bob shed)))
]

initial_state = @objects.keys.map { |o| (o, @objects[o]) }.freeze
solution_space = []
for (m_l, m) in @objects.values.map { |o| [o, at(o, shed)] }.freeze
  for (l_s, l) in @objects.values.map { |o| [o, at(o, location1)] }.freeze
    if m == l
      continue
    end
    for (s_n, s) in @objects.values.map { |o| [o, at(o, shed)] }.freeze
      if s == l
        continue
      end
      for (n_l, n) in @objects.values.map { |o| [o, at(o, gate)] }.freeze
        if n == l
          continue
        end
        for (spanner_l, spanner) in @objects.values.map { |o| [o, at(o, location1)] }.freeze
          if spanner == s
            continue
          end
          for (nut_l, nut) in @objects.values.map { |o| [o, at(o, gate)] }.freeze
            if nut == n
              continue
            end
            solution_space << {m_l, l_s, s_n, n_l, spanner_l, spanner, nut_l, nut}
          end
        end
      end
    end
  end
end

valid_solutions = solution_space.filter { |ss| @constraints.all?(ss) }
if valid_solutions.empty?
  puts "NO-PLAN"
else
  plans = valid_solutions.map do |ss|
    [walk, pickup_spanner, tighten_nut,
     at(ss[:m_l], ss[:l_s]),
     at(ss[:s_n], ss[:n_l]),
     at(ss[:spanner_l], ss[:spanner]),
     at(ss[:nut_l], ss[:nut])]
  end
  for plan in plans
    puts plan.join(" ")
  end
end
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s458508792.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/143)

--- Test 144/200 ---
Problem: spanner-s4-n3-l4-s476128176
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
location1 = "shed"
spanner1 = "spanner1"
nut1 = "nut1"
gate = "gate"
link1 = "location1"
link2 = "location2"
link3 = "location3"
link4 = "location4"

def validate(state, goal, constraints):
    if constraints == "None":
        return all([goal]) == all([p for p in state]) and all([not p for p in state]) == all([not g for g in goal])
    else:
        for constraint in constraints.split("and"):
            if not constraint.replace(" ", "").replace("(sometime-before (tightened nut2))", "").replace("(at-most-once (at bob shed))", "").strip() == constraint.strip():
                return False
        return True

def generate(state, goal, constraints):
    if constraints == "None":
        available_objects = [obj for obj in state if obj!= "gate" and obj!= "link1" and obj!= "link2" and obj!= "link3" and obj!= "link4"]
        available_actions = ["walk", "pickup_spanner", "tighten_nut"]
        actions = []
        for action in available_actions:
            if action == "walk":
                for obj in [spanner1, spanner2, spanner3, spanner4, nut1, nut2, nut3, bob, gate]:
                    for other_obj in obj + [obj.replace("spanner", "nut").replace("man", "nut").replace("spanner", "spanner").replace("nut", "nut"), bob, gate, location1, location2, location3, location4]:
                        if obj!= other_obj:
                            actions.append(f"({action} {obj} {other_obj})")
            elif action == "pickup_spanner":
                for spanner in [spanner1, spanner2, spanner3, spanner4]:
                    for location in [location1, location2, location3, location4]:
                        for other_spanner in spanner + [spanner.replace("spanner1", "spanner2").replace("spanner2", "spanner3").replace("spanner3", "spanner4").replace("spanner4", "spanner1")]:
                            if spanner!= other_spanner:
                                actions.append(f"({action} {spanner} {location})")
                        for nut in [nut1, nut2, nut3]:
                            if spanner == nut:
                                continue
                            actions.append(f"({action} {spanner} {nut})")
            elif action == "tighten_nut":
                for spanner in [spanner1, spanner2, spanner3, spanner4]:
                    for location in [location1, location2, location3, location4]:
                        for nut in [nut1, nut2, nut3]:
                            if spanner == nut:
                                continue
                            actions.append(f"({action} {spanner} {nut})")
        return actions
    else:
        available_objects = [obj for obj in state if obj!= "gate" and obj!= "link1" and obj!= "link2" and obj!= "link3" and obj!= "link4"]
        available_actions = ["walk", "pickup_spanner", "tighten_nut"]
        actions = []
        for action in available_actions:
            if action == "walk":
                for spanner in [spanner1, spanner2, spanner3, spanner4]:
                    for location in [location1, location2, location3, location4]:
                        actions.append(f"({action} {spanner} {location})")
            elif action == "pickup_spanner":
                for spanner in [spanner1, spanner2, spanner3, spanner4]:
                    for nut in [nut1, nut2, nut3]:
                        actions.append(f"({action} {spanner} {nut})")
            elif action == "tighten_nut":
                for nut in [nut1, nut2, nut3]:
                    actions.append(f"({action} {nut})")
        return actions

available_objects = [location1, spanner1, spanner2, spanner3, spanner4, nut1, nut2, nut3, gate]
available_actions = ["walk", "pickup_spanner", "tighten_nut"]
actions = []
for action in available_actions:
    if action == "walk":
        for obj in [spanner1, spanner2, spanner3, spanner4, nut1, nut2, nut3, gate]:
            for other_obj in obj + [obj.replace("spanner", "nut").replace("man", "nut").replace("spanner", "spanner").replace("nut", "nut"), gate, location1, location2, location3]:
                if obj!= other_obj:
                    actions.append(f"({action} {obj} {other_obj})")
    elif action == "pickup_spanner":
        for spanner in [spanner1, spanner2, spanner3, spanner4]:
            for nut in [nut1, nut2, nut3]:
                actions.append(f"({action} {spanner} {nut})")
    elif action == "tighten_nut":
        for nut in [nut1, nut2, nut3]:
            actions.append(f"({action} {nut})")

state = available_objects
goal = []
for link in [link1, link2, link3, link4]:
    goal.append(f"(tightened {link})")

constraints = None

# validate the initial state and goal
if not validate(state, goal, constraints):
    print("Invalid initial state or goal")
else:
    # generate a plan
    plan = generate(state, goal, constraints)

    # validate the plan
    if not validate(state, goal, constraints):
        print("Invalid plan")
    else:
        # print the plan
        for action in plan:
            print(action)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s476128176.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/144)

--- Test 145/200 ---
Problem: spanner-s4-n3-l4-s609328837
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Define the domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 4 --seed 609328837 --problem-name spanner-s4-n3-l4-s609328837
(define (problem spanner-s4-n3-l4-s609328837)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location3)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (at spanner4 location2)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location4 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Define the constraints
constraints = [
    (sometime-before, (tightened, nut2), (tightened, nut3)),
    (at-most-once, (at, bob, shed))
]

# Create a Planner object
planner = Planner(domain, problem, constraints)

# Produce a valid, grounded, totally-ordered plan
plan = planner.plan()

# Validate the plan (not shown in the output)
planner.validate(plan)

# Output the plan
for step in plan:
    print(f"{step})")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s609328837.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/145)

--- Test 146/200 ---
Problem: spanner-s4-n3-l4-s638609312
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
import (sys)
from (range) import *
from (re) import *
from (datetime) import (
    datetime,
    timedelta
)
from (typing) import *
from (math) import (
    inf,
    pi,
    sqrt,
    factorial,
    isqrt,
    ceil,
    floor,
    perm,
    comb,
    prod
)
from (collections) import (
    (
        defaultdict,
        deque,
        Counter,
        OrderedDict,
        namedtuple,
        ChainMap,
        WeakKeyDictionary
    ),
    (
        list,
        tuple,
        set,
        frozenset,
        dict,
        OrderedDict,
        heapq
    )
)
from (io) import (BytesIO, IOStr)
from (os) import (
    path,
    curdir,
    cwd,
    getcwd,
    mkdir,
    exists,
    remove,
    system,
    tempdir,
    cut,
    realpath,
    expanduser,
    copyfile,
    copyfileobj,
    link,
    symlink,
    renames
)

(
    A,
    B,
    C,
    directed_graph,
    edge,
    vertices,
    weight
) -> (type)
class Edge(object):
    def __init__(self,
                 source: 'Vertex', dest: 'Vertex', w: int = 0) -> None:
        self.source = source
        self.dest = dest
        self.w = w

from (typing) import (
    List,
    Tuple,
    Set,
    Dict,
    Optional,
    Callable,
    Collection,
    Any,
    Union,
    Generic,
    Iterable,
    Iterator,
    TypeVar,
    GenericType,
    Type,
    cast,
    ContainerEq,
    ContainerOrd
)
X = TypeVar('X')
Y = TypeVar('Y')
C = TypeVar('C', bound=Collection[X])
A = Tuple[Any,...]
D = Dict[Any, Any]
Q = Set[Any]
V = Union[
    int,
    str,
    float,
    complex,
    datetime,
    timedelta,
    None,
    Any
]
AI = Iterable[Any]
AI = Generic[AI, X]
AO = Callable[[], X]
AIO = Callable[[], A]
AIo = Generic[AIO[X], Y]
AOo = Generic[AO[X], Z], where Z = Collection[X]
AIOo = Generic[AIOo[X], Z]
B = int  # replace with int
class StrEnum(RawEnum, Generic[str, int]):
    @classmethod
    def _generate(cls, **_kwargs) -> Dict[str, int]:
        gen = super(StrEnum, cls)._generate(**_kwargs)
        gen = {k: v for (k, v) in gen.items() if not k.startswith('__')}
        gen['name'] = max(gen['name'], key=len)
        return gen

    @property
    def name(self) -> str:
        return self.value

class Values(CollectionEq, Generic[X]):
    def __init__(self, *args: X) -> None:
        if len(args)!= 2:
            raise ValueError('Values must be initialized with two values')
        self._values = args

    def __len__(self) -> int:
        return len(self._values[0])

    def __iter__(self) -> Iterator[X]:
        return iter(self._values[0])

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Values):
            return False
        return self._values[0] == other._values[1]

    def __hash__(self) -> int:
        return hash((self._values[0], self._values[1]))

    def __contains__(self, item: object) -> bool:
        return item in self._values[0]

    def __getitem__(self, item: object) -> X:
        return self._values[0][self._values[1].__getitem__(item)]

    def __setitem__(self, item: object, value: X) -> None:
        self._values[0][self._values[1].__setitem__(item, value)] = value

    def __delitem__(self, item: object) -> None:
        del self._values[0][self._values[1].__delitem__(item)]

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __iter__(self) -> Iterator[X]:
        return iter(self._values[0])

    def __iter__(self) -> Iterator[X]:
        return iter(self._values[0])

    def __iter__(self) -> Iterator[X]:
        return iter(self._values[0])

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({list(self)}, {tuple(self)})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'

    def __repr__(self) -> str:
        return f'Values({self._values[0]}, {self._values[1]})'
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s638609312.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/146)

--- Test 147/200 ---
Problem: spanner-s4-n3-l4-s645105511
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator
problem_name = "spanner-s4-n3-l4-s645105511"
spanner_generator.generate_problem(problem_name)
# Produce a valid, grounded, totally-ordered plan
import pddlplan2
domain = "domain/spanner.pddl"
problem = "problem/spanner-s4-n3-l4-s645105511.pddl"
pddlplan2.generate_plan(domain, problem, ["spanner-s4-n3-l4-s645105511"], False, False)

# Internal validation before emitting
def validate_plan(plan, domain, problem):
    # At each step, all action preconditions hold in the current state.
    # Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
    # If constraints exist in PROBLEM, ensure the plan satisfies all of them.
    pass

# Output Requirements
def emit_plan(plan, domain, problem):
    # Return **ONLY** the plan steps, one per line.
    # Each line must be exactly: `<action-name> <obj1> <obj2>...`
    # Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
    # No numbering, timestamps, costs, comments, headers, code fences, or extra text.
    # No blank lines at the start or end; no trailing spaces; use a single space between tokens.
    output = ""
    for step in plan:
        action = step[0]
        objects = step[1:]
        obj_str = " ".join([f"{obj}:obj" for obj in objects])
        output += f"({action} {obj_str})\n"
    return output.strip()

# Generate and validate the plan
plan = pddlplan2.generate_plan(domain, problem, ["spanner-s4-n3-l4-s645105511"], False, False)
validation_result = validate_plan(plan, domain, problem)
output = emit_plan(plan, domain, problem)

# Print the output
print(output)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s645105511.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/147)

--- Test 148/200 ---
Problem: spanner-s4-n3-l4-s728535634
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location2)
(useable spanner3)
(at spanner4 location2)
(useable spanner4)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(pickup_spanner location1 spanner2 bob)
(pickup_spanner location1 spanner3 bob)
(pickup_spanner location1 spanner4 bob)
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
(tighten_nut location2 spanner2 bob nut1)
(tighten_nut location2 spanner2 bob nut2)
(tighten_nut location2 spanner2 bob nut3)
(tighten_nut location2 spanner3 bob nut1)
(tighten_nut location2 spanner3 bob nut2)
(tighten_nut location2 spanner3 bob nut3)
(tighten_nut location2 spanner4 bob nut1)
(tighten_nut location2 spanner4 bob nut2)
(tighten_nut location2 spanner4 bob nut3)
(walk location2 gate)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s728535634.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/148)

--- Test 149/200 ---
Problem: spanner-s4-n3-l4-s897330818
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location3)
(useable spanner1)
(at bob shed)
(nothing)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)

(link shed location1)
(at location1 location2)
(at location2 location3)
(at location3 location4)
(link location4 gate)
(at gate bob)
(nothing)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s897330818.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/149)

--- Test 150/200 ---
Problem: spanner-s4-n3-l4-s903704961
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [from/spanner-s4-n3-l4-s903704961] 
(starting at shed)
  (walk bob location1)
  (pickup_spanner bob location1 spanner1)
  (tighten_nut bob location1 spanner1 nut1 gate)
  (walk nut1 gate)
  (tighten_nut nut1 gate nut2 gate)
  (walk nut2 gate)
  (tighten_nut nut2 gate spanner2 gate)
  (walk spanner2 gate)
  (tighten_nut spanner2 gate spanner3 gate)
  (walk spanner3 gate)
  (tighten_nut spanner3 gate spanner4 gate)
  (walk spanner4 gate)
  (tighten_nut spanner4 gate nut3 gate)
  (walk nut3 gate)
  (tighten_nut nut3 gate nut1 gate)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s903704961.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/150)

--- Test 151/200 ---
Problem: spanner-s4-n3-l4-s953257103
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
 :parameters (?start - location?end - location?m - man)
 :precondition (and (at?m?start) 
                     (link?start?end))
 :effect (and (not (at?m?start)) (at?m?end))

#:action pickup_spanner 
 :parameters (?l - location?s - spanner?m - man)
 :precondition (and (at?m?l) 
                     (at?s?l))
 :effect (and (not (at?s?l))
               (carrying?m?s))

#:action tighten_nut 
 :parameters (?l - location?s - spanner?m - man?n - nut)
 :precondition (and (at?m?l) 
                     (at?n?l)
                     (carrying?m?s)
                     (useable?s)
                     (loose?n))
 :effect (and (not (loose?n))
               (not (useable?s))
               (tightened?n))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s953257103.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/151)

--- Test 152/200 ---
Problem: spanner-s4-n3-l4-s969539137
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [(pickup_spanner 
        (at bob shed)
        (at spanner1 location2)
        (at bob shed)
        (at spanner1 location2)
        (at bob shed)
        (useable spanner1)
        (at bob shed)
        (at spanner1 location2)
        (at bob shed)
        (at spanner1 location1)
        (not (at spanner1 location2))
        (not (useable spanner1))
        (tightened nut1))
 
 (tighten_nut 
        (at bob shed)
        (at spanner1 location1)
        (at bob shed)
        (at nut1 gate)
        (at bob shed)
        (at spanner1 location1)
        (at bob shed)
        (at nut1 gate)
        (at bob shed)
        (at spanner1 location2)
        (at bob shed)
        (at nut1 gate)
        (at spanner1 location2)
        (at bob shed)
        (at nut1 gate)
        (not (loose nut1))
        (useable spanner1)
        (at spanner1 location2)
        (at bob shed)
        (at nut1 gate)
        (at spanner1 location2)
        (at bob shed)
        (at nut1 gate)
        (not (loose nut2))
        (tightened nut2))
 
 (tighten_nut 
        (at bob shed)
        (at spanner1 location1)
        (at bob shed)
        (at nut2 gate)
        (at bob shed)
        (at spanner1 location1)
        (at bob shed)
        (at nut2 gate)
        (at bob shed)
        (at spanner1 location2)
        (at bob shed)
        (at nut2 gate)
        (at spanner1 location2)
        (at bob shed)
        (at nut2 gate)
        (not (loose nut2))
        (useable spanner1)
        (at spanner1 location2)
        (at bob shed)
        (at nut2 gate)
        (at spanner1 location2)
        (at bob shed)
        (at nut2 gate)
        (not (loose nut3))
        (tightened nut3)))]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s969539137.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/152)

--- Test 153/200 ---
Problem: spanner-s4-n3-l4-s98498673
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                       (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location4)
(useable spanner1)
(at bob shed)
(at nut1 gate)
(loose nut1)
(at nut1 gate)
(loose nut2)
(at nut2 gate)
(loose nut3)
(at nut3 gate)
(link shed location1)
(link location4 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(tightened nut1)
(tightened nut2)
(tightened nut3)
 
(pickup_spanner location1 spanner1 bob)
(pickup_spanner location1 spanner2 bob)
(pickup_spanner location1 spanner3 bob)
(pickup_spanner location1 spanner4 bob)
 
(walk shed location1 bob)
(walk location1 location2 bob)
(walk location2 location3 bob)
(walk location3 location4 bob)
 
(tighten_nut location1 spanner1 bob nut1)
(tighten_nut location1 spanner1 bob nut2)
(tighten_nut location1 spanner1 bob nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l4-s98498673.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/153)

--- Test 154/200 ---
Problem: spanner-s4-n3-l5-s1004667436
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [(pickup_spanner 
        (at bob shed)
        (at spanner1 location4)
        (at bob shed)
        (at spanner1 location4)
        (at bob shed)
        (at spanner1 location4)
        (at bob location1)
        (at spanner1 location4)
        (useable spanner1)
        (at spanner2 location1)
        (useable spanner2)
        (at bob location1)
        (at spanner1 location4)
        (at spanner2 location1)
        (at bob location1)
        (at spanner1 location4)
        (at spanner2 location1)
        (at bob location1)
        (at spanner1 location4)
        (at spanner2 location1)
        (at bob location1)
        (at spanner1 location4)
        (tightened nut1))
 
     (tighten_nut 
      (at bob location1)
      (at spanner1 location4)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (tightened nut2))
 
     (tighten_nut 
      (at bob location1)
      (at spanner1 location4)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (at bob location1)
      (at spanner1 location4)
      (at spanner2 location1)
      (tightened nut3)))]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1004667436.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/154)

--- Test 155/200 ---
Problem: spanner-s4-n3-l5-s1030741926
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: .dispatchEvent(new Promise(resolve => {
initializeSafetyGen()
resolve()
}))()
function initializeSafetyGen() {
window.genSafety = {
name:'spanner-s4-n3-l5-s1030741926',
rulesUrl:'spanner-s4-n3-l5-s1030741926 rules.pDDL',
objectsUrl:'spanner-s4-n3-l5-s1030741926 objects.ltl',
constraintsUrl:'spanner-s4-n3-l5-s1030741926 constraints.pddl',
genSafetyGen: (options = {}) => {
options.constraints = options.constraints || true;
options.safetyGenType = options.safetyGenType ||'spanner-s4-n3-l5-s1030741926';
options.nutSafetyGenType = options.nutSafetyGenType ||'spanner-s4-n3-l5-s1030741926';
options.spannerSafetyGenType = options.spannerSafetyGenType ||'spanner-s4-n3-l5-s1030741926';
options.n = options.n || 3;
options.m = options.m || 4;
options.l = options.l || 5;
options.seed = options.seed || Math.floor(Date.now() / 1000);
options.safetyGenRaw = (genOptions) => {
var safetyGenRulesUrl = window genSafety.rulesUrl;
var safetyGenObjectsUrl = window genSafety.objectsUrl;
var constraints = window genSafety.constraintsUrl;
var rawSafetyGen = window require(safetyGenRulesUrl);
var rawSafetyGenObjects = window require(safetyGenObjectsUrl);
var safetyGenRawOutput = rawSafetyGen(safetyGenObjectsUrl, constraints, genOptions);
if (safetyGenRawOutput) safetyGenRawOutput = JSON.parse(safetyGenRawOutput);
return safetyGenRawOutput || {};
};
options safetyGen = () => {
var genOptions = {
seed: window genSafety.seed,
constraints: window genSafety.constraints,
safetyGenType: window genSafety.safetyGenType,
nutSafetyGenType: window genSafety.nutSafetyGenType,
spannerSafetyGenType: window genSafety.spannerSafetyGenType,
n: window genSafety.n,
m: window genSafety.m,
l: window genSafety.l
};
var safetyGenOutput = window genSafety.genSafetyRaw(genOptions);
return safetyGenOutput;
}
}
genSafety.safetyGen()
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1030741926.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/155)

--- Test 156/200 ---
Problem: spanner-s4-n3-l5-s1219511012
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

#:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(at bob gate)
(loose nut1)
(at nut1 gate)
(at nut2 gate)
(at nut2 gate)
(at nut3 gate)
(tightened nut1)
(tightened nut2)
(tightened nut3)
(link shed location1)
(link location5 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)
 
walk shed location1 spanner1 bob
pickup_spanner location1 spanner1 bob
tighten_nut location1 spanner1 bob nut1 nut2 nut3
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1219511012.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/156)

--- Test 157/200 ---
Problem: spanner-s4-n3-l5-s1259661454
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import/spanner-generator; spanner = spanner-generator/spanner_generator()
problem_name = "spanner-s4-n3-l5-s1259661454"
gen_spanner_problem(spanner, problem_name)

domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 1259661454 --problem-name spanner-s4-n3-l5-s1259661454
(define (problem spanner-s4-n3-l5-s1259661454)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location3)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location1)
    (useable spanner3)
    (at spanner4 location2)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location5 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
    (link location4 location5)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

obj_count = 0
solution = ""
constraints_satisfied = True

for obj in spanner.objects():
    obj_name = obj.name
    if obj_name.startswith('location'):
        for spanner_obj in spanner.objects():
            if spanner_obj.name =='man' or spanner_obj.name =='spanner' or spanner_obj.name == 'nut' or spanner_obj.name == 'gate' or spanner_obj.name =='shed':
                continue
            if obj_name == spanner_obj.name + '_1' or obj_name == spanner_obj.name + '_2':
                continue
            if 'useable' in spanner_obj.pseudostates() or 'tightened' in spanner_obj.pseudostates():
                obj_count += 1
                if obj_name == spanner_obj.name + '_1':
                    solution += " (pick " + spanner_obj.name + " " + obj_name + ")"
                if obj_name == spanner_obj.name + '_2':
                    solution += " (drop " + spanner_obj.name + " " + obj_name + ")"
                continue
            if 'at' in spanner_obj.pseudostates():
                spanner_obj_at = spanner_obj.pseudostate_name(spanner_obj, 'at')
                obj_at = obj_name + '_at'
                if spanner_obj_at == obj_at:
                    continue
                constraints_satisfied = False
                break
        if not constraints_satisfied:
            break
    if obj_name.startswith('link'):
        for spanner_obj in spanner.objects():
            if spanner_obj.name =='man' or spanner_obj.name =='spanner' or spanner_obj.name == 'nut' or spanner_obj.name == 'gate' or spanner_obj.name =='shed':
                continue
            if obj_name == spanner_obj.name + '_1' or obj_name == spanner_obj.name + '_2':
                continue
            if 'useable' in spanner_obj.pseudostates() or 'tightened' in spanner_obj.pseudostates():
                obj_count += 1
                if obj_name == spanner_obj.name + '_1':
                    solution += " (walk " + spanner_obj.name + " " + obj_name + ")"
                if obj_name == spanner_obj.name + '_2':
                    solution += " (use " + spanner_obj.name + " " + obj_name + ")"
                continue
            if 'at' in spanner_obj.pseudostates():
                spanner_obj_at = spanner_obj.pseudstate_name(spanner_obj, 'at')
                obj_at = obj_name + '_at'
                if spanner_obj_at == obj_at:
                    continue
                constraints_satisfied = False
                break
        if not constraints_satisfied:
            break
obj_count += obj_count
print(solution)
if obj_count > obj_count or constraints_satisfied == False:
    print("NO-PLAN")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1259661454.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/157)

--- Test 158/200 ---
Problem: spanner-s4-n3-l5-s1316772739
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location5)
(useable spanner3)
(at spanner4 location2)
(useable spanner4)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location5 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1316772739.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/158)

--- Test 159/200 ---
Problem: spanner-s4-n3-l5-s1326238689
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: â”” (no-plan)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1326238689.soln
âœ— Invalid solution: Validation failed: Type-checking walk
...action passes type checking.
Type-checking pickup_spanner
...action passes type checking.
Type-checking tighten_nut
...action passes type checking.
Checking plan: /tmp/2317655.1.gpu/tmp_e5_vzjg.soln
â””Bad plan description!


Failed plans:
 /tmp/2317655.1.gpu/tmp_e5_vzjg.soln 

Current success rate: 0.0% (0/159)

--- Test 160/200 ---
Problem: spanner-s4-n3-l5-s1422168867
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: <walk bob location1 location2 spanner1>
(<pickup_spanner spanner1 location2 bob>)
(<tighten_nut bob location2 spanner1 nut1>)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1422168867.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/160)

--- Test 161/200 ---
Problem: spanner-s4-n3-l5-s1471195100
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s1471195100"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
objects = spanner_generator.get_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)

objects_declared = {}
for obj in objects:
    if obj not in objects_declared:
        objects_declared[obj] = 1

available_objects = [obj for obj in available_objects if obj in objects_declared]

constraints = spanner_generator.get_constraints(problem_name)

def validate_action_preconditions(action, state):
    for pred in action['precondition'].args:
        if pred['obj'] =='m' and 'at' not in pred['name']:
            if 'at' not in state or not (state['at_m'] == pred['arg']):
                return False
        elif pred['obj'] =='s' and 'carrying' not in pred['name']:
            if 'carrying_s' not in state or not (state['carrying_s'] == pred['arg']):
                return False
        elif pred['obj'] == 'n' and 'loose' not in pred['name']:
            if 'loose_n' not in state or not (state['loose_n'] == pred['arg']):
                return False
        elif pred['obj'] == 'l' and 'link' not in pred['name']:
            if 'link_l1_l2' not in state or not (state['link_l1_l2'] == pred['arg']):
                return False
        elif pred['obj'] == 'l2' and 'link' not in pred['name']:
            if 'link_l2_l1' not in state or not (state['link_l2_l1'] == pred['arg']):
                return False
        elif pred['obj'] =='s' and 'useable' not in pred['name']:
            if 'useable_s' not in state or not (state['useable_s'] == pred['arg']):
                return False
        elif pred['obj'] == 'n' and 'tightened' not in pred['name']:
            if 'tightened_n' not in state or not (state['tightened_n'] == pred['arg']):
                return False
        else:
            return False
    return True

def validate_plan(state, plan):
    for i, action in enumerate(plan):
        if i > 0 and plan[i-1]['action'] == action['action']:
            return False
        if not validate_action_preconditions(action, state):
            return False
    return True

def generate_spanner_problem(problem_name):
    spanner_generator.spanner_generator(problem_name)

def validate_spanner_problem(problem_name):
    spanner_generator.generate_spanner_problem(problem_name)
    domain = "<DOMAIN>"
    problem = "<PROBLEM>"
    print(domain)
    print(problem)
    available_objects = spanner_generator.get_available_objects(problem_name)
    objects = spanner_generator.get_objects(problem_name)
    constants = spanner_generator.get_constants(problem_name)
    objects_declared = {}
    for obj in objects:
        if obj not in objects_declared:
            objects_declared[obj] = 1
    available_objects = [obj for obj in available_objects if obj in objects_declared]
    constraints = spanner_generator.get_constraints(problem_name)
    valid = True
    if constraints:
        valid = False
        for constraint in constraints:
            if not validate_spanner_constraint(constraint, problem_name):
                print(f"Invalid constraint: {constraint['name']}")
                valid = True
                break
    if valid:
        print("Valid spanner problem generated.")
    else:
        print("Invalid spanner problem.")

def validate_spanner_constraint(constraint, problem_name):
    spanner_generator.generate_spanner_problem(problem_name)
    domain = "<DOMAIN>"
    problem = "<PROBLEM>"
    print(domain)
    print(problem)
    available_objects = spanner_generator.get_available_objects(problem_name)
    objects = spanner_generator.get_objects(problem_name)
    constants = spanner_generator.get_constants(problem_name)
    objects_declared = {}
    for obj in objects:
        if obj not in objects_declared:
            objects_declared[obj] = 1
    available_objects = [obj for obj in available_objects if obj in objects_declared]
    constraints = spanner_generator.get_constraints(problem_name)
    constraint_valid = True
    if constraint['type'] == 'PDDL3':
        if constraint['name'] =='sometime-before':
            if not validate_sometime_before_constraint(constraint, problem_name):
                constraint_valid = False
        elif constraint['name'] == 'at-most-once':
            if not validate_at_most_once_constraint(constraint, problem_name):
                constraint_valid = False
        else:
            constraint_valid = False
    elif constraint['type'] == 'PDDL2':
        if constraint['name'] == 'goal':
            if not validate_goal_constraint(constraint, problem_name):
                constraint_valid = False
        elif constraint['name'] == 'constraint':
            if not validate_constraint_constraint(constraint, problem_name):
                constraint_valid = False
        else:
            constraint_valid = False
    return constraint_valid

def validate_sometime_before_constraint(constraint, problem_name):
    spanner_generator.generate_spanner_problem(problem_name)
    domain = "<DOMAIN>"
    problem = "<PROBLEM>"
    print(domain)
    print(problem)
    available_objects = spanner_generator.get_available_objects(problem_name)
    objects = spanner_generator.get_objects(problem_name)
    constants = spanner_generator.get_constants(problem_name)
    objects_declared = {}
    for obj in objects:
        if obj not in objects_declared:
            objects_declared[obj] = 1
    available_objects = [obj for obj in available_objects if obj in objects_declared]
    constraints = spanner_generator.get_constraints(problem_name)
    constraint_valid = True
    if constraint['name'] =='sometime-before':
        if not validate_sometime_before_objects(constraint, problem_name):
            constraint_valid = False
        elif constraint['precondition'].args[0]['obj'] =='m' and constraint['precondition'].args[0]['name'] == 'at_m':
            if not validate_sometime_before_at_m_constraint(constraint, problem_name):
                constraint_valid = False
        elif constraint['precondition'].args[0]['obj'] =='s' and constraint['precondition'].args[0]['name'] == 'useable_s':
            if not validate_sometime_before_useable_s_constraint(constraint, problem_name):
                constraint_valid = False
        elif constraint['precondition'].args[0]['obj'] == 'n' and constraint['precondition'].args[0]['name'] == 'tightened_n':
            if not validate_sometime_before_tightened_n_constraint(constraint, problem_name):
                constraint_valid = False
        else:
            constraint_valid = False
    return constraint_valid

def validate_sometime_before_at_m_constraint(constraint, problem_name):
    spanner_generator.generate_spanner_problem(problem_name)
    domain = "<DOMAIN>"
    problem = "<PROBLEM>"
    print(domain)
    print(problem)
    available_objects = spanner_generator.get_available_objects(problem_name)
    objects = spanner_generator.get_objects(problem_name)
    constants = spanner_generator.get_constants(problem_name)
    objects_declared = {}
    for obj in objects:
        if obj not in objects_declared:
            objects_declared[obj] = 1
    available_objects = [obj for obj in available_objects if obj in objects_declared]
    constraints = spanner_generator.get_constraints(problem_name)
    constraint_valid = True
    if constraint['precondition'].args[0]['obj'] =='m' and constraint['precondition'].args[0]['name'] == 'at_m':
        if not validate_at_m_constraint(constraint, problem_name):
            constraint_valid = False
    return constraint_valid

def validate_sometime_before_useable_s_constraint(constraint, problem_name):
    spanner_generator.generate_spanner_problem(problem_name)
    domain = "<DOMAIN>"
    problem = "<PROBLEM>"
    print(domain)
    print(problem)
    available_objects = spanner_generator.get_available_objects(problem_name)
    objects = spanner_generator.get_objects(problem_name)
    constants = spanner_generator.get_constants(problem_name)
    objects_declared = {}
    for obj in objects:
        if obj not in objects_declared:
            objects_declared[obj] = 1
    available_objects = [obj for obj in available_objects if obj in objects_declared]
    constraints = spanner_generator.get_constraints(problem_name)
    constraint_valid = True
    if constraint['precondition'].args[0]['obj'] =='s' and constraint['precondition'].args[0]['name'] == 'useable_s':
        if not validate_useable_s_constraint(constraint, problem_name):
            constraint_valid = False
    return constraint_valid

def validate_sometime_before_tightened_n_constraint(constraint, problem_name):
    spanner_generator.generate_spanner_problem(problem_name)
    domain = "<DOMAIN>"
    problem = "<PROBLEM>"
    print(domain)
    print(problem)
    available_objects = spanner_generator.get_available_objects(problem_name)
    objects = spanner_generator.get_objects(problem_name)
    constants = spanner_generator.get_constants(problem_name)
    objects_declared = {}
    for obj in objects:
        if
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1471195100.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/161)

--- Test 162/200 ---
Problem: spanner-s4-n3-l5-s1480631790
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Symbols, Constraints

# Define the domain and problem symbols
domain = {
    'domain':'spanner',
    'typing': ['man', 'nut','spanner', 'location'],
   'strips': True,
    'constraints': True,
    'predicates': ['at', 'carrying', 'useable', 'loose', 'tightened'],
    'constants': ['bob','spanner1','spanner2','spanner3','spanner4', 'nut1', 'nut2', 'nut3', 'location1', 'location2', 'location3', 'location4', 'location5','shed', 'gate'],
    'predicates_args': {
        'at': [('man', 'location'), ('spanner', 'location')],
        'carrying': [('man','spanner')],
        'useable': [('spanner', )],
        'loose': [('nut', )],
        'tightened': [('nut', )],
        'link': [('location', 'location')]
    }
}

problem = {
    'problem':'spanner-s4-n3-l5-s1480631790',
    'objects': {
        'bob': None,
       'spanner1': None,
       'spanner2': None,
       'spanner3': None,
       'spanner4': None,
        'nut1': None,
        'nut2': None,
        'nut3': None,
        'location1': None,
        'location2': None,
        'location3': None,
        'location4': None,
        'location5': None,
       'shed': None,
        'gate': None
    },
    'init': {
        ('at', 'bob','shed'): True,
        ('at','spanner1', 'location1'): True,
        ('useable','spanner1'): True,
        ('at','spanner2', 'location2'): True,
        ('useable','spanner2'): True,
        ('at','spanner3', 'location2'): True,
        ('useable','spanner3'): True,
        ('at','spanner4', 'location1'): True,
        ('useable','spanner4'): True,
        ('loose', 'nut1'): True,
        ('at', 'nut1', 'gate'): True,
        ('loose', 'nut2'): True,
        ('at', 'nut2', 'gate'): True,
        ('loose', 'nut3'): True,
        ('at', 'nut3', 'gate'): True,
        ('link','shed', 'location1'): True,
        ('link', 'location5', 'gate'): True,
        ('link', 'location1', 'location2'): True,
        ('link', 'location2', 'location3'): True,
        ('link', 'location3', 'location4'): True,
        ('link', 'location4', 'location5'): True
    },
    'goal': {
        ('tightened', 'nut1'): True,
        ('tightened', 'nut2'): True,
        ('tightened', 'nut3'): True
    },
    'constraints': [
        ('sometime-before', 'tightened', 'nut1'),
        ('forall','man', 'at-most-once','shed')
    ]
}

# Create a new planner
planner = Planner(domain, problem)

# Generate symbols
symbols = planner.generate_symbols()

# Generate constraints
constraints = planner.generate_constraints(symbols, problem)

# Solve the problem
solution = planner.solve(symbols, constraints)

# Produce the final output
output = []
for step in solution:
    action = symbols['actions'][step['action']]
    obj1 = symbols['objects'][action obj1]
    obj2 = symbols['objects'][action obj2]
    if step['type'] == 'action':
        output.append(f"({action} {obj1} {obj2})")
    elif step['type'] == 'constraint':
        constraint = symbols['constraints'][step['constraint']]
        obj1 = symbols['objects'][constraint obj1]
        obj2 = symbols['objects'][constraint obj2]
        if constraint =='sometime-before':
            output.append(f"({obj1} before {obj2})")
        elif constraint == 'forall':
            output.append(f"({obj1} only-once-at {obj2})")
        elif constraint == 'at':
            output.append(f"({obj1} at {obj2})")
        elif constraint == 'link':
            output.append(f"({obj1} connected-to {obj2})")
        elif constraint == 'useable':
            output.append(f"({obj1} useable-now)")
        elif constraint == 'loose':
            output.append(f"({obj1} loose-now)")
        elif constraint == 'tightened':
            output.append(f"({obj1} tightened-now)")
for line in output:
    print(line)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1480631790.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/162)

--- Test 163/200 ---
Problem: spanner-s4-n3-l5-s1504554823
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import/spanner-generator; spanner = spanner-generator.spanner_generator()
problem_name = "spanner-s4-n3-l5-s1504554823"
spanner.generate_problem(problem_name=problem_name)
domain = spanner.generate_domain(problem_name)
problems = spanner.generate_problems([problem_name])
constraints = spanner.generate_constraints(problems, problem_name)

gen = spanner-generator.spanner_generator()
location1 = spanner-generator.location()
location2 = spanner-generator.location()
location3 = spanner-generator.location()
location4 = spanner-generator.location()
location5 = spanner-generator.location()
bob = spanner-generator.bob()
spanner1 = spanner-generator.spanner()
spanner2 = spanner-generator.spanner()
spanner3 = spanner-generator.spanner()
spanner4 = spanner-generator.spanner()
nut1 = spanner-generator.nut()
nut2 = spanner-generator.nut()
nut3 = spanner-generator.nut()
shed = spanner-generator.shed()
gate = spanner-generator.gate()

action_walk = spanner-generator.action_walk(
    location1, location5, bob
)
action_pick_spanner = spanner-generator.action_pick_spanner(
    location1, spanner1, bob
)
action_tighten_nut = spanner-generator.action_tighten_nut(
    location1, spanner1, bob, nut1
)
action_pick_spanner_2 = spanner-generator.action_pick_spanner(
    location4, spanner2
)
action_tighten_nut_2 = spanner-generator.action_tighten_nut(
    location4, spanner2, bob, nut2
)
action_pick_spanner_3 = spanner-generator.action_pick_spanner(
    location3, spanner3
)
action_tighten_nut_3 = spanner-generator.action_tighten_nut(
    location3, spanner3, bob, nut3
)
action_pick_spanner_4 = spanner-generator.action_pick_spanner(
    location4, spanner4
)
action_tighten_nut_4 = spanner-generator.action_tighten_nut(
    location4, spanner4, bob, nut3
)

constraints.append(spanner-generator.constraint(nut2, nut3))
constraints.append(spanner-generator.constraint(bob, shed, "at-most-once"))

actions = [
    action_walk,
    action_pick_spanner,
    action_tighten_nut,
    action_pick_spanner_2,
    action_tighten_nut_2,
    action_pick_spanner_3,
    action_tighten_nut_3,
    action_pick_spanner_4,
    action_tighten_nut_4,
]

plan = []
for action in actions:
    if spanner_generator.is_valid_action(plan, action):
        for step in action.args:
            if spanner_generator.is_valid_state(plan, step):
                plan.append(action.name + (" " + " ".join(map(str, action.args)) if action.args else ""))

print("\n".join(plan))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1504554823.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/163)

--- Test 164/200 ---
Problem: spanner-s4-n3-l5-s1505956009
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s1505956009"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)
print()

problem = "<PROBLEM>"
print(problem)
print()

spanner_generator.generate_spanner_problem(problem_name)

rules = """
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

"""
constraints = """
and
 (sometime-before (tightened nut2) (tightened nut3))
and
 (forall (?m - man) (at-most-once (at?m shed)))
"""

domain_objects = """
(:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
"""

problem_objects = """
(:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
"""

action_walk = """
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))
"""

action_pick_spanner = """
(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))
"""

action_tighten_nut = """
(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
"""

domain_predicates = """
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))
"""

problem_predicates = """
(:predicates
  (and
   (sometime-before (tightened nut2) (tightened nut3))
   (forall (?m - man) (at-most-once (at?m shed)))
  )
"""

domain_constants = """
()

"""

problem_constants = """
()

"""

print("DOMAIN")
print(domain_objects)
print()
print("PROBLEM")
print(problem_objects)
print()
print("RULES")
print(rules)
print()
print("CONSTRANTS")
print(constraints)
print()

available_symbols = set(domain_objects.split() + problem_objects.split()) - {
    '(:objects', '(:action', '(:predicates', '(:constraints', '(:parameters', '(:effect', '(:precondition'
} 

available_symbols = sorted(list(available_symbols)) 

objects = {}
actions = {}
predicates = {}
constraints = {}

for symbol in available_symbols:
    if symbol.startswith('(:'):
        if symbol.endswith(')'):
            name = symbol[2:-1]
            if name in objects:
                print(f"Error: Object {name} already exists.")
                exit()
            objects[name] = len(objects)
        elif symbol == '(:objects':
            continue
        elif symbol == '(:action':
            continue
        elif symbol == '(:predicates':
            continue
        elif symbol == '(:constraints':
            continue
        elif symbol == '(:parameters':
            continue
        elif symbol == '(:effect':
            continue
        elif symbol == '(:precondition':
            continue
        else:
            raise Exception(f"Unknown symbol: {symbol}")
    else:
        if symbol.isnumeric():
            continue
        if '_' in symbol:
            name, separator = symbol.split('_', 1)
            if name in objects:
                print(f"Error: Object {name} already exists.")
                exit()
            objects[name] = len(objects)
        else:
            if symbol in objects:
                print(f"Error: Object {symbol} already exists.")
                exit()
            objects[symbol] = len(objects)

for obj in objects.values():
    name = f"{obj:03d}"
    symbols = [f":{name}"] + [f"{name}{i:03d}" for i in range(1, 8)] + [f":{name}n", f":{name}m"]
    for symbol in symbols:
        if symbol in available_symbols:
            if symbol == f":{name}n":
                predicates[name + "n"] = len(predicates)
            elif symbol == f":{name}m":
                predicates[name + "m"] = len(predicates)
            elif symbol == f":{name}":
                actions[name] = len(actions)
            else:
                constraints[name] = len(constraints)

print("OBJECTS")
for obj in objects.values():
    print(f"{obj:03d}: {objects[obj]}")

print()
print("ACTIONS")
for action in actions.values():
    print(f"{action:03d}: {actions[action]}")

print()
print("PREDICATES")
for pred in predicates.values():
    print(f"{pred:03d}: {predicates[pred]}")

print()
print("CONSTRAINTS")
for constraint in constraints.values():
    print(f"{constraint:03d}: {constraints[constraint]}")

available_symbols = sorted(list(available_symbols))

domain = ""
problem = ""

domain_objects = ""
problem_objects = ""

domain_predicates = ""
problem_predicates = ""

domain_constants = ""
problem_constants = ""

print("DOMAIN")
domain_objects = f"""
(:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
"""
for obj in objects.values():
    name = f"{obj:03d}"
    domain_objects += f"""
    ({name})
"""
domain_predicates = f"""
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut)
"""
for pred in predicates.values():
    name = f"{pred:03d}n"
    domain_predicates += f"""
    ({name})
"""
for pred in predicates.values():
    name = f"{pred:03d}m"
    domain_predicates += f"""
    ({name})
"""
domain_constants = ""
for constraint in constraints.values():
    name = f"{constraint:03d}"
    domain_constants += f"""
    ({name})
"""

domain = f"""
(:domain spanner)
({domain_objects
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1505956009.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/164)

--- Test 165/200 ---
Problem: spanner-s4-n3-l5-s1506686026
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
import (re)

# Produce a valid, grounded, totally-ordered plan for the input below.
# <DOMAIN>
# (domain spanner)                    
# (:requirements :typing :strips :constraints)      

# (:types 
#     location locatable - object
#       man nut spanner - locatable   
# )                                           
#                                                                               
# (:predicates 
#       (at?m - locatable?l - location)
#       (carrying?m - man?s - spanner)
#       (useable?s - spanner)
#       (link?l1 - location?l2 - location)
#       (tightened?n - nut)
#       (loose?n - nut))
# (:action walk 
#        (:parameters (?start - location?end - location?m - man))
#        (:precondition (and (at?m?start) 
#                           (link?start?end)))
#        (:effect (and (not (at?m?start)) (at?m?end))))
#
# (:action pickup_spanner 
#        (:parameters (?l - location?s - spanner?m - man))
#        (:precondition (and (at?m?l) 
#                           (at?s?l))
#        (:effect (and (not (at?s?l))
#                     (carrying?m?s))))
#
# (:action tighten_nut 
#        (:parameters (?l - location?s - spanner?m - man?n - nut))
#        (:precondition (and (at?m?l) 
#               (at?n?l)
#               (carrying?m?s)
#               (useable?s)
#               (loose?n))
#        (:effect (and (not (loose?n))(not (useable?s)) (tightened?n))))
# )
# </DOMAIN>

# <PROBLEM>
#  ; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 1506686026 --problem-name spanner-s4-n3-l5-s1506686026
# (define (problem spanner-s4-n3-l5-s1506686026)
#  (:domain spanner)
#  (:objects 
#       bob - man
#       spanner1 spanner2 spanner3 spanner4 - spanner
#       nut1 nut2 nut3 - nut
#       location1 location2 location3 location4 location5 - location
#       shed gate - location
#       )
#  (:init 
#   (at bob shed)
#   (at spanner1 location1)
#   (useable spanner1)
#   (at spanner2 location4)
#   (useable spanner2)
#   (at spanner3 location5)
#   (useable spanner3)
#   (at spanner4 location5)
#   (useable spanner4)
#   (loose nut1)
#   (at nut1 gate)
#   (loose nut2)
#   (at nut2 gate)
#   (loose nut3)
#   (at nut3 gate)
#   (link shed location1)
#   (link location5 gate)
#   (link location1 location2)
#   (link location2 location3)
#   (link location3 location4)
#   (link location4 location5)
#   )
#  (:goal
#   (and
#    (tightened nut1)
#    (tightened nut2)
#    (tightened nut3)
#   )
# )
# (:constraints
#  (and
#    (sometime-before (tightened nut1) (tightened nut2))
#    (forall (?m - man) (at-most-once (at?m shed)))
#   )
#)
# )
#
# ## Planning Rules
# 1) Only use available symbols:
#    - objects declared under PROBLEM :objects, and
#    - constants declared under DOMAIN/PROBLEM :constants (if any).
#    Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.
#
# 2) Constraints:
#    - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
#    - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.
#
# 3) Plan form:
#    - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.
#
# 4) Internal validation before emitting (do not include reasoning in the output):
#    - At each step, all action preconditions hold in the current state.
#    - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
#    - If constraints exist in PROBLEM, ensure the plan satisfies all of them.
#
# ## Output Requirements
# - Return **ONLY** the plan steps, one per line.
# - Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
# - Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
# - No numbering, timestamps, costs, comments, headers, code fences, or extra text.
# - No blank lines at the start or end; no trailing spaces; use a single space between tokens.
# - If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
# - If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`.
#
# ## Examples
# Bad:
# - Plan:
# - Here is the plan:
# - (move a b)  (two actions on one line)
# - (move a) extra
#
# Good:
# (move a b)
# (pick a c)
# (drop a d)
#
# Now produce the final output. Remember: only lines matching the regex.
# ```
# python3 <stdin>
# > --check-safety --no-print --no-timestamp --no-numbering --no-validation --output-format=sequential --output-filename=-- --input-file=/home/fjl2401/Safety-gen/spanner/spanner-generator.py
# (at shed gate)
# (useable spanner1)
# (at location1 spanner1)
# (at gate nut1)
# (loose spanner2)
# (at location4 spanner2)
# (at gate nut2)
# (at gate nut3)
# (tightened spanner1)
# (tightened nut1)
# (tightened nut2)
# (tightened nut3)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
# (at gate nut2)
# (at gate nut1)
# (at gate nut3)
#
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1506686026.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/165)

--- Test 166/200 ---
Problem: spanner-s4-n3-l5-s1512220393
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s1512220393"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)

objects = ""
for obj in available_objects:
    objects += f"{obj} - {obj.lower()}\n"

constraints = spanner_generator.get_constraints(problem_name)
constraints_str = ""
if constraints:
    constraints_str = f"\n:constraints\n{constraints}"

rules = """
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

"""

objects_section = objects + "\n\n"
rules_section = rules + "\n\n"

initial_state = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 1512220393 --problem-name spanner-s4-n3-l5-s1512220393
(define (problem spanner-s4-n3-l5-s1512220393)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location5)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location2)
    (useable spanner3)
    (at spanner4 location4)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location5 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
    (link location4 location5)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
  )
)
)

</PROBLEM>

available_objects = spanner_generator.get_available_objects(problem_name)
objects = ""
for obj in available_objects:
    objects += f"{obj} - {obj.lower()}\n"

constraints = spanner_generator.get_constraints(problem_name)
constraints_str = ""
if constraints:
    constraints_str = f"\n:constraints\n{constraints}"

print(objects_section + objects + rules_section + constraints_str)
```
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1512220393.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/166)

--- Test 167/200 ---
Problem: spanner-s4-n3-l5-s1540157672
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) (at?s?l))
#:effect (and (not (at?s?l)) (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) (at?n?l) (carrying?m?s) (useable?s) (loose?n))
#:effect (and (not (loose?n)) (not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location2)
(useable spanner3)
(at spanner4 location2)
(useable spanner4)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location5 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)

(walk shed location1)
(pickup_spanner location1 spanner1 bob)
(tighten_nut location1 spanner1 bob nut1)
(pickup_spanner location1 spanner2 bob)
(tighten_nut location1 spanner2 bob nut2)
(pickup_spanner location1 spanner3 bob)
(tighten_nut location1 spanner3 bob nut3)
(pickup_spanner location1 spanner4 bob)
(tighten_nut location1 spanner4 bob nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1540157672.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/167)

--- Test 168/200 ---
Problem: spanner-s4-n3-l5-s1560017404
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Symbols, Constraints

# Define domain symbols
domain_symbols = [
    ("man", "spanner", "nut", "location", "shed", "gate"),
    ("bob", "spanner1", "spanner2", "spanner3", "spanner4", "nut1", "nut2", "nut3", "location1", "location2", "location3", "location4", "location5"),
    ("carryng", "useable", "loose", "tightened")
]

# Define problem symbols
problem_symbols = [
    ("bob", "spanner1", "spanner2", "spanner3", "spanner4", "nut1", "nut2", "nut3", "location1", "location2", "location3", "location4", "location5", "shed", "gate"),
    ("at", "carryng", "useable", "loose", "tightened"),
    ("link", "at", "carryng", "useable", "loose", "tightened"),
    ("goal", "at", "tightened")
]

# Define action definitions
actions = {
    "walk": {
        "parameters": ["start", "end", "m"],
        "precondition": ["and", ["at", "m", "shed"], ["link", "shed", "start"]],
        "effect": ["and", ["not", ["at", "m", "start"]], ["at", "m", "end"]]
    },
    "pickup_spanner": {
        "parameters": ["l", "s", "m"],
        "precondition": ["and", ["at", "m", "l"], ["at", "s", "l"]],
        "effect": ["and", ["not", ["at", "s", "l"]], ["carryng", "m", "s"]]
    },
    "tighten_nut": {
        "parameters": ["l", "s", "m", "n"],
        "precondition": ["and", ["at", "m", "l"], ["at", "n", "l"], ["carryng", "m", "s"], ["useable", "s"], ["loose", "n"]],
        "effect": ["and", ["not", ["loose", "n"]], ["not", ["useable", "s"]], ["tightened", "n"]]
    }
}

# Define constraints
constraints = [
    # sometime-before constraint
    {"type": "sometime-before", "p1": "tightened_nut1", "p2": "tightened_nut2"},
    # at-most-once constraint
    {"type": "at-most-once", "p1": "bob", "p2": "shed"}
]

# Create planner
planner = Planner(domain_symbols, problem_symbols, actions, constraints)

# Generate plan
plan = planner.generate_plan()

# Print plan
for step in plan:
    print(f"{step['action']} {step['objects']}")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1560017404.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/168)

--- Test 169/200 ---
Problem: spanner-s4-n3-l5-s1570047118
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ['# -*- mode: python -*-]
(problem spanner-s4-n3-l5-s1570047118)
(:domain spanner)
(:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
(:init 
    (at bob shed)
    (at spanner1 location2)
    (useable spanner1)
    (at spanner2 location4)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (at spanner4 location5)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location5 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
    (link location4 location5)
)
(:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

(appropriate-actions
 (focus nut1)
 (exists (?n - nut) (at?n gate) (tightened?n))
 (exists (?s - spanner) (at?s gate) (useable?s))
 (forall (?s - spanner) (at-most-once (at?s gate)))
 (exists (?m - man) (at?m shed))
 (forall (?m - man) (at-most-once (at?m shed)))
 (exists (?l - location) (link shed?l)) (at-most-once (at bob shed))
 (forall (?l - location) (link shed?l)) (at-most-once (at bob shed))
 (forall (?m - man) (at (?m shed)??l)) (exists (?l - location) (link shed?l)) 

(
  (exists (?m - man) (at (?m shed) location1))
  (exists (?s - spanner) (at?s location1)) (exists (?n - nut) (at?n location1)) 

  (exists (?s - spanner) (at-most-once (at?s location2)))
  (exists (?n - nut) (at-most-once (at?n location1)))
  (exists (?n - nut) (at-most-once (at?n location2)))
  (exists (?s - spanner) (at-most-once (at?s location3)))
  (exists (?s - spanner) (at-most-once (at?s location4)))
  (exists (?s - spanner) (at-most-once (at?s location5)))
  (exists (?n - nut) (at-most-once (at?n location3)))
  (exists (?n - nut) (at-most-once (at?n location4)))
  (exists (?n - nut) (at-most-once (at?n location5)))
)
)

(action-next-nuts 
 (focus nut1)
 (exists (?s - spanner) (at?s gate) (useable?s))
 (exists (?l - location) (link gate location1)) (at-most-once (at bob shed))
 (exists (?l - location) (link gate location5)) (at-most-once (at bob shed))
 (exists (?m - man) (at-most-once (at bob shed)))
 (exists (?s - spanner) (at-most-once (at?s location2)))
 (exists (?n - nut) (at-most-once (at?n location2)))
 (exists (?s - spanner) (at-most-once (at?s location4)))
 (exists (?n - nut) (at-most-once (at?n location4)))
 (exists (?s - spanner) (at-most-once (at?s location5)))
 (exists (?n - nut) (at-most-once (at?n location5)))
 (exists (?m - man) (at-most-once (at bob shed)))
 (exists (?n - nut) (at-most-once (at nut1 gate)))
 (exists (?s - spanner) (at-most-once (at spanner1 location2)))
 (exists (?s - spanner) (at-most-once (at spanner2 location4)))
 (exists (?s - spanner) (at-most-once (at spanner3 location4)))
 (exists (?s - spanner) (at-most-once (at spanner4 location5)))
 (exists (?n - nut) (at-most-once (at nut2 gate)))
 (exists (?s - spanner) (at-most-once (at spanner1 location2)))
 (exists (?s - spanner) (at-most-once (at spanner2 location4)))
 (exists (?s - spanner) (at-most-once (at spanner3 location4)))
 (exists (?s - spanner) (at-most-once (at spanner4 location5)))
 (exists (?n - nut) (at-most-once (at nut3 gate)))
 (exists (?s - spanner) (at-most-once (at spanner1 location2)))
 (exists (?s - spanner) (at-most-once (at spanner2 location4)))
 (exists (?s - spanner) (at-most-once (at spanner3 location4)))
 (exists (?s - spanner) (at-most-once (at spanner4 location5)))
)

(available-nuts 
 (focus nut1)
 (exists (?s - spanner) (at?s gate) (useable?s))
 (exists (?l - location) (link gate location1)) (at-most-once (at bob shed))
 (exists (?l - location) (link gate location5)) (at-most-once (at bob shed))
 (exists (?m - man) (at-most-once (at bob shed)))
 (exists (?n - nut) (at?n gate)) (forall (?n - nut) (at-most-once (at?n gate)))
 (exists (?s - spanner) (at-most-once (at?s location2))) (forall (?s - spanner) (at-most-once (at?s location2)))
 (exists (?s - spanner) (at-most-once (at?s location4))) (forall (?s - spanner) (at-most-once (at?s location4)))
 (exists (?s - spanner) (at-most-once (at?s location5))) (forall (?s - spanner) (at-most-once (at?s location5)))
 (exists (?m - man) (at-most-once (at bob shed))) (forall (?m - man) (at-most-once (at bob shed)))
 (exists (?n - nut) (at-most-once (at nut1 gate))) (forall (?n - nut) (at-most-once (at nut1 gate)))
 (exists (?s - spanner) (at-most-once (at spanner1 location2))) (forall (?s - spanner) (at-most-once (at spanner1 location2)))
 (exists (?s - spanner) (at-most-once (at spanner2 location4))) (forall (?s - spanner) (at-most-once (at spanner2 location4)))
 (exists (?s - spanner) (at-most-once (at spanner3 location4))) (forall (?s - spanner) (at-most-once (at spanner3 location4)))
 (exists (?s - spanner) (at-most-once (at spanner4 location5))) (forall (?s - spanner) (at-most-once (at spanner4 location5)))
 (exists (?n - nut) (at-most-once (at nut2 gate))) (forall (?n - nut) (at-most-once (at nut2 gate)))
 (exists (?s - spanner) (at-most-once (at spanner1 location2))) (forall (?s - spanner) (at-most-once (at spanner1 location2)))
 (exists (?s - spanner) (at-most-once (at spanner2 location4))) (forall (?s - spanner) (at-most-once (at spanner2 location4)))
 (exists (?s - spanner) (at-most-once (at spanner3 location4))) (forall (?s - spanner) (at-most-once (at spanner3 location4)))
 (exists (?s - spanner) (at-most-once (at spanner4 location5))) (forall (?s - spanner) (at-most-once (at spanner4 location5)))
 (exists (?n - nut) (at-most-once (at nut3 gate))) (forall (?n - nut) (at-most-once (at nut3 gate)))
 (exists (?s - spanner)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1570047118.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/169)

--- Test 170/200 ---
Problem: spanner-s4-n3-l5-s1591424164
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: Assassinating Mary Poppins and the spanner nut 4-n3-l5
=================================================================
( At every spanner location 
  (walk bob spanner1 spanner2 spanner3 spanner4)
  (at spanner1 spanner3)
  (pickup spanner spanner1 spanner2 spanner3 spanner4)
)( At every nut location 
  (tighten nut nut1 nut2 nut3)
  (at nut1 nut3)
  (pickup nut nut1 nut2 nut3)
)( At every shed gate location 
  (at shed gate)
  (tighten nut1 nut2 nut3)
  (at bob)
  (walk bob shed gate)
  (at shed gate nut1 nut2 nut3)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1591424164.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/170)

--- Test 171/200 ---
Problem: spanner-s4-n3-l5-s1653983428
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s1653983428"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)
print()

problem = "<PROBLEM>"
print(problem)
print()

spanner_generator.generate_spanner_problem(problem_name, domain=domain, problem=problem)

rules = """
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output. Remember: only lines matching the regex. No extra text of any kind.
"""
rules = """
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output. Remember: only lines matching the regex. No extra text of any kind.
"""
validation_rules = """
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output. Remember: only lines matching the regex. No extra text of any kind.
"""

domain_objects = [
    "bob",
    "spanner1",
    "spanner2",
    "spanner3",
    "spanner4",
    "nut1",
    "nut2",
    "nut3",
    "location1",
    "location2",
    "location3",
    "location4",
    "location5",
    "shed",
    "gate"
]

problem_objects = [
    "bob",
    "spanner1",
    "spanner2",
    "spanner3",
    "spanner4",
    "nut1",
    "nut2",
    "nut3",
    "location1",
    "location2",
    "location3",
    "location4",
    "location5",
    "shed",
    "gate"
]

constants = []
constraints = None

try:
    with open("spanner-generator/spanner-generator.py", "r") as f:
        exec(f.read(), {"problem_name": problem_name}, constants)
    with open(f"spanner-generator/spanner-{problem_name}.pddl", "r") as f:
        exec(f.read(), {"domain": domain, "problem": problem}, constants)
    with open(f"spanner-generator/spanner-{problem_name}-constraints.pddl", "r") as f:
        exec(f.read(), {"constraints": constraints}, constants)
except FileNotFoundError:
    print("spanner-generator/spanner-generator.py and spanner-generator/spanner-<problem-name>.pddl must exist.")
    exit(1)

available_symbols = []
for obj in domain_objects + problem_objects:
    if obj not in constants["objects"] and obj not in constants["constants"]:
        available_symbols.append(obj)

if constraints is None:
    print("spanner-generator/spanner-<problem-name>.pddl must contain constraints.")
    exit(1)

if constraints is not None and len(constraints) > 0 and not isinstance(constraints, list):
    print("spanner-generator/spanner-<problem-name>-constraints.pddl must contain a list of constraints.")
    exit(1)

for constraint in constraints:
    if not isinstance(constraint, str):
        print("spanner-generator/spanner-<problem-name>-constraints.pddl must contain only strings.")
        exit(1)

if constraints is not None and len(constraints) > 0:
    for constraint in constraints:
        try:
            if not constraint.startswith("#"):
                raise ValueError(f"spanner-generator/spanner-<problem-name>-constraints.pddl must start with '#' for each constraint.")
            constraint = constraint[1:]
        except IndexError:
            print("spanner-generator/spanner-<problem-name>-constraints.pddl must contain at least one constraint.")
            exit(1
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1653983428.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/171)

--- Test 172/200 ---
Problem: spanner-s4-n3-l5-s1713246634
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import gi

gi.require_version('PDDL3', '1.0')
gi.require_version('PDDL2', '2.0')
from PDDL3 import *
from PDDL2 import *

problem = Problem(name='spanner-s4-n3-l5-s1713246634')
problem.domain = Domain(name='spanner')
problem.objects = ['bob','spanner1','spanner2','spanner3','spanner4', 'nut1', 'nut2', 'nut3', 'location1', 'location2', 'location3', 'location4', 'location5','shed', 'gate']
problem.constants = ['bob','spanner1','spanner2','spanner3','spanner4', 'nut1', 'nut2', 'nut3', 'location1', 'location2', 'location3', 'location4', 'location5','shed', 'gate']
problem.priors = {'bob': AtMostOnce('bob'), 'nut1': SometimeBefore('nut2'), 'nut2': SometimeBefore('nut3')}
problem.action_names = ['walk', 'pickup_spanner', 'tighten_nut']
problem.action_args = [
    (Name('action:walk'), [Name('obj:m')], AtLeastOne('link:start_link')),
    (Name('action:pickup_spanner'), [Name('obj:l')], AtLeastOne('obj:at_link')),
    (Name('action:tighten_nut'), [Name('obj:l')], AtLeastOne('obj:at_link'))
]
problem.object_symbols = {
    'bob': ['obj:m'],
    'nut1': ['obj:nut'],
    'nut2': ['obj:nut'],
    'nut3': ['obj:nut'],
   'shed': ['obj:location'],
    'gate': ['obj:location'],
   'spanner1': ['obj:spanner'],
   'spanner2': ['obj:spanner'],
   'spanner3': ['obj:spanner'],
   'spanner4': ['obj:spanner'],
    'location1': ['obj:location'],
    'location2': ['obj:location'],
    'location3': ['obj:location'],
    'location4': ['obj:location'],
    'location5': ['obj:location']
}
problem.action_types = {
    'walk': Symbol('action:walk'),
    'pickup_spanner': Symbol('action:pickup_spanner'),
    'tighten_nut': Symbol('action:tighten_nut')
}
problem.action_requirements = {
    'walk': ['obj:m', 'link:start_link'],
    'pickup_spanner': ['obj:l', 'obj:at_link'],
    'tighten_nut': ['obj:l', 'obj:at_link']
}
problem.goal_symbols = []
problem.goal_objects = []
problem.constraint_symbols = []
problem.constraint_objects = []
problem.constraint_predicates = []

problem.init = [
    At('bob','shed'),
    At('spanner1', 'location3'),
    Useable('spanner1'),
    At('spanner2', 'location2'),
    Useable('spanner2'),
    At('spanner3', 'location4'),
    Useable('spanner3'),
    At('spanner4', 'location3'),
    Useable('spanner4'),
    At('nut1', 'gate'),
    Loose('nut1'),
    At('nut2', 'gate'),
    Loose('nut2'),
    At('nut3', 'gate'),
    Loose('nut3')
]
problem.goal = []
problem.invariants = []
problem.constraints = [
    SometimeBefore('nut2', 'nut3'),
    AtMostOnce('bob')
]

solution = Plan()
gi.pddl_read_problem(problem, solution)
gi.pddl_solve_problem(problem, solution)

while problem.constraints or problem.goal:
    if problem.constraints:
        gi.pddl_enforce_constraints(problem, solution)
    if problem.goal:
        gi.pddl_make_goal(solution)

while solution.heads_up():
    gi.pddl_remove_head(solution)
    gi.pddl_add_tail(solution)

print(solution.plan)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1713246634.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/172)

--- Test 173/200 ---
Problem: spanner-s4-n3-l5-s1772813654
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import (open)
from (sys) import stdin, stdout,stderr
from (os) import spanner1, spanner2, spanner3, spanner4, nut1, nut2, location1, location2, location3, location4, gate, bob, shed, nut3, gate, spanner1, spanner2, spanner3, spanner4, bob, nut3, gate, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner1, spanner2, spanner3, spanner4, nut3, gate, bob, spanner
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1772813654.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/173)

--- Test 174/200 ---
Problem: spanner-s4-n3-l5-s1788191839
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s1788191839"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)

objects = {}
for obj in available_objects:
    objects[obj] = spanner_generator.get_object_info(problem_name, obj)

constraints = spanner_generator.get_constraints(problem_name)

def validate_plan(state, plan):
    for i in range(len(plan) - 1):
        action = plan[i]
        obj1 = action.args[i]
        obj2 = action.args[i + 1]

        if obj1 not in objects or obj2 not in objects:
            return False

        if action.name not in objects[obj1][action.name + '_available']:
            return False

        if obj1!= objects[obj2][obj2 + '_at_start']:
            if obj2 not in objects[obj1][obj1 + '_objects']:
                return False

        if action.name == 'walk':
            if obj1 == objects[obj2][obj2 + '_at_start']:
                return False
        elif action.name == 'pickup_spanner':
            if obj1 == objects[obj2][obj2 + '_at_start']:
                return False
        elif action.name == 'tighten_nut':
            if obj1 == objects[obj2][obj2 + '_at_start']:
                return False

        if i < len(constraints) and constraints[i]:
            return False

    return True

def generate_plan(state, goal):
    available_actions = {}
    for obj in objects:
        action_name = obj + '_available'
        available_actions[obj] = objects[obj][action_name]

    available_objects = [obj for obj in objects if objects[obj]['at_start']]

    if not available_objects:
        return []

    best_action = None
    best_score = -1

    for obj in available_objects:
        for action_name in objects[obj]['available_actions']:
            action = objects[obj][action_name]
            if action.name == 'walk':
                if state[obj] == 'at_start':
                    score = 1
                else:
                    score = -1
            elif action.name == 'pickup_spanner':
                if state[obj] == 'at_start':
                    score = 1
                else:
                    score = -1
            elif action.name == 'tighten_nut':
                if state[obj] == 'at_start':
                    score = 1
                else:
                    score = -1
            else:
                continue

            if score > best_score:
                best_action = action
                best_score = score

    if best_action is None:
        return []

    new_state = state.copy()
    new_state[best_action.obj] = 'at_start'

    remaining_objects = [obj for obj in objects if obj!= best_action.obj]
    remaining_objects.append(best_action.obj)

    remaining_available_actions = {}
    for obj in remaining_objects:
        action_name = obj + '_available'
        remaining_available_actions[obj] = objects[obj][action_name]

    remaining_available_objects = [obj for obj in remaining_objects if objects[obj]['at_start']]

    if not remaining_available_objects:
        return [best_action]

    best_action = None
    best_score = -1

    for obj in remaining_available_objects:
        for action_name in objects[obj]['available_actions']:
            action = objects[obj][action_name]
            if action.name == goal:
                if state[obj] == 'at_start':
                    score = 1
                else:
                    score = -1
            else:
                continue

            if score > best_score:
                best_action = action
                best_score = score

    if best_action is None:
        return [best_action]

    new_state[best_action.obj] = goal

    return [best_action] + generate_plan(new_state, goal)

available_objects = list(objects.keys())
available_objects.remove('bob')
available_objects.remove('shed')
available_objects.remove('gate')
available_objects.remove('location1')
available_objects.remove('location2')
available_objects.remove('location3')
available_objects.remove('location4')
available_objects.remove('location5')
available_objects.remove('spanner1')
available_objects.remove('spanner2')
available_objects.remove('spanner3')
available_objects.remove('spanner4')
available_objects.remove('nut1')
available_objects.remove('nut2')
available_objects.remove('nut3')

available_objects = spanner_generator.filter_available_objects(available_objects, constraints)

objects = spanner_generator.update_objects_info(available_objects, objects)

state = spanner_generator.init_state(available_objects, objects)

goal = 'tightened_all_nuts'

plan = generate_plan(state, goal)

if validate_plan(state, plan):
    for action in plan:
        obj1 = action.args[0]
        obj2 = action.args[1]
        print(f"{action.name} {obj1} {obj2}")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1788191839.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/174)

--- Test 175/200 ---
Problem: spanner-s4-n3-l5-s1838005993
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: doprav <action-name> <obj1> <obj2>...
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l)
			   (carrying?m?s))
        :effect (and (not (at?s?l))
                     (tightened nut1)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened nut2)))

(at bob shed)
(at spanner1 location2)
(useable spanner1)
(at spanner2 location5)
(useable spanner2)
(at spanner3 location1)
(useable spanner3)
(at spanner4 location4)
(useable spanner4)
(at nut1 gate)
(tightened nut1)
(at nut2 gate)
(tightened nut2)
(link shed location1)
(link location5 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1838005993.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/175)

--- Test 176/200 ---
Problem: spanner-s4-n3-l5-s1855817073
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s1855817073"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)

objects = {}
for obj in available_objects:
    objects[obj] = spanner_generator.get_object_info(problem_name, obj)

constraints = spanner_generator.get_constraints(problem_name)

def validate_plan(state, plan):
    for i in range(len(plan) - 1):
        action = plan[i]
        obj1 = action.args[0]
        obj2 = action.args[1]
        if not (at(obj1, state.get(obj1, [])) and at(obj2, state.get(obj2, [])) and link(state.get(obj1, [None])[0], state.get(obj2, [None])[0])):
            return False
        if action == pickup_spanner and (at(spanner, state.get(spanner, [])[0]) and at(m, state.get(spanner, [None])[1])):
            return False
        if action == tighten_nut and (at(nut, state.get(nut, [])[0]) and at(m, state.get(spanner, [None])[1]) and useable(spanner) and loose(nut)):
            return False
    return True

def is_valid_state(state, goal):
    for obj in objects.keys():
        if obj!= bob and obj!= spanner and obj!= nut and obj!= location and obj!= shed and obj!= gate:
            if at(obj, state.get(obj, [])):
                if obj == bob and not (at(shed, state.get(location, []))):
                    return False
                if obj == spanner and not (at(gate, state.get(location, []))):
                    return False
                if obj == nut and not (at(gate, state.get(location, []))):
                    return False
                if obj == location and not (at(shed, state.get(location, [])) or at(gate, state.get(location, []))):
                    return False
                if obj == shed and not (at(bob, state.get(shed, []))):
                    return False
                if obj == gate and not (at(spanner, state.get(gate, [])) or at(nut, state.get(gate, []))):
                    return False
    for obj in constraints:
        if not (sometime_before(obj, state.get(goal, [])) and at_most_once(at(bob, state.get(shed, [])))):
            return False
    return True

def generate_plan(state, goal):
    available_actions = []
    for obj in objects.keys():
        if obj!= bob and obj!= spanner and obj!= nut and obj!= location and obj!= shed and obj!= gate:
            if at(obj, state.get(obj, [])):
                if obj == bob:
                    available_actions.append((pickup_spanner, obj, m))
                if obj == spanner:
                    available_actions.append((pickup_spanner, obj, m))
                if obj == nut:
                    available_actions.append((tighten_nut, obj, nut))
                if obj == location:
                    available_actions.append((walk, obj, bob))
                if obj == shed:
                    available_actions.append((walk, obj, bob))
                if obj == gate:
                    available_actions.append((walk, obj, bob))
    if not available_actions:
        return None
    available_actions = [action for action in available_actions if is_valid_action(state, action)]
    if not available_actions:
        return None
    best_action = random.choice(available_actions)
    best_state = copy.deepcopy(state)
    best_plan = [best_action]
    while True:
        new_state = copy.deepcopy(best_state)
        new_action = available_actions.pop(random.randint(0, len(available_actions) - 1))
        if not is_valid_state(new_state, goal) or not is_valid_action(new_state, new_action):
            break
        best_state = new_state
        best_plan.append(new_action)
    return best_plan

def solve_problem():
    global problem_name
    spanner_generator.generate_spanner_problem(problem_name)
    domain = "<DOMAIN>"
    problem = "<PROBLEM>"
    print(domain)
    print(problem)
    objects = spanner_generator.get_available_objects(problem_name)
    constants = spanner_generator.get_constants(problem_name)
    available_objects = [obj for obj in objects if obj not in constants]
    objects = {obj: spanner_generator.get_object_info(problem_name, obj) for obj in objects}
    constraints = spanner_generator.get_constraints(problem_name)
    state = {}
    for obj in objects.keys():
        if obj!= bob and obj!= spanner and obj!= nut and obj!= location and obj!= shed and obj!= gate:
            state[obj] = [spanner_generator.get_initial_location(obj)]
        if obj == bob:
            state[obj] = [spanner_generator.get_initial_location(obj)]
        if obj == spanner:
            state[obj] = [spanner_generator.get_initial_location(spanner)]
        if obj == nut:
            state[obj] = [spanner_generator.get_initial_location(nut)]
        if obj == location:
            state[obj] = [spanner_generator.get_initial_location(location)]
        if obj == shed:
            state[obj] = [spanner_generator.get_initial_location(shed)]
        if obj == gate:
            state[obj] = [spanner_generator.get_initial_location(gate)]
    goal = spanner_generator.get_goal(problem_name)
    if constraints:
        goal = spanner_generator.get_goal_with_constraints(problem_name, constraints)
    best_plan = generate_plan(state, goal)
    if best_plan:
        return best_plan
    return None

spanner_generator.generate_spanner_problem(problem_name)
domain = spanner_generator.get_domain(problem_name)
problem = spanner_generator.get_problem(problem_name)
objects = spanner_generator.get_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)
available_objects = [obj for obj in objects if obj not in constants]
objects = {obj: spanner_generator.get_object_info(problem_name, obj) for obj in available_objects}
constraints = spanner_generator.get_constraints(problem_name)
state = spanner_generator.create_initial_state(available_objects, constants, objects, problem)
goal = spanner_generator.get_goal(problem_name)
if constraints:
    goal = spanner_generator.get_goal_with_constraints(problem_name, constraints)
best_plan = spanner_generator.generate_plan(state, goal)
if best_plan:
    spanner_generator.print_plan(best_plan)
else:
    print("NO-PLAN")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1855817073.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/176)

--- Test 177/200 ---
Problem: spanner-s4-n3-l5-s1862259077
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s1862259077"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
constants = spanner_generator.get_available_constants(problem_name)

objects = {}
constants_dict = {}

for obj in available_objects:
    objects[obj] = obj
    constants_dict[obj] = None

for constant in constants:
    constants_dict[constant] = constant

# Define domain objects (man, spanner, nut, location, shed, gate)
objects['bob'] ='man'
objects['spanner1'] ='spanner'
objects['spanner2'] ='spanner'
objects['spanner3'] ='spanner'
objects['spanner4'] ='spanner'
objects['nut1'] = 'nut'
objects['nut2'] = 'nut'
objects['nut3'] = 'nut'
objects['location1'] = 'location'
objects['location2'] = 'location'
objects['location3'] = 'location'
objects['location4'] = 'location'
objects['location5'] = 'location'
objects['shed'] = 'location'
objects['gate'] = 'location'

# Define domain predicates and constants
predicates = {
    'at': '(exists (?obj1 - (man | spanner | nut | location | shed | gate)) (at?obj1?location))',
    'carry': '(exists (?obj - (man | spanner)) (at?obj?location) (holding?spanner))',
    'useable': '(exists (?spanner - (spanner)) (at?spanner?location) (useable?spanner))',
    'link': '(exists (?location1 - (location)) (at?obj?location1) (link?location1?location2))',
    'tightened': '(exists (?nut - (nut)) (at?nut?location) (tightened?nut))',
    'loose': '(exists (?nut - (nut)) (at?nut?location) (loose?nut))',
   'sometime-before': '(foronce (?time) (before?time?t1) (or (and (sometime-before?t1?t2) (equal?t1?time)) (and (sometime-before?t2?t1) (equal?t2?time))))',
    'at-most-once': '(foronce (?obj1 - (man)) (at-most-once (at?obj1?location)))'
}

constants = {
   'shed': '(exists (?location) (link?location shed))',
    'gate': '(exists (?location) (link gate?location))'
}

# Define actions
actions = {
    'walk': {
        'parameters': '(?start-location - (location)) (?end-location - (location)) (?obj - (man | spanner))',
        'precondition': '(and (at?obj?start-location) (link?start-location?end-location))',
        'effect': '(and (not (at?obj?start-location)) (at?obj?end-location))'
    },
    'pickup_spanner': {
        'parameters': '(?start-location - (location)) (?spanner - (spanner)) (?obj - (man))',
        'precondition': '(and (at?obj?start-location) (at?spanner?start-location))',
        'effect': '(and (not (at?spanner?start-location)) (carrying?obj?spanner))'
    },
    'tighten_nut': {
        'parameters': '(?start-location - (location)) (?spanner - (spanner)) (?obj - (man)) (?nut - (nut))',
        'precondition': '(and (at?obj?start-location) (at?nut?start-location) (carrying?obj?spanner) (at?spanner?start-location) (useable?spanner) (loose?nut))',
        'effect': '(and (not (loose?nut)) (not (useable?spanner)) (tightened?nut))'
    }
}

# Produce a valid, grounded, totally-ordered plan for the input below.
available_objects = spanner_generator.get_available_objects(problem_name)
objects = {}
constants = {}
for obj in available_objects:
    objects[obj] = obj
    constants[obj] = None

shed = spanner_generator.get_object_value(objects,'shed')
gate = spanner_generator.get_object_value(objects, 'gate')
bob = spanner_generator.get_object_value(objects, 'bob')
spanner1 = spanner_generator.get_object_value(objects,'spanner1')
spanner2 = spanner_generator.get_object_value(objects,'spanner2')
spanner3 = spanner_generator.get_object_value(objects,'spanner3')
spanner4 = spanner_generator.get_object_value(objects,'spanner4')
nut1 = spanner_generator.get_object_value(objects, 'nut1')
nut2 = spanner_generator.get_object_value(objects, 'nut2')
nut3 = spanner_generator.get_object_value(objects, 'nut3')
location1 = spanner_generator.get_object_value(objects, 'location1')
location2 = spanner_generator.get_object_value(objects, 'location2')
location3 = spanner_generator.get_object_value(objects, 'location3')
location4 = spanner_generator.get_object_value(objects, 'location4')
location5 = spanner_generator.get_object_value(objects, 'location5')

shed_value = spanner_generator.get_constant_value(constants,'shed')
gate_value = spanner_generator.get_constant_value(constants, 'gate')

bob_value = spanner_generator.get_object_value(objects, 'bob')
spanner1_value = spanner_generator.get_object_value(objects,'spanner1')
spanner2_value = spanner_generator.get_object_value(objects,'spanner2')
spanner3_value = spanner_generator.get_object_value(objects,'spanner3')
spanner4_value = spanner_generator.get_object_value(objects,'spanner4')
nut1_value = spanner_generator.get_object_value(objects, 'nut1')
nut2_value = spanner_generator.get_object_value(objects, 'nut2')
nut3_value = spanner_generator.get_object_value(objects, 'nut3')
location1_value = spanner_generator.get_object_value(objects, 'location1')
location2_value = spanner_generator.get_object_value(objects, 'location2')
location3_value = spanner_generator.get_object_value(objects, 'location3')
location4_value = spanner_generator.get_object_value(objects, 'location4')
location5_value = spanner_generator.get_object_value(objects, 'location5')

available_locations = spanner_generator.get_available_object_value(objects, 'location')
shed_location = spanner_generator.get_object_value(available_locations, shed)
gate_location = spanner_generator.get_object_value(available_locations, gate)
bob_location = spanner_generator.get_object_value(available_locations, bob)
spanner1_location = spanner_generator.get_object_value(available_locations, spanner1)
spanner2_location = spanner_generator.get_object_value(available_locations, spanner2)
spanner3_location = spanner_generator.get_object_value(available_locations, spanner3)
spanner4_location = spanner_generator.get_object_value(available_locations, spanner4)
nut1_location = spanner_generator.get_object_value(available_locations, nut1)
nut2_location = spanner_generator.get_object_value(available_locations, nut2)
nut3_location = spanner_generator.get_object_value(available_locations, nut3)
location1_location = spanner_generator.get_object_value(available_locations, location1)
location2_location = spanner_generator.get_object_value(available_locations, location2)
location3_location = spanner_generator.get_object_value(available_locations, location3)
location4_location = spanner_generator.get_object_value(available_locations, location4)
location5_location = spanner_generator.get_object_value(available_locations, location5)

shed_link = spanner_generator.get_constant_value(constants,'shed')
gate_link = spanner_generator.get_constant_value(constants, 'gate')
bob_link = spanner_generator.get_constant_value(constants,'shed')
gate_link = spanner_generator.get_constant_value(constants, 'gate')

shed_before = spanner_generator.get_constant_value(constants, shed_link)
gate_before = spanner_generator.get_constant_value(constants, gate_link)

bob_before_nuts = spanner_generator.get_constant_value(constants, shed_before)
bob_before_spanners = spanner_generator.get_constant_value(constants, gate_before)

spanner_before_nuts = spanner_generator.get_constant_value(constants, shed_before)
spanner_before_spanners = spanner_generator.get_constant_value(constants, gate_before)

nut_before_spanners = spanner_generator.get_constant_value(constants, shed_before)
nut_before_nuts = spanner_generator.get_constant_value(constants, gate_before)

nut1_before_spanner1 = spanner_generator.get_constant_value(constants, spanner_before_spanners)
nut1_before_spanner2 = spanner_generator.get_constant_value(constants, spanner_before_spanners)
nut1_before_spanner3 = spanner_generator.get_constant_value(constants, spanner_before_spanners)
nut1_before_spanner4 = spanner_generator.get_constant_value(constants, spanner_before_spanners)
nut2_before_spanner1 = spanner_generator.get_constant_value(constants, spanner_before_spanners)
nut2_before_spanner2 = spanner_generator.get_constant
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1862259077.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/177)

--- Test 178/200 ---
Problem: spanner-s4-n3-l5-s1872740614
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: # Produce a valid, grounded, totally-ordered plan for the input below.
# <DOMAIN>
# (domain spanner)                    
# (:requirements :typing :strips :constraints)      

# (:types 
#     location locatable - object
#       man nut spanner - locatable   
# )                                           
#                                                                               
# (:predicates 
#       (at?m - locatable?l - location)
#       (carrying?m - man?s - spanner)
#       (useable?s - spanner)
#       (link?l1 - location?l2 - location)
#       (tightened?n - nut)
#       (loose?n - nut)
# )                                                                                           
# (:action walk 
#        :parameters (?start - location?end - location?m - man)
#        :precondition (and (at?m?start) 
#                           (link?start?end))
#        :effect (and (not (at?m?start)) (at?m?end)))

# (:action pickup_spanner 
#        :parameters (?l - location?s - spanner?m - man)
#        :precondition (and (at?m?l) 
#                           (at?s?l))
#        :effect (and (not (at?s?l))
#                     (carrying?m?s)))

# (:action tighten_nut 
#        :parameters (?l - location?s - spanner?m - man?n - nut)
#        :precondition (and (at?m?l) 
#		      	   (at?n?l)
#			   (carrying?m?s)
#			   (useable?s)
#			   (loose?n))
#        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
# )
# </DOMAIN>

# <PROBLEM>
#  ; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 1872740614 --problem-name spanner-s4-n3-l5-s1872740614
# (define (problem spanner-s4-n3-l5-s1872740614)
#  (:domain spanner)
#  (:objects 
#       bob - man
#       spanner1 spanner2 spanner3 spanner4 - spanner
#       nut1 nut2 nut3 - nut
#       location1 location2 location3 location4 location5 - location
#       shed gate - location
#      )
#  (:init 
#   (at bob shed)
#   (at spanner1 location1)
#   (useable spanner1)
#   (at spanner2 location5)
#   (useable spanner2)
#   (at spanner3 location4)
#   (useable spanner3)
#   (at spanner4 location2)
#   (useable spanner4)
#   (loose nut1)
#   (at nut1 gate)
#   (loose nut2)
#   (at nut2 gate)
#   (loose nut3)
#   (at nut3 gate)
#   (link shed location1)
#   (link location5 gate)
#   (link location1 location2)
#   (link location2 location3)
#   (link location3 location4)
#   (link location4 location5)
#  (:goal
#   (and
#    (tightened nut1)
#    (tightened nut2)
#    (tightened nut3)
#   )
#  )
#  (:constraints
#   (and
#     (sometime-before (tightened nut1) (tightened nut2))
#     (forall (?m - man) (at-most-once (at?m shed)))
#   )
#  )
# )
# </PROBLEM>

## Planning Rules
# 1) Only use available symbols:
#    - objects declared under PROBLEM :objects, and
#    - constants declared under DOMAIN/PROBLEM :constants (if any).
#   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

# 2) Constraints:
#    - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
#    - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

# 3) Plan form:
#    - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

# 4) Internal validation before emitting (do not include reasoning in the output):
#   - At each step, all action preconditions hold in the current state.
#   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
#   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
# - Return **ONLY** the plan steps, one per line.
# - Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
# - Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
# - No numbering, timestamps, costs, comments, headers, code fences, or extra text.
# - No blank lines at the start or end; no trailing spaces; use a single space between tokens.
# - If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
# - If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
# Bad:
# - Plan:
# - Here is the plan:
# - (move a b)  (two actions on one line)
# - (move a) extra

# Good:
# (move a b)
# (pick a c)
# (drop a d)

# Now produce the final output.

# shed 
(at :no-such-manchain bob shed)
# No, at bob shed must start the whole plan, because bob must go to shed at the beginning:
#
# (at bob shed)

(at bob shed)
(at spanner1 location1)
(at spanner2 location5)
(at spanner3 location4)
(at spanner4 location2)

(useable spanner1)
(useable spanner2)
(useable spanner3)
(useable spanner4)

(nut1-at-gate)
(nut2-at-gate)
(nut3-at-gate)

(link shed location1)
(link location5 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)

#
# Now validate and generate the plan under the constraints:
#
# 1) bob must go to shed only once, so he cannot be at shed twice:
#
#  (at bob shed)
#
# 2) nut1 and nut2 must be tightened before nut3:
#
#  (tightened-nut1-at-nut1 gate)
#  (tightened-nut2-at-nut2 gate)
#
# 3) bob must go to shed only once:
#
# No action is needed here. At this point, we have validated all constraints and have a grounded plan under PDDL2:
#
# (at bob shed)
# (tightened-nut1-at-nut1 gate)
# (tightened-nut2-at-nut2 gate)
#
# Now generate the plan under PDDL3 constraints:
#
# 1) bob must go to shed at most once:
#
# No action is needed here. At this point, we have validated all constraints and have a grounded plan under PDDL3:
#
# (at bob shed)
# (tightened-nut1-at-nut1 gate)
# (tightened-nut2-at-nut2 gate)
#
# Produce the final grounded totally-ordered plan:
#
# At this point, we have a grounded plan under both PDDL2 and PDDL3, so we can generate the final plan:
#
# (at bob shed)
# (at spanner1 location1)
# (at spanner2 location5)
# (at spanner3 location4)
# (at spanner4 location2)
# (useable spanner1)
# (useable spanner2)
# (useable spanner3)
# (useable spanner4)
# (nut1-at-gate)
# (nut2-at-gate)
# (nut3-at-gate)
# (link shed location1)
# (link location5 gate)
# (link location1 location2)
# (link location2 location3)
# (link location3 location4)
# (link location4 location5)
#
# Now validate the plan under PDDL3 constraints again:
#
# 1) bob must go to shed at most once:
# 2) nut1 and nut2 must be tightened before nut3:
# 3) bob must go to shed only once:
#
# No action is needed here. At this point, we have validated all constraints and have a grounded plan under PDDL3:
#
# (at bob shed)
# (at spanner
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1872740614.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/178)

--- Test 179/200 ---
Problem: spanner-s4-n3-l5-s1950252568
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: ```python
(walk shed location1)
(pick spanner1 location1)
(tighten_nut shed spanner1 nut1)
(walk shed)
(pick spanner2 location3)
(tighten_nut shed spanner2 nut2)
(walk shed)
(pick spanner3 location2)
(tighten_nut shed spanner3 nut3)
(walk shed)
(pick spanner4 location4)
(tighten_nut shed spanner4 nut1)
```
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1950252568.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/179)

--- Test 180/200 ---
Problem: spanner-s4-n3-l5-s1973506333
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) (at?s?l))
#:effect (and (not (at?s?l)) (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) (at?n?l) (carrying?m?s) (useable?s) (loose?n))
#:effect (and (not (loose?n)) (not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location1)
(useable spanner1)
(at bob shed)
(at spanner2 location4)
(useable spanner2)
(at spanner3 location1)
(useable spanner3)
(at spanner4 location4)
(useable spanner4)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)
(link gate location5)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s1973506333.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/180)

--- Test 181/200 ---
Problem: spanner-s4-n3-l5-s203819550
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: (#) `<pickup_spanner shed spanner1 location1>
<pickup_spanner shed spanner2 location1>
<pickup_spanner shed spanner3 location3>
<tighten_nut location1 spanner1 gate nut1>
<tighten_nut location1 spanner2 gate nut2>
<tighten_nut location1 spanner3 gate nut3>
</pickup_spanner>
</tighten_nut>`
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s203819550.soln
âœ— Invalid solution: Validation failed: Type-checking walk
...action passes type checking.
Type-checking pickup_spanner
...action passes type checking.
Type-checking tighten_nut
...action passes type checking.
Checking plan: /tmp/2317655.1.gpu/tmp81tzpdyd.soln
#Bad plan description!


Failed plans:
 /tmp/2317655.1.gpu/tmp81tzpdyd.soln 

Current success rate: 0.0% (0/181)

--- Test 182/200 ---
Problem: spanner-s4-n3-l5-s2123980499
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Define the domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 2123980499 --problem-name spanner-s4-n3-l5-s2123980499
(define (problem spanner-s4-n3-l5-s2123980499)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location2)
    (useable spanner1)
    (at spanner2 location1)
    (useable spanner2)
    (at spanner3 location1)
    (useable spanner3)
    (at spanner4 location3)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location5 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
    (link location4 location5)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Define the constraints
constraints = [
    (sometime-before, (tightened, nut1), (tightened, nut2)),
    (at-most-once, (at, bob, shed))
]

# Create a Planner object
planner = Planner(domain, problem, constraints)

# Produce a valid, grounded, totally-ordered plan
plan = planner.plan()

# Validate the plan (not shown in the output)
planner.validate(plan)

# Output the plan
for step in plan:
    print(f"{step})")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s2123980499.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/182)

--- Test 183/200 ---
Problem: spanner-s4-n3-l5-s22057207
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location3)
(useable spanner1)
(at bob shed)
(at spanner2 location4)
(useable spanner2)
(at spanner2 location4)
(at spanner3 location1)
(useable spanner3)
(at spanner3 location1)
(at spanner4 location3)
(useable spanner4)
(at spanner4 location3)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s22057207.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/183)

--- Test 184/200 ---
Problem: spanner-s4-n3-l5-s26730043
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s26730043"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)

objects = ""
for obj in available_objects:
    objects += f"{obj} - {obj.lower()}\n"

constraints = spanner_generator.get_constraints(problem_name)
constraints_str = ""
if constraints:
    constraints_str = f"\n:constraints\n{constraints}"

init_str = ""
obj_init = spanner_generator.get_obj_init(available_objects, constants, problem_name)
for obj in obj_init:
    init_str += f"(at {obj}?loc)\n"
    init_str += f"(holdable?obj)\n"
    init_str += f"(link?loc1?loc2)\n"
    init_str += f"(connect?obj?loc?loc1)\n"
    init_str += f"(useable?obj)\n"
    init_str += f"(tightened?nut)\n"
    init_str += f"(loose?nut)\n\n"

goal_str = ""
goal_obj = spanner_generator.get_goal_obj(available_objects, constants, problem_name)
goal_str += f"(goal)\n"
goal_str += f"(at {goal_obj}?loc)\n"
goal_str += f"(tightened?nut)\n"
goal_str += f"(tightened?nut2)\n"
goal_str += f"(tightened?nut3)\n\n"

predicates = """
(:predicates 
locationable?locatable 
	- locatable
man?man 
	- locatable
spanner?spanner 
	- locatable
useable?useable 
	- spanner
at?at 
	-locationatable
link?link1?link2 
	-locationlocationable
tightened?tightened 
	-nut
loose?loose 
	-nut
"""

actions = """
(:actions 
walk 
	-locationlocationable 
	-man 
	-location?start?end 
	:precondition (and (at?m?start) (link?start?end))
	:effect (and (not (at?m?start)) (at?m?end))
pick spanner 
	-locationlocationable 
	-man 
	-spanner 
	:precondition (and (at?m?l) (at?s?l)) 
	:effect (and (not (at?s?l)) (carrying?m?s))
tighten_nut 
	-locationlocationable 
	-man 
	-spanner 
	-nut 
	:precondition (and (at?m?l) (at?n?l) (carrying?m?s) (useable?s) (loose?n)) 
	:effect (and (not (loose?n)) (not (useable?s)) (tightened?n))
"""

rules = f"""
(:rules 
  {domain}
  {problem}
  {objects}
  {constraints_str}
  {init_str}
  {goal_str}
  {predicates}
  {actions}
  (:constraints 
    (and 
      (sometime-before (tightened nut2) (tightened nut3))
    )
  )
"""

print(rules)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s26730043.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/184)

--- Test 185/200 ---
Problem: spanner-s4-n3-l5-s439249873
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: <=>
(aunt) -- locatable ; man ; spanner ; nut
(location-1) -- location -- (link-to location-1 location-2)
(location-2) -- location -- (link-to location-1 location-2)
(location-3) -- location -- (link-to location-2 location-3)
(location-4) -- location -- (link-to location-3 location-4)
(location-5) -- location -- (link-to location-4 location-5)
(bob) -- (at location-1) -- (carrying spanner1)
(spanner1) -- (at location-2) -- (useable)
(nut1) -- (at location-5) -- (loose)
(gate) -- (link-to location-5 gate) -- (at gate) -- (at bob)
=> TightenNut(nut1 gate bob)
(aunt) -- locatable ; man ; spanner ; nut
(location-1) -- location -- (link-to location-1 location-2)
(location-2) -- location -- (link-to location-1 location-2)
(location-3) -- location -- (link-to location-2 location-3)
(location-4) -- location -- (link-to location-3 location-4)
(location-5) -- location -- (link-to location-4 location-5)
(bob) -- (at location-1) -- (at gate) -- (at location-5) -- (at bob) -- (at gate) -- (tightened nut1) -- (at nut1) -- (at gate) -- (at bob) -- (at nut1) -- (at gate) -- (tightened nut2) -- (at nut2) -- (at gate) -- (at bob) -- (at nut2) -- (at gate) -- (tightened nut3) -- (at nut3) -- (at gate) -- (at bob) -- (at nut3) -- (at gate) -- (at nut1) -- (at gate) -- (at bob) -- (tightened spanner1) -- (at spanner1) -- (at location-5) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner1) -- (at location-5) -- (at nut1) -- (tightened spanner2) -- (at spanner2) -- (at location-4) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner2) -- (at location-4) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner2) -- (at location-4) -- (at nut1) -- (at gate) -- (tightened spanner3) -- (at spanner3) -- (at location-2) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-2) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-2) -- (at nut1) -- (at gate) -- (tightened spanner4) -- (at spanner4) -- (at location-3) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner4) -- (tightened nut2) -- (at nut2) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut1) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut2) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (tightened spanner3) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner3) -- (at location-4) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-3) -- (at nut3) -- (at gate) -- (at bob) -- (at spanner4) -- (at location-4) -- (at nut3) -- (at
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s439249873.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/185)

--- Test 186/200 ---
Problem: spanner-s4-n3-l5-s562073928
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) (at?s?l))
#:effect (and (not (at?s?l)) (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) (at?n?l) (carrying?m?s) (useable?s) (loose?n))
#:effect (and (not (loose?n)) (not (useable?s)) (tightened?n)))
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s562073928.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/186)

--- Test 187/200 ---
Problem: spanner-s4-n3-l5-s595893792
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [];

(once (
  (at?m shed)
  (link shed location1))
  every 
  (at?m location1)
  (pickup spanner bob location1 spanner1)
  (tighten nut bob location1 nut1 gate)
  (at gate nut3)
  (at location1 spanner4)
  (at gate spanner1)
  (at spanner1 nut3)
  (at gate spanner2)
  (at spanner2 spanner3)
  (at spanner3 nut3)
  (at spanner4 nut2)
  (at gate spanner4)
  (at spanner4 spanner1)
  (at spanner1 spanner2)
  (at gate spanner2)
  (at spanner2 spanner3)
  (at spanner3 spanner4)
  (at spanner4 spanner1)
  (at gate spanner1)
  (at spanner1 nut3)
  (at gate spanner2)
  (at spanner2 spanner3)
  (at spanner3 spanner4)
  (at gate spanner4)
  (at spanner4 spanner1)
  (at gate spanner1)
  (tightened nut1)
  (tightened nut2)
  (tightened nut3)
) (not (at gate any)) (not (at spanner2 nut1)) (not (at spanner2 nut2)) (not (at spanner3 nut1)) (not (at spanner3 nut2)) (not (at spanner4 nut1)) (not (at spanner4 nut2)) (not (at spanner4 nut3)) (not (at spanner4 spanner1)) (not (at spanner4 spanner2)) (not (at spanner4 spanner3)) (not (at spanner4 spanner4)) (not (at gate spanner1)) (not (at gate spanner2)) (not (at gate spanner3)) (not (at gate spanner4)) (at bob shed) (at nut3 gate) (at spanner1 location4) (at spanner3 location5) (useable spanner1) (useable spanner3) (at nut1 gate) (at nut2 gate) (at nut3 gate) (link shed location1) (link location5 gate) (link location1 location2) (link location2 location3) (link location3 location4) (link location4 location5) (tightened nut1) (tightened nut2) (tightened nut3))) = No-Plan
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s595893792.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/187)

--- Test 188/200 ---
Problem: spanner-s4-n3-l5-s61408799
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s61408799"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)

objects = ""
for obj in available_objects:
    objects += f"{obj} - {available_objects[available_objects.index(obj)]}\n"

constraints = spanner_generator.get_constraints(problem_name)
constraints_str = ""
if constraints:
    constraints_str = f"(:constraints\n{constraints}\n)"

print(f":objects\n{objects}\n:constants\n{constants}\n{constraints_str}\n")

objects = objects.replace("\n:objects\n", "").replace("\n", "\n:objects\n")
constraints_str = constraints_str.replace("\n:constraints\n", "").replace("\n", "\n:constraints\n")

print(f"<DOMAIN>\n(define (domain spanner)\n(:requirements :typing :strips :constraints)\n(:types\n location locatable - object\n man nut spanner - locatable\n)\n(:predicates \n (at?m - locatable?l - location)\n (carrying?m - man?s - spanner)\n (useable?s - spanner)\n (link?l1 - location?l2 - location)\n (tightened?n - nut)\n (loose?n - nut))\n(:action walk \n :parameters (?start - location?end - location?m - man)\n :precondition (and (at?m?start) (link?start?end))\n :effect (and (not (at?m?start)) (at?m?end))\n(:action pickup_spanner \n :parameters (?l - location?s - spanner?m - man)\n :precondition (and (at?m?l) (at?s?l))\n :effect (and (not (at?s?l)) (carrying?m?s))\n(:action tighten_nut \n :parameters (?l - location?s - spanner?m - man?n - nut)\n :precondition (and (at?m?l) (at?n?l) (carrying?m?s) (useable?s) (loose?n))\n :effect (and (not (loose?n)) (not (useable?s)) (tightened?n)))\n)</DOMAIN>\n\n<PROBLEM>\n(define (problem spanner-s4-n3-l5-s61408799)\n(:domain spanner)\n(:objects\n bob spanner1 spanner2 spanner3 spanner4 nut1 nut2 nut3 - spanner nut\n location1 location2 location3 location4 location5 gate - location\n :constants\n\n)\n(:init \n (at bob location1)\n (at spanner1 location2)\n (useable spanner1)\n (at spanner2 location1)\n (useable spanner2)\n (at spanner3 location4)\n (useable spanner3)\n (at spanner4 location3)\n (useable spanner4)\n (loose nut1)\n (at nut1 gate)\n (loose nut2)\n (at nut2 gate)\n (loose nut3)\n (at nut3 gate)\n (link location5 gate)\n (link location1 location2)\n (link location2 location3)\n (link location3 location4)\n (link location4 location5)\n (:goal\n (and (tightened nut1) (tightened nut2) (tightened nut3))\n (:constraints\n (and (sometime-before (tightened nut1) (tightened nut2))) (forall (?m - man) (at-most-once (at?m location5)))\n)\n)</PROBLEM>\n\n## Planning Rules\n1) Only use available symbols:\n  - objects declared under PROBLEM :objects,\n  - constants declared under DOMAIN/PROBLEM :constants (if any).\n  Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.\n\n2) Constraints:\n  - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.\n  - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.\n\n3) Plan form:\n  - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.\n\n4) Internal validation before emitting (do not include reasoning in the output):\n  - At each step, all action preconditions hold in the current state.\n  - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.\n  - If constraints exist in PROBLEM, ensure the plan satisfies all of them.\n\n## Output Requirements\n- Return **ONLY** the plan steps, one per line.\n- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`\n- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).\n- No numbering, timestamps, costs, comments, headers, code fences, or extra text.\n- No blank lines at the start or end; no trailing spaces; use a single space between tokens.\n- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).\n- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`.\n\n## Examples\nBad:\n\n(merge a b)\n\n(merge a)\n\nNow produce the final output. Remember: only lines matching the regex. No extra text of any kind.\n"""
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s61408799.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/188)

--- Test 189/200 ---
Problem: spanner-s4-n3-l5-s620441193
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s620441193"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)

objects = ""
for obj in available_objects:
    objects += f"{obj} - {obj.lower()}\n"

constraints = spanner_generator.get_constraints(problem_name)
constraints_str = ""
if constraints:
    constraints_str = f"\n:constraints\n{constraints}"

init_str = ""
obj_init = spanner_generator.get_obj_init(available_objects, constants)
for obj in obj_init:
    obj_init_str += f"(at {obj}?loc)\n"
init_str += f"{objects}{constraints_str}{obj_init_str}"

goal_str = ""
obj_goal = spanner_generator.get_obj_goal(available_objects, constants)
for obj in obj_goal:
    obj_goal_str += f"(tightened?nut_{obj})\n"
goal_str += f"\n:goal\n{init_str}\n{goal_str}"

print(goal_str)

available_actions = spanner_generator.get_available_actions(problem_name)
action_names = spanner_generator.get_action_names(problem_name)

actions = ""
for action in available_actions:
    action_name = f"{action['name']}"
    if action['name'] in action_names:
        preconditions = spanner_generator.get_action_preconditions(action_name, problem_name)
        obj_args = spanner_generator.get_obj_args(action_name, problem_name)
        args_str = ""
        for i, arg in enumerate(obj_args):
            if i > 0:
                args_str += f"?obj_{i}"
            args_str += f" ({arg['name']})"
        effect = spanner_generator.get_action_effect(action_name, problem_name)
        effect_str = ""
        if effect:
            if effect == "remove":
                effect_str += f"(not (at?obj_1))\n"
            elif effect == "add":
                effect_str += f"(at?obj_1)\n"
            else:
                effect_str += f"(at?obj_1) (not (at?obj_2))\n"
        action_str = f"(:action {action_name}\n"
        action_str += f" :parameters (\n"
        action_str += f"?loc?obj_1 {args_str}\n"
        action_str += f" )\n"
        action_str += f" :precondition (and\n"
        action_str += f" (at?obj_1) (link?loc?loc_2)\n"
        action_str += f" (exists (?obj_2) (and (at?obj_2) (not (at?obj_1)) (link?loc_2?loc_1)))\n"
        action_str += f" )\n"
        action_str += f" :effect\n"
        action_str += f" {effect_str}\n"
        actions += f"{action_str}\n"

print(actions)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s620441193.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/189)

--- Test 190/200 ---
Problem: spanner-s4-n3-l5-s646739284
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s646739284"
spanner_generator.generate_spanner_problem(problem_name)
domain = spanner_generator.get_domain(problem_name)
problem = spanner_generator.get_problem(problem_name)

objects = problem.objects
constants = spanner_generator.get_constants(domain, problem)

available_objects = []
for obj in objects:
    if spanner_generator.is_available(domain, problem, obj):
        available_objects.append(obj)

available_actions = []
for action in spanner_generator.get_available_actions(domain, problem):
    if spanner_generator.is_available(domain, problem, action):
        available_actions.append(action)

available_objects_and_actions = list(set(available_objects + available_actions))

constraints = spanner_generator.get_constraints(problem)
if constraints:
    valid_plan = spanner_generator.validate_plan(domain, problem, constraints, available_objects_and_actions)
else:
    valid_plan = spanner_generator.validate_goal_directed(domain, problem, available_objects_and_actions)

if valid_plan:
    spanner_generator.generate_plan(domain, problem, constraints, available_objects_and_actions)
else:
    print("NO-PLAN")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s646739284.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/190)

--- Test 191/200 ---
Problem: spanner-s4-n3-l5-s66042071
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s66042071"
spanner_generator.generate_spanner_problem(problem_name)

domain = "<DOMAIN>"
print(domain)

problem = "<PROBLEM>"
print(problem)

available_objects = spanner_generator.get_available_objects(problem_name)
constants = spanner_generator.get_constants(problem_name)

objects = ""
for obj in available_objects:
    objects += f"{obj} - {obj.lower()}\n"

constraints = spanner_generator.get_constraints(problem_name)
constraints_str = ""
if constraints:
    constraints_str = f"\n:constraints\n{constraints}"

init_str = ""
obj_init = spanner_generator.get_obj_init(available_objects, constants)
for obj in obj_init:
    obj_init_str += f"(at {obj}?loc)\n"
init_str += f"(:init\n{obj_init_str}\n):init\n"

goal_str = ""
obj_goal = spanner_generator.get_obj_goal(available_objects, constants)
for obj in obj_goal:
    obj_goal_str += f"(at {obj}?loc)\n"
goal_str += f"(:goal\n{obj_goal_str}\n):goal\n"

constraints_str += f"\n:constraints\n{constraints_str}"

typing = "<TYING>"
tying = spanner_generator.get_typing(available_objects, constants)
for obj in tying:
    obj_tying = spanner_generator.get_obj_tying(obj, available_objects, constants)
    typing_str += f"(typing {obj} {obj_tying})\n"
tying_str += f":typing\n{typing_str}\n:typing\n{tying_str}"

strips = "<STRIPS>"
strips_obj = spanner_generator.get_strips_obj(available_objects, constants)
strips_str = f":strips\n(forall (?obj?loc) (at?obj?loc))\n(forall (?obj?goal_loc) (not (at?obj?goal_loc)))\n(forall (?action) (exists (?pre_loc) (at?action?pre_loc)))\n(forall (?action?pre_loc?obj) (exists (?success_loc) (and (not (at?action?pre_loc)) (at?action?success_loc)) (equals (distance?pre_loc?success_loc) 1)))\n:strips\n{strips_str}"

links = "<LINKS>"
links_obj = spanner_generator.get_links_obj(available_objects, constants)
links_str = f":links\n(forall (?l?loc1?l_loc2) (at?l?l_loc2) (link?l_loc2?l_loc1?loc1))\n:links\n{links_str}"

strips_constraints = spanner_generator.get_strips_constraints(constraints)
strips_constraints_str = f"\n:stripsconstraints\n{strips_constraints}\n"

typing_constraints = spanner_generator.get_typing_constraints(constraints)
typing_constraints_str = f"\n:typingconstraints\n{typing_constraints}\n"

links_constraints = spanner_generator.get_links_constraints(constraints)
links_constraints_str = f"\n:linksconstraints\n{links_constraints}\n"

constraints_str += f"\n:constraints\n{constraints_str}\n:stripsconstraints\n{strips_constraints_str}\n:typingconstraints\n{typing_constraints_str}\n:linksconstraints\n{links_constraints_str}\n"

rules = """
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.
"""

print(f"<DOMAIN>\n{domain}\n\n<PROBLEM>\n{problem}\n\n# Problem: {problem_name}\n\n## Objects\n", objects, constraints_str, "\n## Initial State\n", init_str, "\n## Goals\n", goal_str, "\n## Constraints\n", strips_constraints_str, typing_constraints_str, links_constraints_str, "\n## Rules\n", rules, "\n\n## Generation\n", spanner_generator.generate_spanner_plan(problem_name)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s66042071.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/191)

--- Test 192/200 ---
Problem: spanner-s4-n3-l5-s728337100
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: [(pickup_spanner 
        (link location1 location2)
        (at bob location1)
        (at spanner4 location1)
        (at nut3 gate))
 
 (tighten_nut 
        (link location1 location2)
        (at bob location1)
        (at nut3 gate)
        (at spanner4 location1)
        (at spanner1 location2)
        (at nut3 location1)
        (useable spanner4)
        (loose nut3))]
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s728337100.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/192)

--- Test 193/200 ---
Problem: spanner-s4-n3-l5-s828270542
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Define the domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 828270542 --problem-name spanner-s4-n3-l5-s828270542
(define (problem spanner-s4-n3-l5-s828270542)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location4)
    (useable spanner1)
    (at spanner2 location4)
    (useable spanner2)
    (at spanner3 location2)
    (useable spanner3)
    (at spanner4 location3)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location5 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
    (link location4 location5)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Define the constraints
constraints = [
    (sometime-before, (tightened, nut2), (tightened, nut3)),
    (at-most-once, (at, bob, shed))
]

# Create a Planner object
planner = Planner(domain, problem, constraints)

# Produce a valid grounded plan
plan = planner.plan()

# Validate the plan (not shown in the output)

# Output the plan
for step in plan:
    print(f"{step})")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s828270542.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/193)

--- Test 194/200 ---
Problem: spanner-s4-n3-l5-s830888557
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Define the domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 830888557 --problem-name spanner-s4-n3-l5-s830888557
(define (problem spanner-s4-n3-l5-s830888557)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location5)
    (useable spanner1)
    (at spanner2 location4)
    (useable spanner2)
    (at spanner3 location5)
    (useable spanner3)
    (at spanner4 location1)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location5 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
    (link location4 location5)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Define the constraints
constraints = [
    (sometime-before, (tightened, nut2), (tightened, nut3)),
    (at-most-once, (at, bob, shed))
]

# Create a Planner object
planner = Planner(domain, problem, constraints)

# Generate a plan
plan = planner.generate_plan()

# Print the plan
for step in plan:
    print(step)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s830888557.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/194)

--- Test 195/200 ---
Problem: spanner-s4-n3-l5-s833024935
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s833024935"
spanner_generator.generate_spanner_problem(problem_name)
domain = spanner_generator.get_domain(problem_name)
problem = spanner_generator.get_problem(problem_name)

objects = problem.objects
constants = spanner_generator.get_constants(domain, problem)

available_objects = []
for obj in objects:
    if spanner_generator.is_available(domain, problem, obj):
        available_objects.append(obj)

available_actions = []
for action in spanner_generator.get_available_actions(domain, problem):
    if spanner_generator.is_available(domain, problem, action):
        available_actions.append(action)

print("Producing spanner-s4-n3-l5-s833024935 plan...")

# Generate the initial state
initial_state = spanner_generator.generate_initial_state(domain, problem, objects, constants, available_objects, available_actions)

# Find the goal state
goal_state = spanner_generator.generate_goal_state(domain, problem, objects, constants, available_objects, available_actions)

# Perform planning
plan = spanner_generator.plan(domain, problem, objects, constants, available_objects, available_actions, initial_state, goal_state)

# Validate the plan
spanner_generator.validate_plan(domain, problem, objects, constants, available_objects, available_actions, plan)

# Generate the output
output = spanner_generator.generate_output(domain, problem, objects, constants, available_objects, available_actions, plan)

# Print the output
for line in output:
    print(line)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s833024935.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/195)

--- Test 196/200 ---
Problem: spanner-s4-n3-l5-s840629724
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) (at?s?l))
#:effect (and (not (at?s?l)) (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) (at?n?l) (carrying?m?s) (useable?s) (loose?n))
#:effect (and (not (loose?n)) (not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location5)
(useable spanner1)
(at spanner2 location5)
(useable spanner2)
(at spanner3 location4)
(useable spanner3)
(at spanner4 location4)
(useable spanner4)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location5 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s840629724.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/196)

--- Test 197/200 ---
Problem: spanner-s4-n3-l5-s859608426
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: from pyplanner import Planner, Constraints

# Define the domain and problem
domain = """
<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 859608426 --problem-name spanner-s4-n3-l5-s859608426
(define (problem spanner-s4-n3-l5-s859608426)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location2)
    (useable spanner1)
    (at spanner2 location2)
    (useable spanner2)
    (at spanner3 location3)
    (useable spanner3)
    (at spanner4 location1)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location5 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
    (link location4 location5)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut1) (tightened nut2))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

# Define the constraints
constraints = [
    (sometime-before, (tightened, nut1), (tightened, nut2)),
    (at-most-once, (at, bob, shed))
]

# Create a Planner object
planner = Planner(domain, problem, constraints)

# Produce a valid grounded plan
plan = planner.plan()

# Print the plan
for step in plan:
    print(step)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s859608426.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/197)

--- Test 198/200 ---
Problem: spanner-s4-n3-l5-s888590789
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: import spanner_generator

problem_name = "spanner-s4-n3-l5-s888590789"
shed, bob, spanner1, spanner2, spanner3, spanner4, nut1, nut2, nut3, location1, location2, location3, location4, location5, gate = spanner_generator.generate_problem(problem_name)

init_state = spanner_generator.initialize_state(bob, shed, spanner1, spanner2, spanner3, spanner4, nut1, nut2, nut3, location1, location2, location3, location4, location5, gate)

available_actions = spanner_generator.get_available_actions(init_state)

def validate_step(current_state, action):
    if not spanner_generator.validate_action_preconditions(current_state, action):
        return False
    return spanner_generator.validate_action_effects(current_state, action)

def solve_problem():
    current_state = init_state
    goal_reached = spanner_generator.check_goal_reached(current_state)
    plan = []

    while not goal_reached:
        best_action = spanner_generator.find_best_action(current_state, available_actions)
        if best_action is None:
            return []  # No more available actions

        if spanner_generator.is_last_step(best_action, current_state, available_actions):
            goal_reached = spanner_generator.check_goal_reached(current_state)
        else:
            current_state = spanner_generator.apply_action(current_state, best_action)
            plan.append(best_action)

    return plan

plan = solve_problem()

if spanner_generator.is_valid_plan(plan, spanner_generator.init_state, spanner_generator.available_objects):
    spanner_generator.print_plan(plan)
else:
    print("NO-PLAN")
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s888590789.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/198)

--- Test 199/200 ---
Problem: spanner-s4-n3-l5-s953059307
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: #:action walk 
#:parameters (?start - location?end - location?m - man)
#:precondition (and (at?m?start) 
                     (link?start?end))
#:effect (and (not (at?m?start)) (at?m?end)))

#:action pickup_spanner 
#:parameters (?l - location?s - spanner?m - man)
#:precondition (and (at?m?l) 
                       (at?s?l))
#:effect (and (not (at?s?l))
                 (carrying?m?s)))

#:action tighten_nut 
#:parameters (?l - location?s - spanner?m - man?n - nut)
#:precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
#:effect (and (not (loose?n))(not (useable?s)) (tightened?n)))

(at bob location1)
(carrying spanner1)
(at spanner1 location4)
(useable spanner1)
(at bob shed)
(at spanner2 location2)
(useable spanner2)
(at spanner3 location3)
(useable spanner3)
(at spanner4 location4)
(useable spanner4)
(at nut1 gate)
(loose nut1)
(at nut2 gate)
(loose nut2)
(at nut3 gate)
(loose nut3)

(link shed location1)
(link location5 gate)
(link location1 location2)
(link location2 location3)
(link location3 location4)
(link location4 location5)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s953059307.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/199)

--- Test 200/200 ---
Problem: spanner-s4-n3-l5-s95513942
Raw output (first 500 chars): <|begin_of_text|><|start_header_id|>system<|end_header_id|>

Cutting Knowledge Date: December 2023
Today Date: 01 Nov 2025

<|eot_id|><|start_header_id|>user<|end_header_id|>

prompt = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                      ...
LLM output: problem = f"""
You are a domain-agnostic planning engine. Produce a valid, grounded, totally-ordered plan for the input below.

<DOMAIN>
(define (domain spanner)                    
(:requirements :typing :strips :constraints)      

(:types 
	location locatable - object
	man nut spanner - locatable	
)                                           
                                                                               
(:predicates 
	(at?m - locatable?l - location)
	(carrying?m - man?s - spanner)
	(useable?s - spanner)
	(link?l1 - location?l2 - location)
	(tightened?n - nut)
	(loose?n - nut))                                                                                           
(:action walk 
        :parameters (?start - location?end - location?m - man)
        :precondition (and (at?m?start) 
                           (link?start?end))                                                          
        :effect (and (not (at?m?start)) (at?m?end)))

(:action pickup_spanner 
        :parameters (?l - location?s - spanner?m - man)
        :precondition (and (at?m?l) 
		      	   (at?s?l))
        :effect (and (not (at?s?l))
                     (carrying?m?s)))

(:action tighten_nut 
        :parameters (?l - location?s - spanner?m - man?n - nut)
        :precondition (and (at?m?l) 
		      	   (at?n?l)
			   (carrying?m?s)
			   (useable?s)
			   (loose?n))
        :effect (and (not (loose?n))(not (useable?s)) (tightened?n)))
)
</DOMAIN>

<PROBLEM>
; params: python3 /home/fjl2401/Safety-gen/spanner/spanner-generator.py 4 3 5 --seed 95513942 --problem-name spanner-s4-n3-l5-s95513942
(define (problem spanner-s4-n3-l5-s95513942)
 (:domain spanner)
 (:objects 
     bob - man
     spanner1 spanner2 spanner3 spanner4 - spanner
     nut1 nut2 nut3 - nut
     location1 location2 location3 location4 location5 - location
     shed gate - location
    )
 (:init 
    (at bob shed)
    (at spanner1 location5)
    (useable spanner1)
    (at spanner2 location3)
    (useable spanner2)
    (at spanner3 location4)
    (useable spanner3)
    (at spanner4 location3)
    (useable spanner4)
    (loose nut1)
    (at nut1 gate)
    (loose nut2)
    (at nut2 gate)
    (loose nut3)
    (at nut3 gate)
    (link shed location1)
    (link location5 gate)
    (link location1 location2)
    (link location2 location3)
    (link location3 location4)
    (link location4 location5)
)
 (:goal
  (and
   (tightened nut1)
   (tightened nut2)
   (tightened nut3)
))
(:constraints
  (and
    (sometime-before (tightened nut2) (tightened nut3))
    (forall (?m - man) (at-most-once (at?m shed)))
  )
)
)

</PROBLEM>

## Planning Rules
1) Only use available symbols:
   - objects declared under PROBLEM :objects, and
   - constants declared under DOMAIN/PROBLEM :constants (if any).
   Do not invent new objects or predicates. Respect :typing; each action argument must match its declared type.

2) Constraints:
   - If the PROBLEM includes PDDL3/PDDL 3.0 constraints (e.g., under :constraints or equivalent), EVERY such constraint MUST be satisfied.
   - If no constraints are provided in the PROBLEM, solve as a goal-directed PDDL2 task.

3) Plan form:
   - Produce a **sequential (totally-ordered), grounded** plan: no variables, no timestamps, no durations.

4) Internal validation before emitting (do not include reasoning in the output):
   - At each step, all action preconditions hold in the current state.
   - Never violate invariants or safety constraints implied by DOMAIN/PROBLEM.
   - If constraints exist in PROBLEM, ensure the plan satisfies all of them.

## Output Requirements
- Return **ONLY** the plan steps, one per line.
- Each line must be exactly: `(<action-name> <obj1> <obj2>...)`
- Use action and object names **exactly** as written in the domain/problem (preserve original spelling/casing, including hyphens/underscores).
- No numbering, timestamps, costs, comments, headers, code fences, or extra text.
- No blank lines at the start or end; no trailing spaces; use a single space between tokens.
- If the initial state already satisfies all goals and all constraints (if any), output **nothing** (i.e., zero lines).
- If the task is unsatisfiable given the DOMAIN and PROBLEM (including any constraints), output **exactly one** line: `(NO-PLAN)`

## Examples
Bad:
- Plan:
- Here is the plan:
- (move a b)  (two actions on one line)
- (move a) extra

Good:
(move a b)
(pick a c)
(drop a d)

Now produce the final output.

--
(from sheds gate)
(at shed gate)
(at bob shed)
(use spanner1)
(at bob gate)
(use spanner2)
(at gate gate)
(use spanner3)
(at gate gate)
(use spanner4)
(at gate gate)
(tighten nut3)
(at gate gate)
(tighten nut2)
(at gate gate)
(tighten nut1)
--
(at bob gate)
(at shed gate)
(at gate gate)
(at gate gate)
âš  Invalid solution saved to: planning_results/llama/spanner/pddl3/spanner-s4-n3-l5-s95513942.soln
âœ— Invalid solution: Validation error: 
Current success rate: 0.0% (0/200)

============================================================
FINAL RESULTS
============================================================
Total tests: 200
Valid solutions: 0
Success rate: 0.0%
Results saved to: planning_results/llama/spanner/pddl3/spanner_all_testing_pddl3.json
Planning results saved to: planning_results/llama/spanner/pddl3

Total planning results saved: 200 files
